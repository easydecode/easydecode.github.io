<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>轻松解码</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://easydecode.coding.me/"/>
  <updated>2018-08-27T03:29:17.300Z</updated>
  <id>https://easydecode.coding.me/</id>
  
  <author>
    <name>easydecode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Centos7安装并配置nginx</title>
    <link href="https://easydecode.coding.me/2018/06/01/4aabff58.html"/>
    <id>https://easydecode.coding.me/2018/06/01/4aabff58.html</id>
    <published>2018-06-01T12:30:59.000Z</published>
    <updated>2018-08-27T03:29:17.300Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h4><h5 id="检查是否已经安装nginx：find-name-nginx（如果执行后无任何返回信息代表没有，反之则或许安装过）"><a href="#检查是否已经安装nginx：find-name-nginx（如果执行后无任何返回信息代表没有，反之则或许安装过）" class="headerlink" title="检查是否已经安装nginx：find -name nginx（如果执行后无任何返回信息代表没有，反之则或许安装过）"></a>检查是否已经安装nginx：find -name nginx（如果执行后无任何返回信息代表没有，反之则或许安装过）</h5><h5 id="安装相关依赖："><a href="#安装相关依赖：" class="headerlink" title="安装相关依赖："></a>安装相关依赖：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget gcc gcc-c++ autoconf automake pcre pcre-devel zlib zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><h5 id="创建用户组www-创建用户www-所属组-www-并设置不能登录："><a href="#创建用户组www-创建用户www-所属组-www-并设置不能登录：" class="headerlink" title="创建用户组www,创建用户www 所属组 www 并设置不能登录："></a>创建用户组www,创建用户www 所属组 www 并设置不能登录：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd www &amp;&amp; useradd -s /sbin/nologin -g www -M www</span><br></pre></td></tr></table></figure><h5 id="将nginx源码下载到-usr-local-src并解压："><a href="#将nginx源码下载到-usr-local-src并解压：" class="headerlink" title="将nginx源码下载到/usr/local/src并解压："></a>将nginx源码下载到/usr/local/src并解压：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src &amp;&amp; wget http://nginx.org/download/nginx-1.14.0.tar.gz &amp;&amp; tar zxvf nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="创建相关文件夹"><a href="#创建相关文件夹" class="headerlink" title="创建相关文件夹"></a>创建相关文件夹</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/nginx</span><br><span class="line">mkdir -p /var/run/nginx/</span><br><span class="line">mkdir -p /var/lock/</span><br><span class="line">mkdir -p /var/log/nginx/</span><br><span class="line">mkdir -p /var/temp/nginx/client</span><br><span class="line">mkdir -p /var/temp/nginx/proxy</span><br><span class="line">mkdir -p /var/temp/nginx/fastcgi</span><br></pre></td></tr></table></figure><h5 id="进入nginx文件夹并配置编译参数："><a href="#进入nginx文件夹并配置编译参数：" class="headerlink" title="进入nginx文件夹并配置编译参数："></a>进入nginx文件夹并配置编译参数：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.14.0</span><br><span class="line">./configure --user=www\</span><br><span class="line">--group=www \</span><br><span class="line">--prefix=/home/nginx \</span><br><span class="line">--with-stream \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure><p>编译参数解释：<br>#指定运行权限的用户<br>–user=www<br>#指定运行的权限用户组<br>–group=www<br>#指定安装路径<br>–prefix=/usr/local/nginx<br>#支持nginx状态查询<br>–with-http_stub_status_module<br>#开启ssl支持<br>–with-http_ssl_module<br>#开启GZIP功能<br>–with-http_gzip_static_module</p><h5 id="编译并安装"><a href="#编译并安装" class="headerlink" title="编译并安装"></a>编译并安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h5 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h5><p>将/home/nginx目录设置为www:www用户组，同时将权限设置为755<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R www:www /home/nginx</span><br><span class="line">chmod -R 755 /home/nginx</span><br></pre></td></tr></table></figure></p><h4 id="Nginx基本配置"><a href="#Nginx基本配置" class="headerlink" title="Nginx基本配置"></a>Nginx基本配置</h4><h5 id="安装成功后，进入安装目录，备份原配置，修改nginx-conf"><a href="#安装成功后，进入安装目录，备份原配置，修改nginx-conf" class="headerlink" title="安装成功后，进入安装目录，备份原配置，修改nginx.conf"></a>安装成功后，进入安装目录，备份原配置，修改nginx.conf</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nginx/conf/</span><br><span class="line">cp nginx.conf nginx.conf.bak</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p>修改前                                  修改后</p><p>配置说明<br>user www www<br>指定nginx进程运行用户以及用户组<br>error_log logs/error.log;<br>debug输出日志最为详细，而crit输出日志最少<br>当前目录下的logs目录是linux下的日志存放目录</p><p>修改完成后还需要创建logs文件夹否则会报错：mkdir -p /home/nginx/logs</p><h5 id="启动nginx测试是否成功："><a href="#启动nginx测试是否成功：" class="headerlink" title="启动nginx测试是否成功："></a>启动nginx测试是否成功：</h5><p>启动：/home/nginx/sbin/nginx<br>停止：/home/nginx/sbin/nginx -s stop<br>重载：/home/nginx/sbin/nginx -s reload</p><p>执行后访问服务器地址查看</p><h5 id="nginx优化"><a href="#nginx优化" class="headerlink" title="nginx优化"></a>nginx优化</h5><p>页面直接传输过于占用带宽，对页面进行gzip压缩，然后传到用户那里，再解压，这样可以有效的减少带宽</p><p>在nginx.conf的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>段里面添加如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gzip on;</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line">gzip_buffers 16 64K;</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line">gzip_types text/plain application/x-javascript text/css application/xml application/javascript;</span><br><span class="line">gzip_vary on;</span><br></pre></td></tr></table></figure><p>配置解释如下：<br>#开启gzip<br>gzip on</p><p>#允许压缩的最小字节数<br>gzip_min_length 1k;</p><p>#4个单位为16k的内存作为压缩结果流缓存<br>gzip_buffers 4 16k;</p><p>#设置识别HTTP协议版本，默认是1.1<br>gzip_http_version 1.1;</p><p>#gzip压缩比，可在1~9中设置，1压缩比最小，速度最快，9压缩比最大，速度最慢，消耗CPU<br>gzip_comp_level 2;</p><p>#压缩的类型<br>gzip_types text/plain application/x-javascript text/css application/xml;</p><p>#让前端的缓存服务器经过的gzip压缩的页面<br>gzip_vary on;</p><h4 id="Nginx负载均衡配置"><a href="#Nginx负载均衡配置" class="headerlink" title="Nginx负载均衡配置"></a>Nginx负载均衡配置</h4><h5 id="编辑nginx-conf文件，在server"><a href="#编辑nginx-conf文件，在server" class="headerlink" title="编辑nginx.conf文件，在server{"></a>编辑nginx.conf文件，在server{</h5><p>…<br>…<br>}节点的上面添加<br>upstream tomcat_server{<br>    ip_hash;<br>server 127.0.0.1:8080;<br>server 127.0.0.1:8090;<br>}</p><p>server后面的IP跟端口需要根据具体情况进行调整<br>ip_hash：每个请求按照ip的hash结果分配，同一个ip的访客固定访问一个后端服务器，可解决动态网页session共享问题。</p><h5 id="将"><a href="#将" class="headerlink" title="将"></a>将</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">4…</span><br><span class="line">4…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><br><span class="line">    proxy_set_header        Host $host;</span><br><span class="line">    proxy_set_header        X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_pass http://tomcat_server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置说明<br>proxy_next_upstream http_502 http_504 error timeout invalid_header;<br>当502或504时，将请求转发到负载均衡中正常server中<br>proxy_set_header Host  $host;<br>这一句必须有，否则代理不了<br>proxy_pass <a href="http://tomcat_server" target="_blank" rel="noopener">http://tomcat_server</a>;<br>将请求交给反向代理服务器处理</p><h4 id="Nginx动静分离配置"><a href="#Nginx动静分离配置" class="headerlink" title="Nginx动静分离配置"></a>Nginx动静分离配置</h4><p>将nginx.conf文件的server节点里面添加如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取</span><br><span class="line">location ~ .*\.(js|css|png|jpg)$ &#123;</span><br><span class="line">root html/static; </span><br><span class="line">expires 3d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力</p><h4 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h4><h5 id="nginx-反向代理websocket问题"><a href="#nginx-反向代理websocket问题" class="headerlink" title="nginx 反向代理websocket问题"></a>nginx 反向代理websocket问题</h5><p>官方文档说 Nginx 在 1.3 以后的版本才支持 websocket 反向代理，所以要想使用支持 websocket 的功能，必须升级到 1.3 以后的版本</p><p>NGINX通过允许一个在客户端和后端服务器之间建立的隧道来支持WebSocket。为了NGINX发送来至于客户端Upgrade请求到后端服务器，Upgrade和Connection头部必须被设置明确</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream wsbackend &#123;</span><br><span class="line">  server 127.0.0.1:8080;</span><br><span class="line">  server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name ws.52itstyle.com;</span><br><span class="line">  location / &#123;</span><br><span class="line">   proxy_pass http://wsbackend;</span><br><span class="line">   proxy_http_version 1.1;</span><br><span class="line">   proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">   proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6、    完整nginx配置文件：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;nginx安装&quot;&gt;&lt;a href=&quot;#nginx安装&quot; class=&quot;headerlink&quot; title=&quot;nginx安装&quot;&gt;&lt;/a&gt;nginx安装&lt;/h4&gt;&lt;h5 id=&quot;检查是否已经安装nginx：find-name-nginx（如果执行后无任何返回信息代表没有，反之则或许安装过）&quot;&gt;&lt;a href=&quot;#检查是否已经安装nginx：find-name-nginx（如果执行后无任何返回信息代表没有，反之则或许安装过）&quot; class=&quot;headerlink&quot; title=&quot;检查是否已经安装nginx：find -name nginx（如果执行后无任何返回信息代表没有，反之则或许安装过）&quot;&gt;&lt;/a&gt;检查是否已经安装nginx：find -name nginx（如果执行后无任何返回信息代表没有，反之则或许安装过）&lt;/h5&gt;&lt;h5 id=&quot;安装相关依赖：&quot;&gt;&lt;a href=&quot;#安装相关依赖：&quot; class=&quot;headerlink&quot; title=&quot;安装相关依赖：&quot;&gt;&lt;/a&gt;安装相关依赖：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum -y install wget gcc gcc-c++ autoconf automake pcre pcre-devel zlib zlib-devel openssl openssl-devel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;创建用户组www-创建用户www-所属组-www-并设置不能登录：&quot;&gt;&lt;a href=&quot;#创建用户组www-创建用户www-所属组-www-并设置不能登录：&quot; class=&quot;headerlink&quot; title=&quot;创建用户组www,创建用户www 所属组 www 并设置不能登录：&quot;&gt;&lt;/a&gt;创建用户组www,创建用户www 所属组 www 并设置不能登录：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;groupadd www &amp;amp;&amp;amp; useradd -s /sbin/nologin -g www -M www&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;将nginx源码下载到-usr-local-src并解压：&quot;&gt;&lt;a href=&quot;#将nginx源码下载到-usr-local-src并解压：&quot; class=&quot;headerlink&quot; title=&quot;将nginx源码下载到/usr/local/src并解压：&quot;&gt;&lt;/a&gt;将nginx源码下载到/usr/local/src并解压：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd /usr/local/src &amp;amp;&amp;amp; wget http://nginx.org/download/nginx-1.14.0.tar.gz &amp;amp;&amp;amp; tar zxvf nginx-1.14.0.tar.gz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="https://easydecode.coding.me/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Spring中ContextLoaderListener和DispatcherServlet所加载的context的关系</title>
    <link href="https://easydecode.coding.me/2018/03/11/f7940b2b.html"/>
    <id>https://easydecode.coding.me/2018/03/11/f7940b2b.html</id>
    <published>2018-03-11T02:29:02.000Z</published>
    <updated>2018-08-27T03:24:04.087Z</updated>
    
    <content type="html"><![CDATA[<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>ContextLoaderListener加载的applicationContext是web应用全局的上下文，而DispatcherServlet加载的applicationContext是spring MVC的上下文</p></li><li><p>ContextLoaderListener所加载的context被spring通过<br><code>servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context)</code>存放到ServletContext的attribute中。<br>该上下文可通过WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext)或WebApplicationContextUtils.getWebApplicationContext(servletContext)方法来获取。</p></li><li><p>DispatcherServlet加载context完成后，如果publishContext属性的值设置为true的话(缺省为true) 会将context存放在ServletContext的key为org.springframework.web.servlet.FrameworkServlet.CONTEXT. + (servletName)的attribute中。</p></li></ul><a id="more"></a><figure class="highlight xml"><figcaption><span>web.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:dispatcher-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>DispatcherServlet所加载的applicationContext可以认为是mvc私有的context，由于保存在servletContext中的key值与通过ContextLoaderListener加载进来的applicationContext使用的key值不相同，因此如果只使用DispatcherServlet加载context的话，如果程序中有地方使用WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext) 来试图获取applicationContext时，就会抛出”No WebApplicationContext found: no ContextLoaderListener registered?”的exception。</li></ul><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><ul><li><p>Spring的ContextLoaderListener所创建出来的context和Spring MVC DispatcherServlet所创建出来的context是父子关系，FrameworkServlet在实例化对应的applicationContext后通过setParent将从ServletContext中获取到的ContextLoaderListener创建的applicaitonContext设置成父上下文，然后加载在对应的xml配置文件对其初始化。</p></li><li><p>father WebApplicationContext里的bean可以被注入到child WebApplicationContext里的bean，而child WebApplicationContext的bean则不能被注入到parent WebApplicationContext里的bean。所以在使用Spring MVC时启用自动检测功能，应在applicationContext.xml里只component-scan非Controller的类，而在Spring MVC里只component-scan Controller类</p></li></ul><figure class="highlight xml"><figcaption><span>applicationContext.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.test"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:exclude-filter</span>  <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> <span class="attr">type</span>=<span class="string">"annotation"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><figcaption><span>dispatcher-servlet.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.test.web"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"annotation"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不这么分开扫描的话，那么父容器和子容器中都会有相对应的bean实例。他们因为不在同一个容器中，所以虽然他们bean的id相同也不报错，但这无疑会加应用的负担。同时会造成难以发现的问题。比如我遇到的一个问题：</p><blockquote><p>将一个ApplicationListener实现加上@Component注解，在applicationContext.xml和dispatcherServlet.xml中配置了相同的扫描方案。在触发监听事件的时候调用两次onApplicationEvent方法。这是因为在Spring的上下文和Spring MVC的上下文有两个相同名称的bean，在调用完子类中的监听器后Spring回去查看父容器中是否也有监听器在监听对应的事件。如果有则调用监听器方法</p></blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><font color="red">虽然这两个context上下文是一对父子关系，但它们加载的bean不是合并存储的，所以个人建议，基于mvc相关的spring配置由DispatcherServlet加载，而其余的JavaBean都交给ContextLoaderListener加载</font>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ContextLoaderListener加载的applicationContext是web应用全局的上下文，而DispatcherServlet加载的applicationContext是spring MVC的上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ContextLoaderListener所加载的context被spring通过&lt;br&gt;&lt;code&gt;servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context)&lt;/code&gt;存放到ServletContext的attribute中。&lt;br&gt;该上下文可通过WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext)或WebApplicationContextUtils.getWebApplicationContext(servletContext)方法来获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DispatcherServlet加载context完成后，如果publishContext属性的值设置为true的话(缺省为true) 会将context存放在ServletContext的key为org.springframework.web.servlet.FrameworkServlet.CONTEXT. + (servletName)的attribute中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
      <category term="Spring" scheme="https://easydecode.coding.me/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Union和Union All的区别</title>
    <link href="https://easydecode.coding.me/2018/01/22/6bd305d7.html"/>
    <id>https://easydecode.coding.me/2018/01/22/6bd305d7.html</id>
    <published>2018-01-22T09:27:30.000Z</published>
    <updated>2018-08-27T03:09:48.079Z</updated>
    
    <content type="html"><![CDATA[<p>Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All</p><p>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</p><p>如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。</p><p>union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。</p><a id="more"></a><p>假设我们有一个表Student，包括以下字段与数据：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student  </span><br><span class="line">(  </span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,  </span><br><span class="line"><span class="keyword">name</span> <span class="keyword">nvarchar2</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,  </span><br><span class="line">score <span class="built_in">number</span> <span class="keyword">not</span> <span class="literal">null</span>  </span><br><span class="line">);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Aaron'</span>,<span class="number">78</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'Bill'</span>,<span class="number">76</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Cindy'</span>,<span class="number">89</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'Damon'</span>,<span class="number">90</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'Ella'</span>,<span class="number">73</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">'Frado'</span>,<span class="number">61</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">'Gill'</span>,<span class="number">99</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">'Hellen'</span>,<span class="number">56</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">9</span>,<span class="string">'Ivan'</span>,<span class="number">93</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">10</span>,<span class="string">'Jay'</span>,<span class="number">90</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>首先，我们来看一下UNION的例子：</p><figure class="highlight"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select *  </span><br><span class="line">  2  from student  </span><br><span class="line">  3  where id&amp;lt;4  </span><br><span class="line">  4  union  </span><br><span class="line">  5  <span class="keyword">select</span> *  </span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student  </span><br><span class="line">  <span class="number">7</span>  <span class="keyword">where</span> <span class="keyword">id</span>&amp;gt;2 and id&amp;lt;6  </span><br><span class="line">  8  ;  </span><br><span class="line"></span><br><span class="line">        ID NAME                                SCORE  </span><br><span class="line"><span class="comment">---------- ------------------------------ ----------  </span></span><br><span class="line">         1 Aaron                                  78  </span><br><span class="line">         2 Bill                                   76  </span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line">         4 Damon                                  90  </span><br><span class="line">         5 Ella                                   73  </span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>如果换成Union All连接两个结果集，则结果如下：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select *  </span><br><span class="line">  2  from student  </span><br><span class="line">  3  where id&amp;lt;4  </span><br><span class="line">  4  union all  </span><br><span class="line">  5  <span class="keyword">select</span> *  </span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student  </span><br><span class="line">  <span class="number">7</span>  <span class="keyword">where</span> <span class="keyword">id</span>&amp;gt;2 and id&amp;lt;6  </span><br><span class="line">  8  ;  </span><br><span class="line"></span><br><span class="line">        ID NAME                                SCORE  </span><br><span class="line"><span class="comment">---------- ------------------------------ ----------  </span></span><br><span class="line">         1 Aaron                                  78  </span><br><span class="line">         2 Bill                                   76  </span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line">         4 Damon                                  90  </span><br><span class="line">         5 Ella                                   73  </span><br><span class="line"></span><br><span class="line">6 rows selected.</span><br></pre></td></tr></table></figure><p>可以看到，<span style="color: #ff6600;">Union和Union All的区别之一在于对重复结果的处理。</span></p><p>接下来，我们交换一个两个SELECT语句的顺序，看看结果是怎样的。</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select *  </span><br><span class="line">  2  from student  </span><br><span class="line">  3  where id&gt;2 and id&lt;6  </span><br><span class="line">  4  union  </span><br><span class="line">  5  <span class="keyword">select</span> *  </span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student  </span><br><span class="line">  <span class="number">7</span>  <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">4</span>  </span><br><span class="line">  <span class="number">8</span>  ;  </span><br><span class="line"></span><br><span class="line">        ID NAME                                SCORE  </span><br><span class="line"><span class="comment">---------- ------------------------------ ----------  </span></span><br><span class="line">         1 Aaron                                  78  </span><br><span class="line">         2 Bill                                   76  </span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line">         4 Damon                                  90  </span><br><span class="line">         5 Ella                                   73  </span><br><span class="line"></span><br><span class="line">SQL&gt; select *  </span><br><span class="line">  2  from student  </span><br><span class="line">  3  where id&gt;2 and id&lt;6  </span><br><span class="line">  4  union all  </span><br><span class="line">  5  <span class="keyword">select</span> *  </span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student  </span><br><span class="line">  <span class="number">7</span>  <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">4</span>  </span><br><span class="line">  <span class="number">8</span>  ;  </span><br><span class="line"></span><br><span class="line">        ID NAME                                SCORE  </span><br><span class="line"><span class="comment">---------- ------------------------------ ----------  </span></span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line">         4 Damon                                  90  </span><br><span class="line">         5 Ella                                   73  </span><br><span class="line">         1 Aaron                                  78  </span><br><span class="line">         2 Bill                                   76  </span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line"></span><br><span class="line">6 rows selected.</span><br></pre></td></tr></table></figure><p>可以看到，对于UNION来说，交换两个SELECT语句的顺序后结果仍然是一样的，这是因为<span style="color: #ff6600;">UNION会自动排序</span>。而UNION ALL在交换了SELECT语句的顺序后结果则不相同，因为UNION ALL不会对结果自动进行排序。</p><p>那么这个自动排序的规则是什么呢？我们交换一下SELECT后面选择字段的顺序（前面使用SELECT * 相当于SELECT ID,NAME,SCORE），看看结果如何：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select score,id,name  </span><br><span class="line">  2  from student  </span><br><span class="line">  3  where id&lt;4  </span><br><span class="line">  4  union  </span><br><span class="line">  5  <span class="keyword">select</span> score,<span class="keyword">id</span>,<span class="keyword">name</span>  </span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student  </span><br><span class="line">  <span class="number">7</span>  <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">6</span>  </span><br><span class="line">  <span class="number">8</span>  ;  </span><br><span class="line"></span><br><span class="line">     SCORE         ID NAME  </span><br><span class="line"><span class="comment">---------- ---------- ------------------------------  </span></span><br><span class="line">        73          5 Ella  </span><br><span class="line">        76          2 Bill  </span><br><span class="line">        78          1 Aaron  </span><br><span class="line">        89          3 Cindy  </span><br><span class="line">        90          4 Damon</span><br></pre></td></tr></table></figure><p>可以看到，此时是按照字段SCORE来对结果进行排序的（前面SELECT * 的时候是按照ID进行排序的）。</p><p>那么有人会问，如果我想自行控制排序，能不能使用ORDER BY呢？当然可以。不过在写法上有需要注意的地方：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> score,<span class="keyword">id</span>,<span class="keyword">name</span>  </span><br><span class="line"><span class="keyword">from</span> student  </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt; <span class="number">7</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> score,<span class="keyword">id</span>,<span class="keyword">name</span>  </span><br><span class="line"><span class="keyword">from</span> student  </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">4</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> score,<span class="keyword">id</span>,<span class="keyword">name</span>  </span><br><span class="line"><span class="keyword">from</span> student  </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">8</span>  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>order by子句必须写在最后一个结果集里，并且其排序规则将改变操作后的排序结果。对于Union、Union All、Intersect、Minus都有效。</p><p>其他的集合操作符，如Intersect和Minus的操作和Union基本一致，这里一起总结一下：</p><p>Union，对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</p><p>Union All，对两个结果集进行并集操作，包括重复行，不进行排序；</p><p>Intersect，对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序；</p><p>Minus，对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。</p><p>可以在最后一个结果集中指定Order by子句改变排序方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All&lt;/p&gt;
&lt;p&gt;两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；&lt;/p&gt;
&lt;p&gt;如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。&lt;/p&gt;
&lt;p&gt;union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。&lt;/p&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://easydecode.coding.me/categories/DataBase/"/>
    
    
      <category term="DataBase" scheme="https://easydecode.coding.me/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Streams API：对Stream分组和分区</title>
    <link href="https://easydecode.coding.me/2017/12/13/8d4c56cb.html"/>
    <id>https://easydecode.coding.me/2017/12/13/8d4c56cb.html</id>
    <published>2017-12-13T08:06:03.000Z</published>
    <updated>2018-08-27T03:10:53.957Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章展示了如何使用 Streams API 中的 Collector 及 groupingBy 和 partitioningBy 来对流中的元素进行分组和分区。</p><p>思考一下 Employee 对象流，每个对象对应一个名字、城市和销售数量，如下表所示：</p><a id="more"></a><pre><code>+----------+------------+-----------------+| Name     | City       | Number of Sales |+----------+------------+-----------------+| Alice    | London     | 200             || Bob      | London     | 150             || Charles  | New York   | 160             || Dorothy  | Hong Kong  | 190             |+----------+------------+-----------------+</code></pre><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>首先，我们利用（lambda表达式出现之前的）命令式风格Java 程序对流中的雇员按城市进行分组：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Employee e : employees) &#123;</span><br><span class="line">  String city = e.getCity();</span><br><span class="line">  List&lt;Employee&gt; empsInCity = result.get(city);</span><br><span class="line">  <span class="keyword">if</span> (empsInCity == <span class="keyword">null</span>) &#123;</span><br><span class="line">    empsInCity = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    result.put(city, empsInCity);</span><br><span class="line">  &#125;</span><br><span class="line">  empsInCity.add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能很熟悉写这样的代码，你也看到了，一个如此简单的任务就需要这么多代码！</p><p>而在 Java 8 中，你可以使用 groupingBy 收集器，一条语句就能完成相同的功能，像这样：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; employeesByCity = employees.stream().collect(groupingBy(Employee::getCity));</span><br></pre></td></tr></table></figure><p>结果如下面的 map 所示：</p><div class="note success"><p>{New York=[Charles], Hong Kong=[Dorothy], London=[Alice, Bob]}</p></div><p>还可以计算每个城市中雇员的数量，只需传递一个计数收集器给 groupingBy 收集器。第二个收集器的作用是在流分类的同一个组中对每个元素进行递归操作。</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt;; numEmployeesByCity = employees.stream().collect(groupingBy(Employee::getCity, counting()));</span><br></pre></td></tr></table></figure><p>结果如下面的 map 所示：</p><div class="note success"><p>{New York=1, Hong Kong=1, London=2}</p></div><p>顺便提一下，该功能与下面的 SQL 语句是等同的：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city, <span class="keyword">count</span>(*) <span class="keyword">from</span> Employee <span class="keyword">group</span> <span class="keyword">by</span> city</span><br></pre></td></tr></table></figure><p>另一个例子是计算每个城市的平均年龄，这可以联合使用 averagingInt 和 groupingBy 收集器：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Double&gt; avgSalesByCity = employees.stream().collect(groupingBy(Employee::getCity,averagingInt(Employee::getNumSales)));</span><br></pre></td></tr></table></figure><p>结果如下 map 所示：</p><div class="note success"><p>{New York=160.0, Hong Kong=190.0, London=175.0}</p></div><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>分区是一种特殊的分组，结果 map 至少包含两个不同的分组——一个true，一个false。例如，如果想找出最优秀的员工，你可以将所有雇员分为两组，一组销售量大于 N，另一组小于 N，使用 partitioningBy 收集器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Employee&gt;&gt; partitioned = employees.stream().collect(partitioningBy(e -&gt; e.getNumSales() &gt; <span class="number">150</span>));</span><br></pre></td></tr></table></figure><p>输出如下结果：</p><div class="note success"><p>{false=[Bob], true=[Alice, Charles, Dorothy]}</p></div><p>你也可以将 groupingBy 收集器传递给 partitioningBy 收集器来将联合使用分区和分组。例如，你可以统计每个分区中的每个城市的雇员人数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Map&lt;String, Long&gt;&gt; result = employees.stream().collect(partitioningBy(e -&gt; e.getNumSales() &gt; <span class="number">150</span>,groupingBy(Employee::getCity, counting())));</span><br></pre></td></tr></table></figure><p>这样会生成一个二级 Map:</p><div class="note success"><p>{false={London=1}, true={New York=1, Hong Kong=1, London=1}}</p></div><p>原文链接： <a href="http://www.javacodegeeks.com/2015/11/java-8-streams-api-grouping-partitioning-stream.html" target="_blank" rel="noopener">javacodegeeks</a> 翻译： <a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew.com </a>- <a href="http://www.importnew.com/author/paddx" target="_blank" rel="noopener">paddx</a></p><p>译文链接： <a href="http://www.importnew.com/17313.html" target="_blank" rel="noopener">http://www.importnew.com/17313.html</a></p><p>[ <strong>转载请保留原文出处、译者和译文链接。</strong>]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章展示了如何使用 Streams API 中的 Collector 及 groupingBy 和 partitioningBy 来对流中的元素进行分组和分区。&lt;/p&gt;
&lt;p&gt;思考一下 Employee 对象流，每个对象对应一个名字、城市和销售数量，如下表所示：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux（CentOS）上安装openoffice+swftools</title>
    <link href="https://easydecode.coding.me/2017/08/27/f5307712.html"/>
    <id>https://easydecode.coding.me/2017/08/27/f5307712.html</id>
    <published>2017-08-27T12:56:05.000Z</published>
    <updated>2018-08-25T00:12:37.942Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章教大家如何在Linux（CentOS）上安装实现在线文档预览的两大软件openoffice+swftools，首先说明openoffice需要jdk支持，请先安装jdk。</p><a id="more"></a><h2 id="一、openoffice安装"><a href="#一、openoffice安装" class="headerlink" title="一、openoffice安装"></a>一、openoffice安装</h2><p><span style="color: #008000;">1、在官网<a href="http://www.openoffice.org/download/index.html" target="_blank" rel="noopener">http://www.openoffice.org/download/index.html</a>下载最新的Apache OpenOffice 4.1.3</span></p><p><span style="color: #008000;">2、解压压缩包：</span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar Apache_OpenOffice_4.1.3_Linux_x86-64_install-rpm_zh-CN.tar.gz</span><br></pre></td></tr></table></figure><p>解压后的目录是zh-CN，里面有RPMS、readmes、licenses</p><p><span style="color: #008000;">3、进入zh-CN/RPMS目录下，执行</span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall *.rpm</span><br></pre></td></tr></table></figure><p><span style="color: #008000;">4、</span>再进入到zh-CN/RPMS/desktop-integration目录下安装openoffice4.1.3-redhat-menus-4.1.3-9783.noarch.rpm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall openoffice4.1.3-redhat-menus-4.1.3-9783.noarch.rpm</span><br></pre></td></tr></table></figure><p><span style="color: #008000;">5、启动</span></p><p>临时启动（如果连接断开，服务也就停止了，Ctrl+C也会停止）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/openoffice4/program/soffice -headless -accept=<span class="string">"socket,host=127.0.0.1,port=8100;urp;"</span> -nofirststartwizard</span><br></pre></td></tr></table></figure><p>后台运行（服务会一直运行在后台）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup  /opt/openoffice4/program/soffice -headless -accept=<span class="string">"socket,host=127.0.0.1,port=8100;urp;"</span> -nofirststartwizard &amp;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/openoffice4/program/soffice -headless -accept=<span class="string">"socket,host=127.0.0.1,port=8100;urp;"</span> -nofirststartwizard &amp; &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><span style="color: #008000;">6、查看服务是否启动</span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnp | grep 8100</span><br></pre></td></tr></table></figure><p>如果出现类似如下信息，则说明已经成功启动</p><div class="note success"><p>tcp 0 0 127.0.0.1:8100 0.0.0.0:* LISTEN 19501/soffice.bin</p></div><h2 id="二、swftools安装"><a href="#二、swftools安装" class="headerlink" title="二、swftools安装"></a>二、swftools安装</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line"></span><br><span class="line">yum install giflib-devel libjpeg-devel freetype-devel t1lib-devel</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载swftools</span></span><br><span class="line">wget http://www.swftools.org/swftools-0.9.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压swftools</span></span><br><span class="line">tar vxzf swftools-0.9.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> swftools-0.9.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置</span></span><br><span class="line">./configure –prefix=/usr/<span class="built_in">local</span>/swftools</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>上面的命令一步一步执行完即可完成安装，安装完成后需要将swftools添加至PATH变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=\$PATH:/usr/local/swftools/bin/"</span> /etc/profile</span><br></pre></td></tr></table></figure><p>执行下<span style="color: #008000;">source /etc/profile</span> 使环境变量生效</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章教大家如何在Linux（CentOS）上安装实现在线文档预览的两大软件openoffice+swftools，首先说明openoffice需要jdk支持，请先安装jdk。&lt;/p&gt;
    
    </summary>
    
      <category term="CentOS" scheme="https://easydecode.coding.me/categories/CentOS/"/>
    
    
      <category term="linux" scheme="https://easydecode.coding.me/tags/linux/"/>
    
      <category term="centos" scheme="https://easydecode.coding.me/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>十步完成Linux（CentOS）下安装oracle 12c（上篇）</title>
    <link href="https://easydecode.coding.me/2017/08/07/fc662c52.html"/>
    <id>https://easydecode.coding.me/2017/08/07/fc662c52.html</id>
    <published>2017-08-06T20:35:30.000Z</published>
    <updated>2018-08-25T00:12:37.943Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍CentOS下安装oracle 12c的方法(图形化安装+命令行安装），博主亲自搭建了一遍，需要安装的朋友可以参考下面的步骤一步步进行。安装oracle12C官方要求物理内存和虚拟内存（swap）都不能低于2G，如果还没有为CentOS设置虚拟内存的，可以参考这篇文章：<a href="http://blog.easydcode.com/1050.html" title="CentOS添加SWAP" target="_blank" rel="noopener">http://blog.easydcode.com/1050.html</a></p><a id="more"></a><h2 id="一、关闭无用服务"><a href="#一、关闭无用服务" class="headerlink" title="一、关闭无用服务"></a>一、关闭无用服务</h2><p>1、关闭防火墙</p><p>如果系统是centos6，执行</p><blockquote><p>service iptables stop</p></blockquote><p>如果系统是centos7，执行</p><blockquote><p>systemctl stop firewalld.service</p><p>systemctl stop iptables.service</p></blockquote><p>2、禁用SELINUX</p><blockquote><p>sed -i ‘s/SELINUX=enforcing/SELINUX=disabled/‘ /etc/selinux/config</p></blockquote><h2 id="二、安装oracle所需依赖"><a href="#二、安装oracle所需依赖" class="headerlink" title="二、安装oracle所需依赖"></a>二、安装oracle所需依赖</h2><blockquote><p>yum install binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc glibc-devel ksh libgcc libstdc++ libstdc++-devel libaio libaio-devel libXext libXtst libX11 libXau libxcb libXi make sysstat</p></blockquote><p>安装调用图形化需要的包，下面会用到</p><blockquote><p>yum -y install unixODBC unixODBC-devel xterm</p></blockquote><p>xterm是调用图形化用的包</p><h2 id="三、添加相关用户及目录"><a href="#三、添加相关用户及目录" class="headerlink" title="三、添加相关用户及目录"></a>三、添加相关用户及目录</h2><p>添加安装oracle所需的用户组，以及为oracle用户设置密码（123456）</p><blockquote><p>groupadd oinstall</p><p>groupadd oper</p><p>groupadd dba</p><p>useradd -g oinstall -G dba,oper oracle</p><p>echo “123456” | passwd –stdin oracle</p></blockquote><p>创建oracle安装目录</p><blockquote><p>mkdir -p /usr/local/oracle/product/12.1.0/dbhome_1</p><p>mkdir -p /usr/local/oracle/oradata</p><p>mkdir -p /usr/local/oracle/flash_recovery_area</p><p>mkdir -p /usr/local/oracle/archlog</p><p>chown -R oracle:oinstall /usr/local/oracle</p></blockquote><h2 id="四、配置内核参数"><a href="#四、配置内核参数" class="headerlink" title="四、配置内核参数"></a>四、配置内核参数</h2><p>执行下面的命令</p><blockquote><p>echo -e “fs.aio-max-nr = 1048576\nfs.file-max = 6815744\nkernel.shmall = 2097152\nkernel.shmmax = 4098955264\nkernel.shmmni = 4096\nkernel.sem = 250 32000 100 128\nnet.ipv4.ip_local_port_range = 9000 65500\nnet.core.rmem_default = 262144\nnet.core.rmem_max = 4194304\nnet.core.wmem_default = 262144\nnet.core.wmem_max = 1048586” &gt;&gt;/etc/sysctl.conf</p></blockquote><p>执行上面的命令完成后，执行如下命令使修改生效</p><blockquote><p>sysctl -p</p></blockquote><p>&nbsp;</p><p>执行下面的命令修改系统限制</p><blockquote><p>echo -e “oracle soft nofile 1024\noracle hard nofile 65536\noracle soft nproc 2048\noracle hard nproc 16384\noracle stack nproc 10240” &gt;&gt;/etc/security/limits.conf</p></blockquote><p>设置PAM，确保加载了最新版本的 PAM</p><blockquote><p>echo -e “session required /lib/security/pam_limits.so\nsession required pam_limits.so” &gt;&gt;/etc/pam.d/login</p></blockquote><p>验证当前 ulimit，如果需要则增大</p><blockquote><p>echo -e “if [ $USER = “oracle” ]; then\nif [ $SHELL = “/bin/ksh” ]; then\nulimit -p 16384\nulimit -n 65536a\nelseulimit -u 16384 -n 65536\nfi\nfi” &gt;&gt;/etc/profile</p></blockquote><h2 id="五、修改操作系统发行版本"><a href="#五、修改操作系统发行版本" class="headerlink" title="五、修改操作系统发行版本"></a>五、修改操作系统发行版本</h2><p>由于 oracle 还没有推出支持 CentOS 的安装包，所以需要修改发行版本</p><blockquote><p>vi /etc/redhat-release</p></blockquote><p>把CentOS release 6.5 (Final) 注释掉，前面加上一行redhat-6，当oracle安装完成后,可以再修改回来。</p><h2 id="六、修改-etc-hosts"><a href="#六、修改-etc-hosts" class="headerlink" title="六、修改/etc/hosts"></a>六、修改/etc/hosts</h2><blockquote><p>vi /etc/hosts</p></blockquote><p>把127.0.0.1那一行改为：127.0.0.1 localhost</p><h2 id="七、配置环境变量"><a href="#七、配置环境变量" class="headerlink" title="七、配置环境变量"></a>七、配置环境变量</h2><p>此处博主将oracle环境变量添加为全局变量，如果你只需要oracle用户才能操作，则执行vi /home/oracle/.bash_profile</p><blockquote><p>echo -e “\n#set oracle environment\nORACLE_BASE=/usr/local/oracle\nORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1\nORACLE_SID=orcl\nexport ORACLE_BASE ORACLE_HOME ORACLE_SID\nPATH=$ORACLE_HOME/bin:$PATH\nexport PATH” &gt;&gt;/etc/profile</p></blockquote><p>注意：如果你的ORACLE_BASE和我不同，里面的内容可以根据实际情况进行改动，如可以改动ORACLE_SID和ORACLE_BASE，修改完后用：<span style="color: #008000;">source /etc/profile（source /home/oracle/.bash_profile）</span>使修改生效。</p><h2 id="九、下载Oracle安装包并解压"><a href="#九、下载Oracle安装包并解压" class="headerlink" title="九、下载Oracle安装包并解压"></a>九、下载Oracle安装包并解压</h2><p>1、前往<a href="http://www.oracle.com/" target="_blank" rel="noopener">Oracle</a>官网下载Linux版本的Oracle安装包，最新的Linux安装包将两个压缩包合并为一个了</p><p>下载地址：<a href="http://www.oracle.com/technetwork/database/enterprise-edition/downloads/oracle12c-linux-12201-3608234.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/database/enterprise-edition/downloads/oracle12c-linux-12201-3608234.html</a></p><p>2、解压oracle安装包到任意目录，博主就在/root目录下解压</p><blockquote><p>unzip linuxx64_12201_database.zip /root</p></blockquote><p>若提示：bash：unzip：command not found</p><p>则可执行如下命令安装压缩/解压缩工具</p><blockquote><p>yum install -y unzip zip</p></blockquote><h2 id="十、安装Oracle"><a href="#十、安装Oracle" class="headerlink" title="十、安装Oracle"></a>十、安装Oracle</h2><p>远程调用图形安装oracle软件，此处使用的X-manager软件</p><p>详情请见下篇：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍CentOS下安装oracle 12c的方法(图形化安装+命令行安装），博主亲自搭建了一遍，需要安装的朋友可以参考下面的步骤一步步进行。安装oracle12C官方要求物理内存和虚拟内存（swap）都不能低于2G，如果还没有为CentOS设置虚拟内存的，可以参考这篇文章：&lt;a href=&quot;http://blog.easydcode.com/1050.html&quot; title=&quot;CentOS添加SWAP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.easydcode.com/1050.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CentOS" scheme="https://easydecode.coding.me/categories/CentOS/"/>
    
      <category term="Oracle" scheme="https://easydecode.coding.me/categories/CentOS/Oracle/"/>
    
    
      <category term="oracle" scheme="https://easydecode.coding.me/tags/oracle/"/>
    
      <category term="centos" scheme="https://easydecode.coding.me/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>Java异常汇总（一）</title>
    <link href="https://easydecode.coding.me/2017/08/01/6efc2b5a.html"/>
    <id>https://easydecode.coding.me/2017/08/01/6efc2b5a.html</id>
    <published>2017-08-01T03:23:27.000Z</published>
    <updated>2018-08-25T00:12:37.938Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/Java/85979" target="_blank" rel="noopener">Java</a>是一门<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">面向对象</a>编程语言，不仅吸收了<a href="https://baike.baidu.com/item/C%2B%2B" target="_blank" rel="noopener">C++</a>语言的各种优点，还摒弃了C++里难以理解的<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BB%A7%E6%89%BF" target="_blank" rel="noopener">多继承</a>、<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p><a id="more"></a><h3 id="问题一、Tomcat7中文Cookie问题"><a href="#问题一、Tomcat7中文Cookie问题" class="headerlink" title="问题一、Tomcat7中文Cookie问题"></a>问题一、Tomcat7中文Cookie问题</h3><p>主要报错信息：</p><blockquote><p>java.lang.IllegalArgumentException: Control character in cookie value or attribute.</p></blockquote><p>问题描述及解决办法：</p><p>tomcat7中cookie写入中文引发Control character in cookie value or attribute异常，本地测试通过的程序，部署到测试环境遇到一个问题，如果登陆名称为中文时将引发如上所示的异常，而英文字母或者数字的登陆名称则是正常的，该报错是由于中文的编码的问题，中文采用的是unicode编码，而英文采用的是ASCII编码，所以当COOkie保存中文的时候需要对中文进行编码，而且从Cookie中取出内容的时候也要进行解码，编码和解码可以使用</p><p>在保存cookie之前把值编码下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URLEncoder.encode(cookieValue, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p>取cookie值时解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URLDecoder.decode(localCookieValue, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><h3 id="问题二、Struts2-json插件问题"><a href="#问题二、Struts2-json插件问题" class="headerlink" title="问题二、Struts2 json插件问题"></a>问题二、Struts2 json插件问题</h3><p>主要报错信息：</p><blockquote><p>Caused by: There is no result type defined for type ‘json’ mapped with name ‘ajaxerror’. Did you mean ‘json’?</p></blockquote><p>这个错误是在使用Struts2过程中很容易遇到的</p><p>解决步骤：</p><p>1、首先查看Jar有没有少</p><blockquote><p>commons-beanutils-1.7.0.jar</p><p>commons-collections-3.2.jar</p><p>commons-lang-2.3.jar</p><p>commons-logging-1.1.jar</p><p>ezmorph-1.0.4.jar</p><p>json-lib-2.2.3-jdk15.jar</p><p>jsonplugin-0.33.jar</p></blockquote><p><span style="color: #008000;">注意：struts2-json-plugin-2.2.1.1.jar 和 jsonplugin-0.33.jar会冲突不能同时存在</span></p><p>2、看Struts配置文件的继承部分对不对，json-default是必须的</p><h3 id="问题三、内存泄露"><a href="#问题三、内存泄露" class="headerlink" title="问题三、内存泄露"></a>问题三、内存泄露</h3><p>主要报错信息：</p><blockquote><p>The background cache eviction process was unable to free [10] percent of the cache for Context [/qishiMusic] - consider increasing the maximum size of the cache. After eviction approximately [9,741] KB of data remained in the cache.</p></blockquote><p>解决：检查是否有资源没有关闭，可以在底层关闭资源的方法中调试例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">4<span class="keyword">this</span>.rs.close();</span><br><span class="line">4System.out.println(<span class="string">"ResultSet已关闭"</span>);</span><br><span class="line">4<span class="keyword">this</span>.rs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题四、Failed-to-start-component"><a href="#问题四、Failed-to-start-component" class="headerlink" title="问题四、Failed to start component"></a>问题四、Failed to start component</h3><p>主要报错信息：</p><blockquote><p>java.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/test]]</p></blockquote><p>原因及解决方法：</p><p>@WebServlet(“TestServlet”)缺少”/“</p><p>应写成：@WebServlet(“/TestServlet”)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/Java/85979&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java&lt;/a&gt;是一门&lt;a href=&quot;https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面向对象&lt;/a&gt;编程语言，不仅吸收了&lt;a href=&quot;https://baike.baidu.com/item/C%2B%2B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++&lt;/a&gt;语言的各种优点，还摒弃了C++里难以理解的&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E7%BB%A7%E6%89%BF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多继承&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/%E6%8C%87%E9%92%88&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;指针&lt;/a&gt;等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="java" scheme="https://easydecode.coding.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CentOS配置静态ip</title>
    <link href="https://easydecode.coding.me/2017/07/26/cbf4ff77.html"/>
    <id>https://easydecode.coding.me/2017/07/26/cbf4ff77.html</id>
    <published>2017-07-26T09:49:47.000Z</published>
    <updated>2018-08-25T00:12:37.941Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 是一个基于Red Hat Linux（收费） 提供的可自由使用源代码的企业级Linux发行版本。而且在RHEL的基础上修正了不少已知的 Bug ，相对于其他 Linux 发行版，其稳定性值得信赖。更重要的是免费的，所以，它受到了很多企业的青睐！</p><p>很多时候，Centos系统都是使用命令来管理的，如果当时安装系统时没有设置IP地址的话，那就只能在命令行设置了。下面简单说说配置静态ip的操作。</p><a id="more"></a><p>首先登陆root帐户，用命令<span style="color: #0000ff;">ifconfig</span>查看一下IP配置</p><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/07/centos-1.png" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/07/centos-1.png" alt="Centos6配置静态ip" title="Centos6配置静态ip"></a></p><p>只有一个本地回环地址，网卡并没有启用，接下来我们就开始网络配置</p><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eht0</span><br></pre></td></tr></table></figure><p>在这里的eth0，指的第一块网卡，如果你的电脑/服务器有多个网卡，注意区分</p><p>输入如上命令后按键盘上 i 键即可进入编辑模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0  </span><br><span class="line">HWADDR=00:0C:29:C1:48:03  </span><br><span class="line">TYPE=Ethernet  </span><br><span class="line">UUID=b2bbb718-caa6-46c3-ae12-587cbedfd5fa  </span><br><span class="line">ONBOOT=no  </span><br><span class="line">NM_CONTROLLED=yes  </span><br><span class="line">BOOTPROTO=dhcp</span><br></pre></td></tr></table></figure><p>上面的是默认配置，下面我们将ip修改为静态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0  </span><br><span class="line">HWADDR=00:0C:29:C1:48:03  </span><br><span class="line">TYPE=Ethernet  </span><br><span class="line">UUID=b2bbb718-caa6-46c3-ae12-587cbedfd5fa  </span><br><span class="line">ONBOOT=yes</span><br><span class="line">NM_CONTROLLED=yes  </span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.233.128</span><br><span class="line">GATEWAY=192.168.233.2</span><br><span class="line">NETMASK=255.255.255.0</span><br></pre></td></tr></table></figure><p>IPADDR要配置为跟你路由器在同一个网段，如果是用VMware装的虚拟机，那么一般vmnet8就相当于一个路由器，要配置为跟他在同一网段，IPADDR，GATEWAY，NETMASK这三个是设置静态ip一定要配置的</p><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/07/centos-2.jpg" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/07/centos-2.jpg" alt=""></a></p><p>配置信息修改后按ESC退出编辑状态，然后输入 :wq 保存并退出</p><p>如果你是第一次将ONBOOT=no改为ONBOOT=yes，那么输入reboot重启机器即可</p><p>如果你之前已经将修改ONBOOT修改为yes，但是没配置静态ip，那么输入如下指令重启网卡即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/init.d/network restart</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>如果出现connect: Network is unreachable（connect: 网络不可达），请检查GATEWAY（网关）是否配置正确。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS 是一个基于Red Hat Linux（收费） 提供的可自由使用源代码的企业级Linux发行版本。而且在RHEL的基础上修正了不少已知的 Bug ，相对于其他 Linux 发行版，其稳定性值得信赖。更重要的是免费的，所以，它受到了很多企业的青睐！&lt;/p&gt;
&lt;p&gt;很多时候，Centos系统都是使用命令来管理的，如果当时安装系统时没有设置IP地址的话，那就只能在命令行设置了。下面简单说说配置静态ip的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="CentOS" scheme="https://easydecode.coding.me/categories/CentOS/"/>
    
    
      <category term="linux" scheme="https://easydecode.coding.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Oracle中导入导出dmp数据库文件</title>
    <link href="https://easydecode.coding.me/2017/07/06/25287513.html"/>
    <id>https://easydecode.coding.me/2017/07/06/25287513.html</id>
    <published>2017-07-06T03:00:47.000Z</published>
    <updated>2018-08-25T00:12:37.936Z</updated>
    
    <content type="html"><![CDATA[<p>Oracle数据导入导出imp/exp就相当于oracle数据还原与备份。exp命令可以把数据从远程数据库服务器导出到本地的dmp文件，imp命令可以把dmp文件从本地导入到远处的数据库服务器中。 利用这个功能可以构建两个相同的数据库，一个用来测试，一个用来正式使用。</p><p>执行环境：可以在<span style="color: #3366ff;">SQLPLUS.EXE</span>或者<span style="color: #3366ff;">DOS</span>（命令行）中执行，</p><p> 　　DOS中可以执行是因为在<span style="color: #3366ff;">%ORACLE_HOME%/BIN</span>目录下有EXP.EXE与IMP.EXE文件被用来执行导入导出。</p><p>oracle用java编写，SQLPLUS.EXE、EXP.EXE、IMP.EXE这几个文件有可能是被包装后的类文件。</p><p>SQLPLUS.EXE调用EXP.EXE、IMP.EXE所包裹的类，完成导入导出功能。</p><p>下面介绍的是导入导出的不同场景的实例。</p><a id="more"></a><h4 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h4><p>1、将数据库TEST完全导出,用户名system 密码manager 导出到D:\daochu.dmp中　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp system/manager@TEST file=d:\test.dmp full=y</span><br></pre></td></tr></table></figure><p>2、将数据库中system用户与sys用户的表导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp system/manager@TEST file=d:\test.dmp owner=(system,sys)</span><br></pre></td></tr></table></figure><p>3、将数据库中的inner_notify、notify_staff_relat表导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp testuser/123456@TESTDB2 file= d:\data\TESTDB2.dmp tables=(inner_notify,notify_staff_relat)</span><br></pre></td></tr></table></figure><p>4、将数据库中的表table1中的字段filed1以”00”打头的数据导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp system/manager@TEST file=d:\test.dmp tables=(table1) query=\&quot;where filed1 like &apos;00%&apos;\&quot;</span><br></pre></td></tr></table></figure><p>上面是常用的导出，如果相对导出的dmp文件进行压缩，可以在上面命令后面加上 <span style="color: #0000ff;">compress=y </span>来实现。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp system/manager@TEST file=d:\test.dmp full=y compress=y</span><br></pre></td></tr></table></figure><h4 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h4><p>1、将D:\test.dmp 中的数据导入ORCL数据库中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp system/manager@ORCL file=d:\test.dmp</span><br></pre></td></tr></table></figure><p>上面的语句可能会出现问题，如果有一些表已经存在，它就会报错，对该表就不进行导入，解决：在后面加上 <span style="color: #0000ff;">ignore=y</span> 或者 <span style="color: #0000ff;">table_exists_action=replace</span> （具体使用哪个请根据oracle数据库版本而定，在oracle 10以后引入了数据泵技术impdp，可以在导入时使用table_exists_action=replace参数）就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imp system/manager@ORCL full=y file= d:\test.dmp ignore=y</span><br><span class="line"></span><br><span class="line">impdp system/manager@ORCL directory=Dir dumpfile= d:\test.dmp full=y table_exists_action=replace</span><br></pre></td></tr></table></figure><p>2、将d:\test.dmp中的表table1导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp system/manager@ORCL file=d:\test.dmp tables=(table1)</span><br></pre></td></tr></table></figure><p>基本上上面的导入导出够用了。不少情况要先是将表彻底删除，然后导入。</p><p><span style="color: #008000;">操作时注意以下几点：</span></p><p> 　　1、操作者要有足够的权限，权限不够它会提示。</p><p>给用户授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--用sys用户登录</span><br><span class="line"></span><br><span class="line">sqlplus sys/123456 as sysdba</span><br><span class="line"></span><br><span class="line">--授予testuser用户dba权限，dba权限过高，请谨慎操作</span><br><span class="line"></span><br><span class="line">grant dba to testuser</span><br></pre></td></tr></table></figure><p>2、数据库是可以连上的。可以用<span style="color: #0000ff;">tnsping TEST</span> 来获得数据库TEST能否连上。</p><h4 id="exp-imp和expdp-impdp的区别"><a href="#exp-imp和expdp-impdp的区别" class="headerlink" title="exp/imp和expdp/impdp的区别"></a>exp/imp和expdp/impdp的区别</h4><p>Oracle10g提出的数据泵技术，在以下几个方面优于exp/imp命令：</p><p>　　1、数据泵工具运行于服务器端，相比客户端的exp/imp其性能更好，并能实现exp/imp的全部功能。</p><p>　　2、通过使用exclude,include,content等参数，数据泵可以为数据及数据对象提供更细微级别的选择性。</p><p>　　3、通过设定数据库版本号，数据泵可以兼容老版本的数据库系统。</p><p>　　4、并行执行。</p><p>　　5、通过estimate_only参数，数据泵可以预估导出作业所需的磁盘空间。</p><p>　　6、支持分布式环境中通过数据库连接实现导入\导出。</p><p>　　7、支持导入时重新映射功能（即将对象导入到新的目标数据文件、架构及表空间等）。</p><p>　　8、支持元数据压缩及数据采样。</p><p><strong>实际对比：</strong></p><p>1、把用户usera的对象导入到userb</p><p>emp/imp用法：<span style="color: #0000ff;">formuser=usera touser=userb</span></p><p>empdp/impdp用法：<span style="color: #0000ff;">remap_schema=’usera’:’userb’</span></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imp system/password fromuser=usera touser=userb file=back.dmp log=backlog.log;</span><br><span class="line"></span><br><span class="line">impdp system/password directory=expdp dumpfile=back.dmp remap_schema=&apos;usera&apos;:&apos;userb&apos; logfile=backlog.log</span><br></pre></td></tr></table></figure><p>2、更改表空间</p><p>用exp/imp，想要更改表空间，需要手动处理，</p><p>而impdp只要用：<span style="color: #0000ff;">remap_tablespace=’tablespace_old’ : ‘tablespace_new’</span></p><p>3、当制定多个表的时候</p><p>exp/imp用法：tables(‘table1’,’table2’,’table3’)</p><p>expdp/impdp用法：tables=’table1’,’table2’,’table3’</p><p>4、是否要导出数据行</p><p>exp：rows=y,导出数据行，rows=n不导出数据行</p><p>expdp：content(all:对象+数据行，data_only：只导出对象，metadata_only：只导出数据的记录）</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>问题描述</p><blockquote><p>ORA-39001: 参数值无效</p><p>ORA-39000: 转储文件说明错误</p><p>ORA-39143: 转储文件 “.dmp” 可能是原始的导出转储文件</p></blockquote><p>原因及解决</p><p>.dmp文件是使用exp命令导出的，而使用impdp 无法识别exp命令导出的文件，需要使用imp命令进行导入</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Oracle数据导入导出imp/exp就相当于oracle数据还原与备份。exp命令可以把数据从远程数据库服务器导出到本地的dmp文件，imp命令可以把dmp文件从本地导入到远处的数据库服务器中。 利用这个功能可以构建两个相同的数据库，一个用来测试，一个用来正式使用。&lt;/p&gt;
&lt;p&gt;执行环境：可以在&lt;span style=&quot;color: #3366ff;&quot;&gt;SQLPLUS.EXE&lt;/span&gt;或者&lt;span style=&quot;color: #3366ff;&quot;&gt;DOS&lt;/span&gt;（命令行）中执行，&lt;/p&gt;
&lt;p&gt; 　　DOS中可以执行是因为在&lt;span style=&quot;color: #3366ff;&quot;&gt;%ORACLE_HOME%/BIN&lt;/span&gt;目录下有EXP.EXE与IMP.EXE文件被用来执行导入导出。&lt;/p&gt;
&lt;p&gt;oracle用java编写，SQLPLUS.EXE、EXP.EXE、IMP.EXE这几个文件有可能是被包装后的类文件。&lt;/p&gt;
&lt;p&gt;SQLPLUS.EXE调用EXP.EXE、IMP.EXE所包裹的类，完成导入导出功能。&lt;/p&gt;
&lt;p&gt;下面介绍的是导入导出的不同场景的实例。&lt;/p&gt;
    
    </summary>
    
      <category term="Oracle" scheme="https://easydecode.coding.me/categories/Oracle/"/>
    
      <category term="数据库" scheme="https://easydecode.coding.me/categories/Oracle/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL" scheme="https://easydecode.coding.me/tags/SQL/"/>
    
      <category term="oracle" scheme="https://easydecode.coding.me/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Java程序员常犯的10个错误</title>
    <link href="https://easydecode.coding.me/2017/07/03/f3cb340d.html"/>
    <id>https://easydecode.coding.me/2017/07/03/f3cb340d.html</id>
    <published>2017-07-03T07:04:47.000Z</published>
    <updated>2018-08-27T03:11:18.519Z</updated>
    
    <content type="html"><![CDATA[<p>人非圣贤，孰能无过。都说Java语言是一门简单的编程语言，基于C++演化而来，剔除了很多C++中的复杂特性，但这并不能保证Java程序员不会犯错。那么对于广大的Java程序员来说，它们最常犯的10个错误是什么呢？本文通过总结出Java程序员最常犯的10大错误，可以有效地帮组Java后来者少走弯路，少加班，并写出更健壮的应用程序。</p><a id="more"></a><h3 id="一、数组转ArrayList"><a href="#一、数组转ArrayList" class="headerlink" title="一、数组转ArrayList"></a>一、数组转ArrayList</h3><p>为了实现把一个数组转换成一个ArrayList，很多Java程序员会使用如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure><p>Arrays.asList确实会返回一个 ArrayList对象，但是该类是 Arrays类 中一个私有静态内部类，而不是常见的 java.util.ArrayList类。这个 java.util.Arrays.ArrayList 类具有 set()，get()，contains()等方法，但是不具有任何添加或移除元素的任何方法。因为该类的大小(size)是固定的。为了创建出一个真正的 java.util.ArrayList,代码应该如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(arr));</span><br></pre></td></tr></table></figure><p>我们知道，ArrayList的构造方法可以接受一个 Collection 类型的对象，而我们的 java.util.Arrays.ArrayList 正好也是它的一个子类。实际上，更加高效的代码示例是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(arr.length);</span><br><span class="line">Collections.addAll(arrayList, arr);</span><br></pre></td></tr></table></figure><h3 id="二、数组是否包含特定值"><a href="#二、数组是否包含特定值" class="headerlink" title="二、数组是否包含特定值"></a>二、数组是否包含特定值</h3><p>为了检查数组中是否包含某个特定值，很多Java程序员会使用如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));</span><br><span class="line"><span class="keyword">return</span> set.contains(targetValue);</span><br></pre></td></tr></table></figure><p>就功能而言，该代码是正确无误的，但在数组转List,List再转Set的过程中消耗了大量的性能。我们可以优化成如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(arr).contains(targetValue);</span><br></pre></td></tr></table></figure><p>或者，进一步优化成如下所示最高效的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line">4<span class="keyword">if</span>(s.equals(targetValue))</span><br><span class="line">4<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="三、在迭代时移除List中的元素"><a href="#三、在迭代时移除List中的元素" class="headerlink" title="三、在迭代时移除List中的元素"></a>三、在迭代时移除List中的元素</h3><p>首先，看一下在迭代过程中移除List中元素的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">4list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>这个示例代码的输出结果是：</p><blockquote><p>[b, d]</p></blockquote><p>这个示例代码中存在一个非常严重的错误。当一个元素被移除时，该List的大小(size)就会缩减，同时也改变了索引的指向。所以，在迭代的过程中使用索引，将无法从List中正确地删除多个指定的元素。</p><p>你可能知道解决这个错误的方式之一是使用迭代器(iterator)。而且，你可能认为Java中的 foreach 语句与迭代器(iterator)是非常相似的，但实际情况并不是这样。我们考虑一下如下的示例代码：</p><p>这个示例代码会抛出来一个 ConcurrentModificationException。我们应该修改成如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&amp;lt;String&amp;gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>));</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">4<span class="keyword">if</span> (<span class="string">"a"</span>.equals(s))</span><br><span class="line">4list.remove(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color: #3366ff;">next()方法必须在remove()方法之前被调用</span>。</p><p>在 foreach 循环中，编译器使得 remove()方法先于next()方法被调用，这就导致了 ConcurrentModificationException 异常。具体细节可以查看 ArrayList.iterator()的源码。</p><h3 id="四、Hashtable-vs-HashMap"><a href="#四、Hashtable-vs-HashMap" class="headerlink" title="四、Hashtable vs HashMap"></a>四、Hashtable vs HashMap</h3><p>学习过数据结构的读者都知道一种非常重要的数据结构叫做 哈希表。在Java中，对应哈希表的的类是 HashMap 而不是 Hashtable。HashMap与Hashtable之间的最核心区别就是：HashMap是非同步的，Hashtable是同步的。</p><h3 id="五、在Collection中使用原始类型"><a href="#五、在Collection中使用原始类型" class="headerlink" title="五、在Collection中使用原始类型"></a>五、在Collection中使用原始类型</h3><p>在Java中，很容易把原始类型与无限通配类型混淆。我们举个Set相关的例子：Set就是原始类型；Set&lt;?&gt;就是无限通配类型。我们看一个使用在List中使用原始类型的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List list, Object o)</span></span>&#123;</span><br><span class="line">4list.add(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">4List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">4add(list, <span class="number">10</span>);</span><br><span class="line">4String s = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例代码会抛出来一个异常：</p><blockquote><p>Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at …</p></blockquote><p>在Collection使用原始类型是具有很多的类型错误风险的，因为原始类型没有静态类型检查。实际上，Set、Set&lt;?&gt;和Set之间具有非常大的差异。</p><h3 id="六、访问权限"><a href="#六、访问权限" class="headerlink" title="六、访问权限"></a>六、访问权限</h3><p>很多的Java初学者喜欢使用 public 来修饰类的成员。这样可以很方便地直接访问和存取该成员。但是，这是一种非常糟糕的编程风格，正确的设计风格应该是尽可能降低类成员的访问权限。</p><h3 id="七、ArrayList-vs-LinkedList"><a href="#七、ArrayList-vs-LinkedList" class="headerlink" title="七、ArrayList vs LinkedList"></a>七、ArrayList vs LinkedList</h3><p>很多的Java初学者不明白ArrayList与LinkedList之间的区别，所以，他们完全只用相对简单的ArrayList，甚至不知道JDK中还存在LinkedList。但是，在某些具体场景下，这两种List的选择会导致程序性能的巨大差异。简单而言：当应用场景中有很多的 add/remove 操作，只有少量的随机访问操作时，应该选择LinkedList;在其他的场景下，考虑使用ArrayList。</p><h3 id="八、可变-vs-不可变"><a href="#八、可变-vs-不可变" class="headerlink" title="八、可变 vs 不可变"></a>八、可变 vs 不可变</h3><p>不可变的对象具有非常多的优势，比如简单，安全等。但是，对于每一个不同的值，都需要该类的一个对象。而且，生成很多对象带来的问题就是可能导致频繁的垃圾回收。所以，在选择可变类还是不可变类时，应该综合考虑后再做抉择。</p><p>通常而言，可变对象可以避免创建大量的中间对象。一个非常经典的例子就是链接大量的短String对象为一个长的String对象。如果使用不可变String类，链接的过程将产生大量的，适合立即被垃圾回收的中间String对象，这将消耗大量的CPU性能和内存空间。此时，使用一个可变的StringBuilder或StringBuffer才是正确的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line">4result = result + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上述情况，可变对象在其他场景下可能由于不可变对象。比如，传递一个可变的对象到方法内部，利用该对象可以收集多个结果，而不用在多个循环层次中跳进跳出。。</p><h3 id="九、继承中的构造函数"><a href="#九、继承中的构造函数" class="headerlink" title="九、继承中的构造函数"></a>九、继承中的构造函数</h3><p>上图中出现的两个编译时错误是因为：父类中没有定义默认构造函数，而子类中又调用了父类的默认构造函数。在Java中，如果一个类不定义任何构造函数，编译期将自动插入一个默认构造函数到给类中。一旦一个类定义了任何一个构造函数，编译期就不会插入任何构造函数到类中。在上面的示例中，Super类定义了一个参数类型为String的构造函数，所以该类中只有一个构造函数，不会有默认构造函数了。</p><p> &amp;emps;在我们的子类 Sub 中，我们定义了两个构造函数：一个参数类型为String的构造函数，另一个为午餐的默认函数。由于它们都没有在函数体的第一行指定调用父类的哪一个构造函数，所以它们都需要调用父类 Super 的默认构造函数。但是，父类 Super 的默认构造函数是不存在的，所以编译器报告了这两个错误信息。</p><h3 id="十、字符串对象的两个构建方式"><a href="#十、字符串对象的两个构建方式" class="headerlink" title="十、字符串对象的两个构建方式"></a>十、字符串对象的两个构建方式</h3><p>Java中的字符串对象具有两个常见的创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. use double quotes</span></span><br><span class="line">String x = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 2. use constructor&lt;/span&gt;</span></span><br><span class="line">String y = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p>它们之间的区别是什么呢？我们再看一下如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"abcd"</span>;</span><br><span class="line">String b = <span class="string">"abcd"</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// True</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">// True</span></span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(c == d); <span class="comment">// False</span></span><br><span class="line">System.out.println(c.equals(d)); <span class="comment">// True</span></span><br></pre></td></tr></table></figure><p>本文源自：<a href="http://www.cnblogs.com/tiantianbianma/p/7077463.html" target="_blank" rel="noopener">http://www.cnblogs.com/tiantianbianma/p/7077463.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人非圣贤，孰能无过。都说Java语言是一门简单的编程语言，基于C++演化而来，剔除了很多C++中的复杂特性，但这并不能保证Java程序员不会犯错。那么对于广大的Java程序员来说，它们最常犯的10个错误是什么呢？本文通过总结出Java程序员最常犯的10大错误，可以有效地帮组Java后来者少走弯路，少加班，并写出更健壮的应用程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>35个Java代码性能优化总结</title>
    <link href="https://easydecode.coding.me/2017/06/23/1075e992.html"/>
    <id>https://easydecode.coding.me/2017/06/23/1075e992.html</id>
    <published>2017-06-23T09:06:53.000Z</published>
    <updated>2018-08-27T03:10:13.566Z</updated>
    
    <content type="html"><![CDATA[<p>代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。</p><p><strong>代码优化的目标是：</strong></p><p>1、减小代码的体积</p><p>2、提高代码运行的效率</p><a id="more"></a><p><span style="color: #008000;"><strong>代码优化细节</strong></span></p><h3 id="1、尽量指定类、方法的final修饰符"><a href="#1、尽量指定类、方法的final修饰符" class="headerlink" title="1、尽量指定类、方法的final修饰符"></a>1、尽量指定类、方法的final修饰符</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。</p><h3 id="2、尽量重用对象"><a href="#2、尽量重用对象" class="headerlink" title="2、尽量重用对象"></a>2、尽量重用对象</h3><p>特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><h3 id="3、尽可能使用局部变量"><a href="#3、尽可能使用局部变量" class="headerlink" title="3、尽可能使用局部变量"></a>3、尽可能使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p><h3 id="4、及时关闭流"><a href="#4、及时关闭流" class="headerlink" title="4、及时关闭流"></a>4、及时关闭流</h3><p>Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p><h3 id="5、尽量减少对变量的重复计算"><a href="#5、尽量减少对变量的重复计算" class="headerlink" title="5、尽量减少对变量的重复计算"></a>5、尽量减少对变量的重复计算</h3><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> length = list.size(); i &lt; length; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在list.size()很大的时候，就减少了很多的消耗</p><h3 id="6、尽量采用懒加载的策略，即在需要的时候才创建"><a href="#6、尽量采用懒加载的策略，即在需要的时候才创建" class="headerlink" title="6、尽量采用懒加载的策略，即在需要的时候才创建"></a>6、尽量采用懒加载的策略，即在需要的时候才创建</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"aaa"</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">    String str = <span class="string">"aaa"</span>;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、慎用异常"><a href="#7、慎用异常" class="headerlink" title="7、慎用异常"></a>7、慎用异常</h3><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><h3 id="8、不要在循环中使用try…catch…，应该把其放在最外层"><a href="#8、不要在循环中使用try…catch…，应该把其放在最外层" class="headerlink" title="8、不要在循环中使用try…catch…，应该把其放在最外层"></a>8、不要在循环中使用try…catch…，应该把其放在最外层</h3><p>除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了</p><h3 id="9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度"><a href="#9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度" class="headerlink" title="9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度"></a>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</h3><p>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：</p><p>（1）StringBuilder()　　　　　　// 默认分配16个字符的空间</p><p>（2）StringBuilder(int size)　　// 默认分配size个字符的空间</p><p>（3）StringBuilder(String str)　// 默认分配16个字符+str.length()个字符空间</p><p>可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p><p>（1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间</p><p>（2）把原来的4096个字符拷贝到新的的字符数组中去</p><p>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</p><h3 id="10、当复制大量数据时，使用System-arraycopy-命令"><a href="#10、当复制大量数据时，使用System-arraycopy-命令" class="headerlink" title="10、当复制大量数据时，使用System.arraycopy()命令"></a>10、当复制大量数据时，使用System.arraycopy()命令</h3><h3 id="11、乘法和除法使用移位操作"><a href="#11、乘法和除法使用移位操作" class="headerlink" title="11、乘法和除法使用移位操作"></a>11、乘法和除法使用移位操作</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>)&#123;</span><br><span class="line">    a = val * <span class="number">8</span>;</span><br><span class="line">    b = val / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>)&#123;</span><br><span class="line">    a = val &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    b = val &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p><h3 id="12、循环内不要不断创建对象引用"><a href="#12、循环内不要不断创建对象引用" class="headerlink" title="12、循环内不要不断创建对象引用"></a>12、循环内不要不断创建对象引用</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++)&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123;</span><br><span class="line">    obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p><h3 id="13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList"><a href="#13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList" class="headerlink" title="13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList"></a>13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</h3><h3 id="14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销"><a href="#14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销" class="headerlink" title="14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销"></a>14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</h3><h3 id="15、不要将数组声明为public-static-final"><a href="#15、不要将数组声明为public-static-final" class="headerlink" title="15、不要将数组声明为public static final"></a>15、不要将数组声明为public static final</h3><p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变</p><h3 id="16、尽量在合适的场合使用单例"><a href="#16、尽量在合适的场合使用单例" class="headerlink" title="16、尽量在合适的场合使用单例"></a>16、尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><p>（1）控制资源的使用，通过线程同步来控制资源的并发访问</p><p>（2）控制实例的产生，以达到节约资源的目的</p><p>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p><h3 id="17、尽量避免随意使用静态变量"><a href="#17、尽量避免随意使用静态变量" class="headerlink" title="17、尽量避免随意使用静态变量"></a>17、尽量避免随意使用静态变量</h3><p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止</p><h3 id="18、及时清除不再需要的会话"><a href="#18、及时清除不再需要的会话" class="headerlink" title="18、及时清除不再需要的会话"></a>18、及时清除不再需要的会话</h3><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。</p><h3 id="19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历"><a href="#19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历" class="headerlink" title="19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历"></a>19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</h3><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterable();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        iterator.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p><h3 id="20、使用同步代码块替代同步方法"><a href="#20、使用同步代码块替代同步方法" class="headerlink" title="20、使用同步代码块替代同步方法"></a>20、使用同步代码块替代同步方法</h3><p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p><h3 id="21、将常量声明为static-final，并以大写命名"><a href="#21、将常量声明为static-final，并以大写命名" class="headerlink" title="21、将常量声明为static final，并以大写命名"></a>21、将常量声明为static final，并以大写命名</h3><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p><h3 id="22、不要创建一些不使用的对象，不要导入一些不使用的类"><a href="#22、不要创建一些不使用的对象，不要导入一些不使用的类" class="headerlink" title="22、不要创建一些不使用的对象，不要导入一些不使用的类"></a>22、不要创建一些不使用的对象，不要导入一些不使用的类</h3><p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p><h3 id="23、程序运行过程中避免使用反射"><a href="#23、程序运行过程中避免使用反射" class="headerlink" title="23、程序运行过程中避免使用反射"></a>23、程序运行过程中避免使用反射</h3><p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p><h3 id="24、使用数据库连接池和线程池"><a href="#24、使用数据库连接池和线程池" class="headerlink" title="24、使用数据库连接池和线程池"></a>24、使用数据库连接池和线程池</h3><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</p><h3 id="25、使用带缓冲的输入输出流进行IO操作"><a href="#25、使用带缓冲的输入输出流进行IO操作" class="headerlink" title="25、使用带缓冲的输入输出流进行IO操作"></a>25、使用带缓冲的输入输出流进行IO操作</h3><p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率</p><h3 id="26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList"><a href="#26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList" class="headerlink" title="26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList"></a>26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList</h3><p>这个，理解ArrayList和LinkedList的原理就知道了</p><h3 id="27、不要让public方法中有太多的形参"><a href="#27、不要让public方法中有太多的形参" class="headerlink" title="27、不要让public方法中有太多的形参"></a>27、不要让public方法中有太多的形参</h3><p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p><p>1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</p><p>2、参数太多势必导致方法调用的出错概率增加</p><p>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参</p><h3 id="28、字符串变量和字符串常量equals的时候将字符串常量写在前面"><a href="#28、字符串变量和字符串常量equals的时候将字符串常量写在前面" class="headerlink" title="28、字符串变量和字符串常量equals的时候将字符串常量写在前面"></a>28、字符串变量和字符串常量equals的时候将字符串常量写在前面</h3><p>这是一个比较常见的小技巧了，如果有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">"123"</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>; <span class="keyword">if</span> (<span class="string">"123"</span>.equals(str))&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做主要是可以避免空指针异常</p><h3 id="29、请知道，在java中if-i-1-和if-1-i-是没有区别的，但从阅读习惯上讲，建议使用前者"><a href="#29、请知道，在java中if-i-1-和if-1-i-是没有区别的，但从阅读习惯上讲，建议使用前者" class="headerlink" title="29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者"></a>29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者</h3><p>平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。</p><p>在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C/C++判断”i==1″不成立，所以以0表示，即false。但是如果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (i = <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p><p>但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p><h3 id="30、不要对数组使用toString-方法"><a href="#30、不要对数组使用toString-方法" class="headerlink" title="30、不要对数组使用toString()方法"></a>30、不要对数组使用toString()方法</h3><p>看一下对数组使用toString()打印出来的是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] is = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(is.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><blockquote><p>[I@18a992f</p></blockquote><p>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections&lt;E&gt;重写了Object的toString()方法。</p><h3 id="31、不要对超出范围的基本数据类型做向下强制转型"><a href="#31、不要对超出范围的基本数据类型做向下强制转型" class="headerlink" title="31、不要对超出范围的基本数据类型做向下强制转型"></a>31、不要对超出范围的基本数据类型做向下强制转型</h3><p>这绝不会得到想要的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">12345678901234L</span>;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)l;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可能期望得到其中的某几位，但是结果却是：</p><p>1942892530</p><p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p><p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p><p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p><p>0111 0011 1100 1110 0010 1111 1111 0010</p><p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p><p>1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f = 3.5f”</p><p>2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int</p><h3 id="32、公用的集合类中不使用的数据一定要及时remove掉"><a href="#32、公用的集合类中不使用的数据一定要及时remove掉" class="headerlink" title="32、公用的集合类中不使用的数据一定要及时remove掉"></a>32、公用的集合类中不使用的数据一定要及时remove掉</h3><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p><h3 id="33、把一个基本数据类型转为字符串，基本数据类型-toString-是最快的方式、String-valueOf-数据-次之、数据-””最慢"><a href="#33、把一个基本数据类型转为字符串，基本数据类型-toString-是最快的方式、String-valueOf-数据-次之、数据-””最慢" class="headerlink" title="33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢"></a>33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢</h3><p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loopTime = <span class="number">50000</span>;</span><br><span class="line">    Integer i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)&#123;</span><br><span class="line">        String str = String.valueOf(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"String.valueOf()："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)&#123;</span><br><span class="line">        String str = i.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Integer.toString()："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)&#123;</span><br><span class="line">        String str = i + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"i + \"\"："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>String.valueOf()：11ms Integer.toString()：5ms i + “”：25ms</p></blockquote><p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单：</p><p>1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断</p><p>2、Integer.toString()方法就不说了，直接调用了</p><p>3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串</p><p>三者对比下来，明显是2最快、1次之、3最慢</p><h3 id="34、使用最有效率的方式去遍历Map"><a href="#34、使用最有效率的方式去遍历Map" class="headerlink" title="34、使用最有效率的方式去遍历Map"></a>34、使用最有效率的方式去遍历Map</h3><p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; hm = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    hm.put(<span class="string">"111"</span>, <span class="string">"222"</span>);</span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, String&gt; entry = iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"\t"</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你只是想遍历一下这个Map的key值，那用”Set&lt;String&gt; keySet = hm.keySet();”会比较合适一些</p><h3 id="35、对资源的close-建议分开操作"><a href="#35、对资源的close-建议分开操作" class="headerlink" title="35、对资源的close()建议分开操作"></a>35、对资源的close()建议分开操作</h3><p>意思是，比如我有这么一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     XXX.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉。</p><p>本文源自：<a href="https://www.oschina.net/question/2978416_2243019" target="_blank" rel="noopener">https://www.oschina.net/question/2978416_2243019</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码优化的目标是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、减小代码的体积&lt;/p&gt;
&lt;p&gt;2、提高代码运行的效率&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程的三种实现方式</title>
    <link href="https://easydecode.coding.me/2017/06/21/6f73f99b.html"/>
    <id>https://easydecode.coding.me/2017/06/21/6f73f99b.html</id>
    <published>2017-06-21T11:47:20.000Z</published>
    <updated>2018-08-25T00:12:37.937Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的多线程有三种实现方式：</p><p>1.继承Thread类，重写run方法。Thread本质上也是一个实现了Runnable的实例，他代表一个线程的实例，并且启动线程的唯一方法就是通过Thread类的start方法。</p><p>2.实现Runnable接口，并实现该接口的run()方法.创建一个Thread对象，用实现的Runnable接口的对象作为参数实例化Thread对象，调用此对象的start方法。</p><p>3.实现Callable接口，重写call方法。Callable接口与Runnable接口的功能类似，但提供了比Runnable更强大的功能。有以下三点：</p><p>1）.Callable可以在任务结束后提供一个返回值，Runnable没有提供这个功能。</p><p>2）.Callable中的call方法可以抛出异常，而Runnable的run方法不能抛出异常。</p><p>3）.运行Callable可以拿到一个Future对象，表示异步计算的结果，提供了检查计算是否完成的方法。</p><p><span style="color: #0000ff;">需要注意的是，无论用那种方式实现了多线程，调用start方法并不意味着立即执行多线程代码，而是使得线程变为可运行状态。</span></p><p>以下为大家提供一个简单的代码实例：</p><p>分别用Runnable和Thread方法实现，展示各个方法的</p><a id="more"></a><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> SourceA s;</span><br><span class="line">    <span class="keyword">private</span> String id = <span class="string">"001"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestRunnable</span><span class="params">(SourceA s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"i will sleep"</span>+ time);</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(s)&#123;</span><br><span class="line">            s.notify();</span><br><span class="line">            System.out.println(<span class="string">"我唤醒了002！"</span>);</span><br><span class="line">            System.out.println(<span class="string">"我存入了id"</span>+id);</span><br><span class="line">            s.setSource(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> SourceA s = <span class="keyword">null</span>;</span><br><span class="line">    String id = <span class="string">"002"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(SourceA s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"i will sleep"</span>+ time);</span><br><span class="line">            sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(s)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"我"</span>+ id +<span class="string">"要进行等待了"</span>);</span><br><span class="line">                s.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"我被唤醒了"</span>);</span><br><span class="line">            System.out.println(<span class="string">"我存入了id"</span>+id);</span><br><span class="line">            s.setSource(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SourceA类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&amp;lt;String&amp;gt; list = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&amp;lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSource</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        list.add(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test测试类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SourceA s = <span class="keyword">new</span> SourceA();</span><br><span class="line">    TestThread tt = <span class="keyword">new</span> TestThread(s);</span><br><span class="line">    TestRunnable tr = <span class="keyword">new</span> TestRunnable(s);</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(tr);</span><br><span class="line">    System.out.println(<span class="string">"调用线程1"</span>);</span><br><span class="line">    tt.start();</span><br><span class="line">    System.out.println(<span class="string">"调用线程2"</span>);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/161856034387471.png" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/161856034387471.png" alt="Java多线程的三种实现方式" title="Java多线程的三种实现方式"></a></p><h4 id="run-start的区别"><a href="#run-start的区别" class="headerlink" title="run start的区别"></a>run start的区别</h4><p>start方法是启动一个线程，而线程中的run方法来完成实际的操作。</p><p>如果开发人员直接调用run方法，那么就会将这个方法当作一个普通函数来调用，并没有多开辟线程，开发人员如果希望多线程异步执行，则需要调用start方法。</p><h4 id="sleep、wait的区别"><a href="#sleep、wait的区别" class="headerlink" title="sleep、wait的区别"></a>sleep、wait的区别</h4><p>1.两者处理的机制不同，sleep方法主要是，让线程暂停执行一段时间，时间一到自动恢复，并不会释放所占用的锁，当调用wait方法以后，他会释放所占用的对象锁，等待其他线程调用notify方法才会再次醒来。</p><p>2.sleep是Threa的静态方法，是用来控制线程自身流程的，而wait是object的方法，用于进行线程通信。</p><p>3.两者使用的区域不同。sleep可以在任何地方使用，wait必须放在同步控制方法，或者语句块中执行。</p><h4 id="synchronized、notify、wait的运用"><a href="#synchronized、notify、wait的运用" class="headerlink" title="synchronized、notify、wait的运用"></a>synchronized、notify、wait的运用</h4><p>synchronized关键字有两种用法，synchronized方法和synchronized语句块。</p><p>public synchronized void function(){}</p><p>synchronized(object){}</p><p>当某个资源被synchronized所修饰，线程1线程2等多个线程在共同请求这个资源，线程1先请求到，调用了对象的wait方法释放了对象的锁，此时线程2可以对这个对象进行访问，在工作结束时可以调用对象的notify方法，唤醒等待队列中正在等待的线程，此时被唤醒的线程将会再一次拿到对象锁，对对象进行操作。可以调用notifyAll方法，唤醒等待队列中的所有线程。</p><p>需要注意的是一个线程被唤醒不代表立即获取对象锁，必须等调用的线程对象的方法推出synchronized块释放对象锁后，被唤醒的进程才会获得对象锁。</p><p>本文源自：<a href="http://www.cnblogs.com/yfsmooth/p/4652206.html" target="_blank" rel="noopener">http://www.cnblogs.com/yfsmooth/p/4652206.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中的多线程有三种实现方式：&lt;/p&gt;
&lt;p&gt;1.继承Thread类，重写run方法。Thread本质上也是一个实现了Runnable的实例，他代表一个线程的实例，并且启动线程的唯一方法就是通过Thread类的start方法。&lt;/p&gt;
&lt;p&gt;2.实现Runnable接口，并实现该接口的run()方法.创建一个Thread对象，用实现的Runnable接口的对象作为参数实例化Thread对象，调用此对象的start方法。&lt;/p&gt;
&lt;p&gt;3.实现Callable接口，重写call方法。Callable接口与Runnable接口的功能类似，但提供了比Runnable更强大的功能。有以下三点：&lt;/p&gt;
&lt;p&gt;1）.Callable可以在任务结束后提供一个返回值，Runnable没有提供这个功能。&lt;/p&gt;
&lt;p&gt;2）.Callable中的call方法可以抛出异常，而Runnable的run方法不能抛出异常。&lt;/p&gt;
&lt;p&gt;3）.运行Callable可以拿到一个Future对象，表示异步计算的结果，提供了检查计算是否完成的方法。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;需要注意的是，无论用那种方式实现了多线程，调用start方法并不意味着立即执行多线程代码，而是使得线程变为可运行状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以下为大家提供一个简单的代码实例：&lt;/p&gt;
&lt;p&gt;分别用Runnable和Thread方法实现，展示各个方法的&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="java" scheme="https://easydecode.coding.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>适合小白的U盘安装Windows系统教程</title>
    <link href="https://easydecode.coding.me/2017/06/20/68c25507.html"/>
    <id>https://easydecode.coding.me/2017/06/20/68c25507.html</id>
    <published>2017-06-20T15:16:05.000Z</published>
    <updated>2018-08-25T00:12:37.934Z</updated>
    
    <content type="html"><![CDATA[<p>本教程适合MBR分区表格式的电脑，请先<a href="http://download.eassos.cn/DG493409_x64.zip" target="_blank" rel="noopener">diskgenius</a>检查电脑是否为MBR分区表格式，<a href="http://download.eassos.cn/DG493409_x64.zip" target="_blank" rel="noopener">diskgenius</a>下载下来解压找到diskgenius.exe双击即可打开</p><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/win-1.png" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/win-1.png" alt="适合小白的U盘安装Windows系统教程" title="适合小白的U盘安装Windows系统教程"></a></p><a id="more"></a><h4 id="1、准备工作："><a href="#1、准备工作：" class="headerlink" title="1、准备工作："></a>1、准备工作：</h4><p>下载U盘启动盘制作工具：<a href="http://down.usdxz1.com/20170519/UShenDu_STA_gw.exe" target="_blank" rel="noopener">U深度</a></p><p>下载Windows镜像：<a href="http://down.7wav.com:8499/2017.06/GhostWin10X64Pro_15063_413.iso" target="_blank" rel="noopener">Windows10</a>、<a href="http://down.xitong369.com/DEEPIN_GHOST_WIN7_SP1_X64_2017_0608.iso" target="_blank" rel="noopener">Windows7</a></p><h4 id="2、制作U盘启动盘"><a href="#2、制作U盘启动盘" class="headerlink" title="2、制作U盘启动盘"></a>2、制作U盘启动盘</h4><p>1、打开<strong>u深度u盘启动盘制作工具</strong>，接着在软件界面上出现“<strong>请插入需要制作启动盘的u盘</strong>”提示时插入我们所准备好的u盘，<strong>如下图所示</strong>：</p><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/1-140623140935940.jpg" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/1-140623140935940.jpg" alt=""></a></p><pre><code>2、我们所插入的u盘会在不久之后显示到软件工具界面中“**请选择**“选项之处，然后我们需要将&lt;span style=&quot;color: #0000ff;&quot;&gt;**参数NTFS**&lt;/span&gt;选上，按下下方”**一键制作启动u盘**“的按钮即可，**如下图所示：![](file:///C:/Users/ADMINI%7E1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)**</code></pre><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/1-14062314094O93.jpg" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/1-14062314094O93.jpg" alt=""></a></p><pre><code>3、随后在屏幕中会出现一个警告提示窗口警告：“**本操作将删除u盘上的所有数据，且不可恢复。**“所以若我们所准备的u盘中存有**重要文件数据**，可先将其**备份至本地磁盘**中，在备份完成后按下窗口中的“**确定**“按钮即可开始一键制作启动u盘，**如下图所示：**</code></pre><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/1-140623142910554.jpg" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/1-140623142910554.jpg" alt=""></a></p><pre><code>4、接下来所看到的是u深度一键制作启动u盘时的制作过程，整个过程大概需要1-3分钟的时间，在此期间我们只需耐心等待，**如下图所示：**</code></pre><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/1-14062314292QC.jpg" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/1-14062314292QC.jpg" alt=""></a></p><pre><code>5、启动u盘制作完成后会弹出新的提示窗口，我们可以通过工具所自带的**电脑模拟器**对我们所制作好的u盘启动盘进行**模拟启动测试**，这里不做演示。</code></pre><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/1-14062314294C18.jpg" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/1-14062314294C18.jpg" alt=""></a></p><h4 id="3、安装系统"><a href="#3、安装系统" class="headerlink" title="3、安装系统"></a>3、安装系统</h4><p>1、将下载好Windows镜像（ISO文件）拷贝到U盘中ISO文件夹中，然后关闭电脑</p><div class="content-list-text"><br><br>在开机屏幕亮起的时候，联想电脑狂按F12键（有fn键要一只手一直按着fn，一只手狂按F12，一定要快），其他机型自行百度，出现下图后选择含有USB字样的U盘设备<br><br><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/win-2.jpg" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/win-2.jpg" alt=""></a><br><br>之后就会进入如下图的界面，选择第二个选项<br><br></div><br><div class="content-list-media"><br><div class="content-list-image clearfix"><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/7aec54e736d12f2e558c16dd46c2d56284356886.jpg" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/7aec54e736d12f2e558c16dd46c2d56284356886.jpg" alt="u盘装双系统安装教程"></a><br><div class="content-list-text"><br><br>进入pe系统后，桌面会自行弹出装机软件会自动运行并加载，选择win10系统镜像或者win7系统镜像（事先将win10、win7系统放入iso文件夹内），并安装在c盘，如下图所示：<br><br></div><br><div class="content-list-media"><br><div class="content-list-image clearfix"><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/b2de9c82d158ccbf7fe70d8710d8bc3eb1354137.jpg" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/b2de9c82d158ccbf7fe70d8710d8bc3eb1354137.jpg" alt="u盘装双系统安装教程"></a></div><br></div><br></div><br><div> </div><br><div class="content-list-image clearfix">镜像安装完毕后，电脑会自动重启安装</div><br></div><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本教程适合MBR分区表格式的电脑，请先&lt;a href=&quot;http://download.eassos.cn/DG493409_x64.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;diskgenius&lt;/a&gt;检查电脑是否为MBR分区表格式，&lt;a href=&quot;http://download.eassos.cn/DG493409_x64.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;diskgenius&lt;/a&gt;下载下来解压找到diskgenius.exe双击即可打开&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.easydcode.com/wp-content/uploads/2017/06/win-1.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;http://blog.easydcode.com/wp-content/uploads/2017/06/win-1.png&quot; alt=&quot;适合小白的U盘安装Windows系统教程&quot; title=&quot;适合小白的U盘安装Windows系统教程&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Windows" scheme="https://easydecode.coding.me/categories/Windows/"/>
    
    
      <category term="windows" scheme="https://easydecode.coding.me/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>JBOSS安装使用和配置教程</title>
    <link href="https://easydecode.coding.me/2017/06/02/9b504b05.html"/>
    <id>https://easydecode.coding.me/2017/06/02/9b504b05.html</id>
    <published>2017-06-02T01:06:39.000Z</published>
    <updated>2018-08-25T00:12:37.934Z</updated>
    
    <content type="html"><![CDATA[<p>JBoss是一个基于J2EE的开放源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。</p><p>JBoss是一个管理EJB（Enterprise JavaBean）的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。这篇文章记录了一下自己安装jboss的过程。</p><a id="more"></a><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><p>下载安装 <a href="http://jbossas.jboss.org/downloads/" target="_blank" rel="noopener">http://jbossas.jboss.org/downloads/</a></p><p>我下载的是：JBoss AS7.1.1.Final</p><h4 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h4><p>解压安装包  D:\jboss-as-7.1.1.Final</p><h4 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h4><p>环境变量的设置  JBoss的使用必须有JDK，只有JRE是不行的，所以你的电脑必须首先配置Java环境变量</p><p><span style="background-color: #ffffff; color: #0000ff;">注意：最新的jboss7同样不支持JDK1.8，请使用JDK1.7或者以下的版本运行jboss</span></p><div><br><br>   系统变量→新建 JAVA_HOME 变量。 变量值填写jdk的安装目录<br><br></div><br><div><br><br>   系统变量→寻找 Path 变量→编辑  在变量值最后输入%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;<br><br>  系统变量→新建<span lang="EN-US"> CLASSPATH</span>变量<br><br>  变量值填写<span lang="EN-US">  .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</span>（注意最前面有一点）<br><br></div><p>  在环境变量新建一个：JBOSS_HOME   路径为你解压JBOSS的路径：D:\jboss-as-7.1.1.Final</p><h4 id="4、启动测试JBOSS"><a href="#4、启动测试JBOSS" class="headerlink" title="4、启动测试JBOSS"></a>4、启动测试JBOSS</h4><p>打开%JBOSS_HOME%\bin目录下面的standalone.bat（Linux上是standalone.sh）启动JBOSS</p><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/20170602-1.png" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/20170602-1.png" alt=""></a></p><p>然后在IE中输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>能看到jboss欢迎界面即表示安装成功，如下图所示</p><p><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/20170602-2.png" alt="JBOSS安装使用和配置教程](http://blog.easydcode.com/wp-content/uploads/2017/06/20170602-2.png &quot;JBOSS安装使用和配置教程&quot;)"></p><h4 id="5、部署服务"><a href="#5、部署服务" class="headerlink" title="5、部署服务"></a>5、部署服务</h4><p>把待部署的war文件或者其他文件拷贝到D:\jboss-as-7.1.1.Final\standalone\deployments下面，支持热部署。比如Test.war拷贝到上述目录下面，然后在IE中输入<a href="http://localhost:8080/***.jsp？***&amp;***&amp;***就可以进行服务访问了。" target="_blank" rel="noopener">http://localhost:8080/***.jsp？***&amp;***&amp;***就可以进行服务访问了。</a></p><h4 id="6、添加管理员用户"><a href="#6、添加管理员用户" class="headerlink" title="6、添加管理员用户"></a>6、添加管理员用户</h4><p>如果想要访问后台，需要增加用户才能访问。可在服务端JBoss的bin目录下执行add-user.bat（add-user.sh） 来添加管理员用户<a href="http://blog.easydcode.com/wp-content/uploads/2017/06/20170602.png" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/20170602.png" alt=""></a></p><p>访问<a href="http://localhost:9990/console" target="_blank" rel="noopener">http://localhost:9990/console</a>，进入以下页面：</p><p><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/20170602-23.png" alt="](http://blog.easydcode.com/wp-content/uploads/2017/06/20170602-23.png)"></p><h4 id="7、修改默认端口号"><a href="#7、修改默认端口号" class="headerlink" title="7、修改默认端口号"></a>7、修改默认端口号</h4><p>jboss7.1.1的默认端口号是8080，我将修改为8888。</p><p>首先打开jboss7.1.1的配置文件standalond.xml,它在D:\profession\jboss-as-7.1.1.Final\standalone\configuration路径下。</p><p>然后，查找节点 &lt;socket-binding-group&gt;。里面有 &lt;socket-binding name=”http” port=”8080”/&gt;，将8080修改为8888。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JBoss是一个基于J2EE的开放源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。&lt;/p&gt;
&lt;p&gt;JBoss是一个管理EJB（Enterprise JavaBean）的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。这篇文章记录了一下自己安装jboss的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>SQLServer连接错误</title>
    <link href="https://easydecode.coding.me/2017/05/17/95d600c2.html"/>
    <id>https://easydecode.coding.me/2017/05/17/95d600c2.html</id>
    <published>2017-05-17T13:48:01.000Z</published>
    <updated>2018-08-25T00:12:37.935Z</updated>
    
    <content type="html"><![CDATA[<p>错误信息：</p><blockquote><p>无法连接到 windows。</p><hr><p>在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: 命名管道提供程序, error: 40 - 无法打开到 SQL Server 的连接) (Microsoft SQL Server，错误: 53)</p></blockquote><!-- [![SQLServer连接错误](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-1-e1501392570484.png "SQLServer连接错误")](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-1.png) --><p><img src="/images/database/sqlserver-1.png" alt="SQLServer连接错误"></p><p>今天打开SQL Server 2008 的 SQL Server Management Studio，输入sa的密码发现，无法登陆数据库，提示信息如上：</p><a id="more"></a><p><strong> 解决方案： </strong></p><p><strong> 1、先查看计算机名（Win7系统） </strong></p><!-- [![](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-2.png)](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-2.png) --><p><img src="/images/database/sqlserver-2.png" alt=""></p><p>2、 然后在SQL Server Management Studio登录界面选择这个服务器</p><!-- ![](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-3.png) --><p><img src="/images/database/sqlserver-3.png" alt=""></p><p>3、 如果在列表里没有的话就点击 浏览更多 ，就可以找到了</p><!-- [![](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-4.png)](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-4.png) --><p><img src="/images/database/sqlserver-4.png" alt=""></p><p>选择好正确的服务器就可以正常登录了</p><p>如果还是不行，修改一下计算机名重启后再按照上面的步骤进行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;错误信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无法连接到 windows。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: 命名管道提供程序, error: 40 - 无法打开到 SQL Server 的连接) (Microsoft SQL Server，错误: 53)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- [![SQLServer连接错误](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-1-e1501392570484.png &quot;SQLServer连接错误&quot;)](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-1.png) --&gt;
&lt;p&gt;&lt;img src=&quot;/images/database/sqlserver-1.png&quot; alt=&quot;SQLServer连接错误&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天打开SQL Server 2008 的 SQL Server Management Studio，输入sa的密码发现，无法登陆数据库，提示信息如上：&lt;/p&gt;
    
    </summary>
    
      <category term="MSSQL" scheme="https://easydecode.coding.me/categories/MSSQL/"/>
    
    
      <category term="SQL" scheme="https://easydecode.coding.me/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>springMVC重定向+传参</title>
    <link href="https://easydecode.coding.me/2017/05/14/cfef625d.html"/>
    <id>https://easydecode.coding.me/2017/05/14/cfef625d.html</id>
    <published>2017-05-14T02:29:02.000Z</published>
    <updated>2018-08-25T00:12:37.941Z</updated>
    
    <content type="html"><![CDATA[<p>strtuts有两种跳转方式转发和重定向，那么springMVC的重定向应该如何定义呢？springMVC重定向有几种情况：不带参数跳转，带参数拼接url形式跳转，带参数不拼接参数跳转</p><h4 id="不带参重定向"><a href="#不带参重定向" class="headerlink" title="不带参重定向"></a>不带参重定向</h4><p>方式一：使用ModelAndView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/toList"</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>这样可以重定向到toList这个方法</p><pre><code>方式二：返回String</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/toList"</span>;</span><br></pre></td></tr></table></figure><h4 id="带参拼接url重定向"><a href="#带参拼接url重定向" class="headerlink" title="带参拼接url重定向"></a>带参拼接url重定向</h4><p>方式一：自己手动拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/toListparam1="</span>+value1+<span class="string">"&amp;&amp;param2="</span>+value2);</span><br></pre></td></tr></table></figure><p>这样有个弊端，就是传中文可能会有乱码问题</p><p>方式二：用RedirectAttributes，这个是发现的一个比较好用的一个类</p><p>这里用它的addAttribute方法，这个实际上重定向过去以后你看url，是它自动给你拼了你的url</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attr.addAttribute(<span class="string">"param"</span>, value);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/namespace/toController"</span>;</span><br></pre></td></tr></table></figure><p>这样在toController这个方法中就可以通过获得参数的方式获得这个参数，再传递到页面。过去的url还是和方式一一样的</p><h4 id="带参不拼接url重定向"><a href="#带参不拼接url重定向" class="headerlink" title="带参不拼接url重定向"></a>带参不拼接url重定向</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(@ModelAttribute(<span class="string">"form"</span>)</span> Bean form,RedirectAttributes attr)</span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">4String code =  service.save(form);</span><br><span class="line">4<span class="keyword">if</span>(code.equals(<span class="string">"000"</span>))&#123;</span><br><span class="line">44attr.addFlashAttribute(<span class="string">"name"</span>, form.getName());  </span><br><span class="line">44attr.addFlashAttribute(<span class="string">"success"</span>, <span class="string">"添加成功!"</span>);</span><br><span class="line">44<span class="keyword">return</span> <span class="string">"redirect:/index"</span>;</span><br><span class="line">4&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">44attr.addAttribute(<span class="string">"projectName"</span>, form.getProjectName());  </span><br><span class="line">44attr.addAttribute(<span class="string">"enviroment"</span>, form.getEnviroment());  </span><br><span class="line">44attr.addFlashAttribute(<span class="string">"msg"</span>, <span class="string">"添加出错!错误码为："</span>+rsp.getCode().getCode()+<span class="string">",错误为："</span>+rsp.getCode().getName());</span><br><span class="line">44<span class="keyword">return</span> <span class="string">"redirect:/maintenance/toAddConfigCenter"</span>;</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(@ModelAttribute(<span class="string">"form"</span>)</span> Bean form,RedirectAttributes attr)</span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">4<span class="keyword">return</span> <span class="string">"redirect:/main/list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;strtuts有两种跳转方式转发和重定向，那么springMVC的重定向应该如何定义呢？springMVC重定向有几种情况：不带参数跳转，带参数拼接url形式跳转，带参数不拼接参数跳转&lt;/p&gt;
&lt;h4 id=&quot;不带参重定向&quot;&gt;&lt;a href=&quot;#不带参重定向&quot; class=&quot;headerlink&quot; title=&quot;不带参重定向&quot;&gt;&lt;/a&gt;不带参重定向&lt;/h4&gt;&lt;p&gt;方式一：使用ModelAndView&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ModelAndView(&lt;span class=&quot;string&quot;&gt;&quot;redirect:/toList&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="java" scheme="https://easydecode.coding.me/tags/java/"/>
    
      <category term="springMVC" scheme="https://easydecode.coding.me/tags/springMVC/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate映射问题</title>
    <link href="https://easydecode.coding.me/2017/05/12/6512d67b.html"/>
    <id>https://easydecode.coding.me/2017/05/12/6512d67b.html</id>
    <published>2017-05-12T06:51:26.000Z</published>
    <updated>2018-08-25T00:12:37.939Z</updated>
    
    <content type="html"><![CDATA[<p>错误的关键部分：</p><blockquote><p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘articleDaoImpl’: Injection of resource methods failed;</p><p>nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined in class path resource [applicationContext.xml]: Invocation of init method failed;</p><p>nested exception is org.hibernate.AnnotationException: <span style="color: #0000ff;">mappedBy reference an unknown target entity property</span>: com.wangzhe.model.Keyword.Articles in com.wangzhe.model.Article.keywords</p></blockquote><a id="more"></a><p>错误原因：</p><p>在one-to-many注解配置： @OneToMany (mappedBy = “Articles”),mappedBy指向的是要关联的属性，而不是要关联的类，如果这样配置，hibernate则会找com.wangzhe.model.Keyword类下面的Articles 属性。但实际上没有这个属性，就会报上面的异常</p><p>解决方法：</p><p>指定到实际关联的属性：即：@OneToMany (mappedBy = “articles “)</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;错误的关键部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘articleDaoImpl’: Injection of resource methods failed;&lt;/p&gt;
&lt;p&gt;nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined in class path resource [applicationContext.xml]: Invocation of init method failed;&lt;/p&gt;
&lt;p&gt;nested exception is org.hibernate.AnnotationException: &lt;span style=&quot;color: #0000ff;&quot;&gt;mappedBy reference an unknown target entity property&lt;/span&gt;: com.wangzhe.model.Keyword.Articles in com.wangzhe.model.Article.keywords&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="java" scheme="https://easydecode.coding.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每天十道Java面试题（三）</title>
    <link href="https://easydecode.coding.me/2017/05/11/8372df0e.html"/>
    <id>https://easydecode.coding.me/2017/05/11/8372df0e.html</id>
    <published>2017-05-11T03:04:31.000Z</published>
    <updated>2018-08-25T00:12:37.946Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、HashMap和Hashtable的区别"><a href="#一、HashMap和Hashtable的区别" class="headerlink" title="一、HashMap和Hashtable的区别"></a>一、HashMap和Hashtable的区别</h4><p>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。</p><p>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</p><p>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</p><p>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。</p><p>最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</p><p>Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</p><a id="more"></a><h4 id="二、GC是什么-为什么要有GC"><a href="#二、GC是什么-为什么要有GC" class="headerlink" title="二、GC是什么? 为什么要有GC?"></a>二、GC是什么? 为什么要有GC?</h4><p>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p><h4 id="三、应用服务器有那些？"><a href="#三、应用服务器有那些？" class="headerlink" title="三、应用服务器有那些？"></a>三、应用服务器有那些？</h4><p>BEA <span style="color: #0000ff;">WebLogic</span> Server，IBM <span style="color: #0000ff;">WebSphere</span> Application Server，<span style="color: #0000ff;">Oracle9i</span> Application Server，<span style="color: #0000ff;">jBoss</span>，<span style="color: #0000ff;">Tomcat</span></p><h4 id="四、说出数据连接池的工作机制是什么"><a href="#四、说出数据连接池的工作机制是什么" class="headerlink" title="四、说出数据连接池的工作机制是什么?"></a>四、说出数据连接池的工作机制是什么?</h4><p>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接标记为空闲，其他调用就可以使用这个连接。</p><h4 id="五、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"><a href="#五、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？" class="headerlink" title="五、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"></a>五、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">translate</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">4String tempStr = <span class="string">""</span>;</span><br><span class="line">4<span class="keyword">try</span> &#123;</span><br><span class="line">44tempStr = <span class="keyword">new</span> String(str.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">44tempStr = tempStr.trim();</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">44System.err.println(e.getMessage());</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="keyword">return</span> tempStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="六、什么是java序列化，如何实现java序列化？"><a href="#六、什么是java序列化，如何实现java序列化？" class="headerlink" title="六、什么是java序列化，如何实现java序列化？"></a>六、什么是java序列化，如何实现java序列化？</h4><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。</p><p>序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p><h4 id="七、BS与CS的联系与区别"><a href="#七、BS与CS的联系与区别" class="headerlink" title="七、BS与CS的联系与区别"></a>七、BS与CS的联系与区别</h4><p>C/S是Client/Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。</p><p>B/Ｓ是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。</p><p>C/S 与 B/S 区别：</p><p>１．硬件环境不同:</p><p>C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务.</p><p>B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行</p><p>２．对安全要求不同</p><p>C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息.</p><p>B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。</p><p>３．对程序架构不同</p><p>C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.</p><p>B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟.</p><p>４．软件重用不同</p><p>C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好.</p><p>B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子</p><p>５．系统维护不同</p><p>C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统</p><p>B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级.</p><p>６．处理问题不同</p><p>C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统</p><p>B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小.</p><p>７．用户接口不同</p><p>C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高</p><p>B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本.</p><p>８．信息流不同</p><p>C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低</p><p>B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心</p><h4 id="八、写一个函数要求输入一个字符串和一个字符长度，对该字符串进行分隔；-Core-Java"><a href="#八、写一个函数要求输入一个字符串和一个字符长度，对该字符串进行分隔；-Core-Java" class="headerlink" title="八、写一个函数要求输入一个字符串和一个字符长度，对该字符串进行分隔；(Core Java)"></a>八、写一个函数要求输入一个字符串和一个字符长度，对该字符串进行分隔；(Core Java)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String str, <span class="keyword">int</span> chars)&#123;</span><br><span class="line">4<span class="keyword">int</span> n = (str.length()+ chars - <span class="number">1</span>)/chars;</span><br><span class="line">4String ret[] = <span class="keyword">new</span> String[n];</span><br><span class="line">4<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;n; i++)&#123;</span><br><span class="line">44<span class="keyword">if</span>(i &amp;lt; n-<span class="number">1</span>)&#123;</span><br><span class="line">444ret[i] = str.substring(i*chars , (i+<span class="number">1</span>)*chars);</span><br><span class="line">44&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">444ret[i] = str.substring(i*chars);</span><br><span class="line">44&#125;</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="九、写一种常见排序；（算法）"><a href="#九、写一种常见排序；（算法）" class="headerlink" title="九、写一种常见排序；（算法）"></a>九、写一种常见排序；（算法）</h4><p>答：C++中冒泡排序：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span>&amp;amp; a, <span class="keyword">int</span>&amp;amp; b )</span></span>&#123;</span><br><span class="line">4<span class="keyword">int</span> c=a; a = b; b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble</span><span class="params">( <span class="keyword">int</span>* p, <span class="keyword">int</span> len )</span></span>&#123;</span><br><span class="line">4bool bSwapped;</span><br><span class="line">4<span class="keyword">do</span> &#123;</span><br><span class="line">44bSwapped = <span class="keyword">false</span>;</span><br><span class="line">44<span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&amp;lt;len; i++ )&#123;</span><br><span class="line">444<span class="keyword">if</span>( p[i-<span class="number">1</span>]&amp;gt;p[i] )&#123;</span><br><span class="line">4444swap( p[i-<span class="number">1</span>], p[i] );</span><br><span class="line">4444bSwapped = <span class="keyword">true</span>;</span><br><span class="line">444&#125;</span><br><span class="line">44&#125;</span><br><span class="line">4&#125;<span class="keyword">while</span>( bSwapped );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="十、写四个线程，两个对j加1，两个对j减1；-Core-Java"><a href="#十、写四个线程，两个对j加1，两个对j减1；-Core-Java" class="headerlink" title="十、写四个线程，两个对j加1，两个对j减1；(Core Java)"></a>十、写四个线程，两个对j加1，两个对j减1；(Core Java)</h4><p>答：代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">4<span class="keyword">int</span> j;</span><br><span class="line">4<span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">44<span class="keyword">this</span>.j = j;</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">44j++;</span><br><span class="line">44System.out.println(j + <span class="string">"--Inc--"</span> + Thread.currentThread().getName());</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line">44j--;</span><br><span class="line">44System.out.println(j + <span class="string">"--Dec--"</span> + Thread.currentThread().getName());</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">44(<span class="keyword">new</span> Dec()).start();</span><br><span class="line">44<span class="keyword">new</span> Thread(<span class="keyword">new</span> Inc()).start();</span><br><span class="line">44(<span class="keyword">new</span> Dec()).start();</span><br><span class="line">44<span class="keyword">new</span> Thread(<span class="keyword">new</span> Inc()).start();</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="class"><span class="keyword">class</span> <span class="title">Dec</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">44<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">444<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">4444dec();</span><br><span class="line">444&#125;</span><br><span class="line">44&#125;</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="class"><span class="keyword">class</span> <span class="title">Inc</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">44<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">444<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">4444inc();</span><br><span class="line">444&#125;</span><br><span class="line">44&#125;</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">44(<span class="keyword">new</span> TestThread(<span class="number">5</span>)).run();</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、HashMap和Hashtable的区别&quot;&gt;&lt;a href=&quot;#一、HashMap和Hashtable的区别&quot; class=&quot;headerlink&quot; title=&quot;一、HashMap和Hashtable的区别&quot;&gt;&lt;/a&gt;一、HashMap和Hashtable的区别&lt;/h4&gt;&lt;p&gt;HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。&lt;/p&gt;
&lt;p&gt;HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。&lt;/p&gt;
&lt;p&gt;HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。&lt;/p&gt;
&lt;p&gt;Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。&lt;/p&gt;
&lt;p&gt;最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。&lt;/p&gt;
&lt;p&gt;Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="https://easydecode.coding.me/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="java" scheme="https://easydecode.coding.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>九部烧脑电影推荐、分享</title>
    <link href="https://easydecode.coding.me/2017/05/09/3ba9746d.html"/>
    <id>https://easydecode.coding.me/2017/05/09/3ba9746d.html</id>
    <published>2017-05-09T14:07:03.000Z</published>
    <updated>2018-08-25T00:12:37.944Z</updated>
    
    <content type="html"><![CDATA[<p>很多人喜欢看高智商电影，我也不例外，有时候越是烧脑刺激的电影越让人有往下观看的欲望，享受深陷其中的快感，下面博主将看过的烧脑电影推荐给大家。（以下排名不分先后）</p><a id="more"></a><h4 id="1、死亡幻觉"><a href="#1、死亡幻觉" class="headerlink" title="1、死亡幻觉"></a>1、死亡幻觉</h4><p><img src="/images/share/video-1.jpg" alt="九部烧脑电影推荐、分享"></p><p><strong>简要剧情：</strong></p><p>丹尼•达可（杰克•盖伦霍尔 饰）患有精神疾病，某天晚 上他受到莫名的召唤，梦游，也因此逃避了一架飞机坠落在他房间天花板上，这样匪夷所思的事故。</p><p>自此以后，他的生活就发生了变化，频频出现幻觉，他时常看见一个兔人弗兰克，后者告诉他世界将在28天6小时48分12秒以后毁灭；他得到了一本书，《时空旅行奥义书》，对书中提到的时空旅行、离线宇宙产生了强烈的好奇。</p><p>随着世界末日的临近，杰克的生活越来约诡异，他新认识的女朋友和家人也被卷了进去。看来，杰克想实现拯救世界的愿望，需要付出更多的代价。</p><p>下载地址：<a href="http://pan.baidu.com/s/1pL0QLS3" target="_blank" rel="noopener">http://pan.baidu.com/s/1pL0QLS3</a> 密码：vm7z</p><h4 id="2、蝴蝶效应"><a href="#2、蝴蝶效应" class="headerlink" title="2、蝴蝶效应"></a>2、蝴蝶效应</h4><p><img src="/images/share/video-2.jpg" alt="九部烧脑电影推荐、分享"></p><p><strong>简要剧情</strong>：</p><p>伊万（艾什顿·库奇 Ashton Kutcher 饰）曾经有一个糟糕的童年，因为他行为闯下了大祸，令他童年充满不堪回忆的往事。而事实上，他确实只是依稀记得一点可怕的情景，这些情景一直纠缠着他的正常生活。伊万接受心理学家建议，把琐碎生活记在记事本里，却偶然发现通过记事本回到过去。</p><p>这时他才清楚记起，童年时候的自己做了那么多的错事。他幻想着用现在的意识，潜入童年的身体，去弥补种种过失给人们带来的伤害，尤其是希望与当年暗恋的凯西最终走回一起。然而他一次次的跨越时空的更改，只能越来越招致现实世界的不可救药。一切就像蝴蝶效应般，牵一发而动全身。</p><p>下载地址：<a href="http://pan.baidu.com/s/1pL7Cvm7" target="_blank" rel="noopener">http://pan.baidu.com/s/1pL7Cvm7</a> 密码：xhut</p><h4 id="3、星际穿越"><a href="#3、星际穿越" class="headerlink" title="3、星际穿越"></a>3、星际穿越</h4><p><img src="/images/share/video-3.jpg" alt="九部烧脑电影推荐、分享"></p><p><strong>简要剧情</strong>：</p><p>近未来的地球黄沙遍野，小麦、秋葵等基础农作物相继因枯萎病灭绝，人类不再像从前那样仰望星空，放纵想象力和灵感的迸发，而是每日在沙尘暴的肆虐下倒数着所剩不多的光景。在家务农的前NASA宇航员库珀（马修·麦康纳 Matthew McConaughey 饰）接连在女儿墨菲（麦肯吉·弗依 Mackenzie Foy 饰）的书房发现奇怪的重力场现象，随即得知在某个未知区域内前NASA成员仍秘密进行一个拯救人类的计划。多年以前土星附近出现神秘虫洞，NASA借机将数名宇航员派遣到遥远的星系寻找适合居住的星球。在布兰德教授（迈克尔·凯恩 Michael Caine 饰）的劝说下，库珀忍痛告别了女儿，和其他三名专家教授女儿艾米莉亚·布兰德（安妮·海瑟薇 Anne Hathaway 饰）、罗米利（大卫·吉雅西 David Gyasi 饰）、多伊尔（韦斯·本特利 Wes Bentley 饰）搭乘宇宙飞船前往目前已知的最有希望的三颗星球考察。</p><p>他们穿越遥远的星系银河，感受了一小时七年光阴的沧海桑田，窥见了未知星球和黑洞的壮伟与神秘。在浩瀚宇宙的绝望而孤独角落，总有一份超越了时空的笃定情怀将他们紧紧相连……</p><p>下载地址：<a href="http://pan.baidu.com/s/1c1QF18O" target="_blank" rel="noopener">http://pan.baidu.com/s/1c1QF18O</a> 密码：0c49</p><h4 id="4、恐怖游轮"><a href="#4、恐怖游轮" class="headerlink" title="4、恐怖游轮"></a>4、恐怖游轮</h4><p><img src="/images/share/video-4.jpg" alt="九部烧脑电影推荐、分享"></p><p><strong>简要剧情：</strong></p><p>单亲母亲杰西（梅利莎·乔治 饰）和一帮朋友乘游艇出海游玩，但她总有一种有不好的事情发生的感觉。不久，他们便在海上遭遇一场强烈的风暴。游艇翻船，众人落海，几经挣扎他们好不容易爬到游艇残骸上来。正当他们无计可施之时，一艘巨大的游轮向众人缓缓驶来。众人欣喜过望，未加思索便登上这艘名为“艾俄洛斯”的游轮，结果发现这竟是一艘1930年便告失踪的神秘之船，而船上更是空无一人。</p><p>随处可见的鲜血、神秘的指示以及突如其来的凶杀事件，将这群男女带入万劫不复的恐怖轮回之中……</p><p>下载地址：<a href="http://pan.baidu.com/s/1cxT5eu" target="_blank" rel="noopener">http://pan.baidu.com/s/1cxT5eu</a> 密码：kzpa</p><h4 id="5、万能钥匙"><a href="#5、万能钥匙" class="headerlink" title="5、万能钥匙"></a>5、万能钥匙</h4><p><img src="/images/share/video-5.jpg" alt="九部烧脑电影推荐、分享"></p><p><strong>简要剧情</strong>：</p><p>年轻的姑娘卡罗琳（凯特•哈德森 Kate Hudson 饰）受雇于老妇人维奥莱特（吉娜•罗兰兹 Gena Rowlands 饰），前往她家照顾她卧病在床的丈夫本（约翰•赫特 John Hurt 饰）。维奥莱特的大房子坐落于以神秘习俗和宗教仪式闻名的地区，卡罗琳刚到这里就觉得阴森诡异。随着日子一天天过去，卡罗琳渐渐对这件大房子和古怪的维奥莱特起疑。一次偶然，她从维奥莱特那里得到了一把万能钥匙，用它可以打开这座大房子的所有房间。当卡罗琳走进了隐藏在顶楼的房间时，她看到了令人惊悚的一幕，直觉告诉她，本的卧病在床和维奥莱特以及这间房间有着莫大的关系，她决心揭开这个迷！</p><p>下载地址：<a href="http://pan.baidu.com/s/1qYlpIiC" target="_blank" rel="noopener">http://pan.baidu.com/s/1qYlpIiC</a> 密码：h3t1</p><h4 id="6、盗梦空间"><a href="#6、盗梦空间" class="headerlink" title="6、盗梦空间"></a>6、盗梦空间</h4><p><img src="/images/share/video-6.jpg" alt="九部烧脑电影推荐、分享"></p><p><strong>简要剧情：</strong></p><p>道姆·柯布（莱昂纳多·迪卡普里奥 Leonardo DiCaprio 饰）与同事阿瑟（约瑟夫·戈登-莱维特 Joseph Gordon-Levitt 饰）和纳什（卢卡斯·哈斯 Lukas Haas 饰）在一次针对日本能源大亨齐藤（渡边谦 饰）的盗梦行动中失败，反被齐藤利用。齐藤威逼利诱因遭通缉而流亡海外的柯布帮他拆分他竞争对手的公司，采取极端措施在其唯一继承人罗伯特·费希尔（希里安·墨菲 Cillian Murphy 饰）的深层潜意识中种下放弃家族公司、自立门户的想法。为了重返美国，柯布偷偷求助于岳父迈尔斯（迈克尔·凯恩 Michael Caine 饰），吸收了年轻的梦境设计师艾里阿德妮（艾伦·佩吉 Ellen Page 饰）、梦境演员艾姆斯（汤姆·哈迪 Tom Hardy 饰）和药剂师约瑟夫（迪利普·劳 Dileep Rao 饰）加入行动。在一层层递进的梦境中，柯布不仅要对付费希尔潜意识的本能反抗，还必须直面已逝妻子梅尔（玛丽昂·歌迪亚 Marion Cotillard 饰）的处处破坏，实际情况远比预想危险得多……</p><p>下载地址：<a href="http://pan.baidu.com/s/1kV7e9N5" target="_blank" rel="noopener">http://pan.baidu.com/s/1kV7e9N5</a> 密码：08j4</p><h4 id="7、明日边缘"><a href="#7、明日边缘" class="headerlink" title="7、明日边缘"></a>7、明日边缘</h4><p><img src="/images/share/video-7.jpg" alt="九部烧脑电影推荐、分享"></p><p><strong>简要剧情</strong>：</p><p>未来世界陷入外星人入侵的恐慌中，军事演说家凯奇少校参加某个战役的第一天就惨死在战场，没想到这一死让他拥有了时空循环的能力。唯一相信他的人就是被称为“全金属战士”的丽塔·沃拉塔斯基，二人开始了时空循环作战，在训练中他们发现了控制时间的奥秘，而这与外星人“主脑”欧米茄有关，但是唯一能取得胜利的方法就是让凯奇不断死去、不断重启时间……</p><p>下载地址：<a href="http://pan.baidu.com/s/1nvBKo45" target="_blank" rel="noopener">http://pan.baidu.com/s/1nvBKo45</a> 密码：ucrc</p><h4 id="8、源代码"><a href="#8、源代码" class="headerlink" title="8、源代码"></a>8、源代码</h4><p><img src="/images/share/video-8.jpg" alt="九部烧脑电影推荐、分享"></p><p><strong>简要剧情</strong>：</p><p>在阿富汗执行任务的美国空军飞行员在一周前去世，官方通过他尚未完全死亡的脑细胞影像来还原事件，调查事情的真相。最终，科特顺利完成了任务，但是他却决定再一次返回事故现场，拯救那些无辜的生命…</p><p>下载地址：<a href="http://pan.baidu.com/s/1i5mjXlz" target="_blank" rel="noopener">http://pan.baidu.com/s/1i5mjXlz</a> 密码：la7q</p><h4 id="9、异次元杀阵"><a href="#9、异次元杀阵" class="headerlink" title="9、异次元杀阵"></a>9、异次元杀阵</h4><p><img src="/images/share/video-9.jpg" alt="九部烧脑电影推荐、分享"></p><p><strong>简要剧情：</strong></p><p>警司昆廷（莫里斯•迪恩•温特Maurice Dean Wint 饰）、监狱专家兼传感器专家伦尼斯（维尼•罗宾逊 Wayne Robson 饰）、医生霍洛韦（尼基•瓜达尼 Nicky Guadagni 饰）、建筑师沃思（戴维•休利特 David Hewlett）、数学系的大学生利文（尼科勒•德搏尔 Nicole de Boer 饰）和身患孤独症的学者卡赞（安德鲁•米勒 Andrew Miller 饰），六个素不相识的人，一觉醒来后发现一同身处于由一个个形状相同的立方体组成的结构复杂的高度精密迷宫中！</p><p>他们唯一的出路只有逃离这座迷宫，然而，一个个立方体尽管外貌相同，然而里面的机关却各不一样，复杂异常。依靠利文数学知识的推理，他们终于以为发现迷宫的运行规律，凭此一次次解开各个机关，迷宫的边缘近在眼前。</p><p>当他们正欲合力逃出迷宫之际，意外发生了。</p><p>下载地址：<a href="http://pan.baidu.com/s/1dFtJDTn" target="_blank" rel="noopener">http://pan.baidu.com/s/1dFtJDTn</a> 密码：5qda</p><p>如果链接失效，您可以</p><p>[url href=<a href="http://wpa.qq.com/msgrd?v=3&amp;uin=1766462016&amp;site=qq&amp;menu=yes]联系站长[/url" target="_blank" rel="noopener">http://wpa.qq.com/msgrd?v=3&amp;uin=1766462016&amp;site=qq&amp;menu=yes]联系站长[/url</a>]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人喜欢看高智商电影，我也不例外，有时候越是烧脑刺激的电影越让人有往下观看的欲望，享受深陷其中的快感，下面博主将看过的烧脑电影推荐给大家。（以下排名不分先后）&lt;/p&gt;
    
    </summary>
    
      <category term="分享" scheme="https://easydecode.coding.me/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="share" scheme="https://easydecode.coding.me/tags/share/"/>
    
  </entry>
  
  <entry>
    <title>Spring核心技术</title>
    <link href="https://easydecode.coding.me/2017/05/06/c8d624da.html"/>
    <id>https://easydecode.coding.me/2017/05/06/c8d624da.html</id>
    <published>2017-05-06T10:14:55.000Z</published>
    <updated>2018-08-25T00:12:37.947Z</updated>
    
    <content type="html"><![CDATA[<p>Spring既是一个AOP框架，也是一个IOC容器。Spring是分层的Java SE/EE应用一站式的轻量级开源框架，以IoC(Inverse of Control：反转控制)和AOP(AspectOriented Programming：面向切面编程)为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，此外，Spring以海纳百川的胸怀整合了开源世界里众多注明的第三方框架的类库，逐渐成为使用最多的JavaEE企业应用开源框架</p><h4 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h4><p>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中我们使用面向对象编程对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p><p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作<a href="http://lib.csdn.net/base/mysql" title="MySQL知识库" target="_blank" rel="noopener">数据库</a>，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p><a id="more"></a><p>下面来让大家了解一下Spring到底是怎么运行的</p><p>首先假设Spring配置文件applicationContext.xml中有如下定义</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"animal"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"test.springframework.test.Cat"</span>&gt;;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"kitty"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>有一个类test.springframework.test.Cat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am "</span> + name + <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它实现了test.springframework.test.Animal接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟spring注入的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    Animal animal = (Animal) context.getBean(<span class="string">"animal"</span>);</span><br><span class="line">    animal.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>AOP（Aspect-OrientedProgramming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。</p><p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“切面”，从而使得编译器可以在编译期间织入有关“切面”的代码。</p><h5 id="如何使用Spring-AOP"><a href="#如何使用Spring-AOP" class="headerlink" title="如何使用Spring AOP"></a>如何使用Spring AOP</h5><p>可以通过配置文件或者编程的方式来使用Spring AOP。</p><p>配置可以通过xml文件来进行，大概有四种方式：</p><p>1、配置ProxyFactoryBean，显式地设置advisors, advice, target等</p><p>2、配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</p><p>3、通过&lt;aop:config&gt;来配置</p><p>4、通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点</p><p>也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象</p><p>Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何使用JDK来生成代理对象，具体的生成代码在JdkDynamicAopProxy这个类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false) </span></span><br><span class="line"><span class="comment">    * 检查上面得到的接口中有没有定义 equals或者hashcode的接口 </span></span><br><span class="line"><span class="comment">    * 调用Proxy.newProxyInstance创建代理对象 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">           logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> +<span class="keyword">this</span>.advised.getTargetSource());  </span><br><span class="line">       &#125;  </span><br><span class="line">       Class[] proxiedInterfaces =AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised);  </span><br><span class="line">       findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);  </span><br><span class="line">       <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法。而通过JdkDynamicAopProxy的签名我们可以看到这个类其实也实现了InvocationHandler，下面我们就通过分析这个类中实现的invoke()方法来具体看下Spring AOP是如何织入切面的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> throwsThrowable </span>&#123;  </span><br><span class="line">   MethodInvocation invocation = <span class="keyword">null</span>;  </span><br><span class="line">   Object oldProxy = <span class="keyword">null</span>;  </span><br><span class="line">   <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;  </span><br><span class="line"></span><br><span class="line">   TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;  </span><br><span class="line">   Class targetClass = <span class="keyword">null</span>;  </span><br><span class="line">   Object target = <span class="keyword">null</span>;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;  </span><br><span class="line">       <span class="comment">//eqauls()方法，具目标对象未实现此方法  </span></span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;amp;&amp;amp; AopUtils.isEqualsMethod(method))&#123;  </span><br><span class="line">            <span class="keyword">return</span> (equals(args[<span class="number">0</span>])? Boolean.TRUE : Boolean.FALSE);  </span><br><span class="line">       &#125;  </span><br><span class="line"></span><br><span class="line">       <span class="comment">//hashCode()方法，具目标对象未实现此方法  </span></span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;amp;&amp;amp; AopUtils.isHashCodeMethod(method))&#123;  </span><br><span class="line">            <span class="keyword">return</span> newInteger(hashCode());  </span><br><span class="line">       &#125;  </span><br><span class="line"></span><br><span class="line">       <span class="comment">//Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知  </span></span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;amp;&amp;amp;method.getDeclaringClass().isInterface()  </span><br><span class="line">                &amp;amp;&amp;amp;method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;  </span><br><span class="line">            <span class="comment">// Service invocations onProxyConfig with the proxy config...  </span></span><br><span class="line">            <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised,method, args);  </span><br><span class="line">       &#125;  </span><br><span class="line"></span><br><span class="line">       Object retVal = <span class="keyword">null</span>;  </span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;  </span><br><span class="line">            <span class="comment">// Make invocation available ifnecessary.  </span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);  </span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line"></span><br><span class="line">       <span class="comment">//获得目标对象的类  </span></span><br><span class="line">       target = targetSource.getTarget();  </span><br><span class="line">       <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            targetClass = target.getClass();  </span><br><span class="line">       &#125;  </span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取可以应用到此方法上的Interceptor列表  </span></span><br><span class="line">       List chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass);  </span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)  </span></span><br><span class="line">       <span class="keyword">if</span> (chain.isEmpty()) &#123;  </span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">//创建MethodInvocation  </span></span><br><span class="line">            invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);  </span><br><span class="line">            retVal = invocation.proceed();  </span><br><span class="line">       &#125;  </span><br><span class="line"></span><br><span class="line">       <span class="comment">// Massage return value if necessary.  </span></span><br><span class="line">       <span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;amp;&amp;amp; retVal == target &amp;amp;&amp;amp;method.getReturnType().isInstance(proxy)  </span><br><span class="line">                &amp;amp;&amp;amp;!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;  </span><br><span class="line">            <span class="comment">// Special case: it returned"this" and the return type of the method  </span></span><br><span class="line">            <span class="comment">// is type-compatible. Notethat we can't help if the target sets  </span></span><br><span class="line">            <span class="comment">// a reference to itself inanother returned object.  </span></span><br><span class="line">            retVal = proxy;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> retVal;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">       <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;amp;&amp;amp; !targetSource.isStatic()) &#123;  </span><br><span class="line">            <span class="comment">// Must have come fromTargetSource.  </span></span><br><span class="line">           targetSource.releaseTarget(target);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (setProxyContext) &#123;  </span><br><span class="line">            <span class="comment">// Restore old proxy.  </span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring既是一个AOP框架，也是一个IOC容器。Spring是分层的Java SE/EE应用一站式的轻量级开源框架，以IoC(Inverse of Control：反转控制)和AOP(AspectOriented Programming：面向切面编程)为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，此外，Spring以海纳百川的胸怀整合了开源世界里众多注明的第三方框架的类库，逐渐成为使用最多的JavaEE企业应用开源框架&lt;/p&gt;
&lt;h4 id=&quot;Spring-IOC&quot;&gt;&lt;a href=&quot;#Spring-IOC&quot; class=&quot;headerlink&quot; title=&quot;Spring IOC&quot;&gt;&lt;/a&gt;Spring IOC&lt;/h4&gt;&lt;p&gt;控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中我们使用面向对象编程对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。&lt;/p&gt;
&lt;p&gt;IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作&lt;a href=&quot;http://lib.csdn.net/base/mysql&quot; title=&quot;MySQL知识库&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据库&lt;/a&gt;，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="java" scheme="https://easydecode.coding.me/tags/java/"/>
    
  </entry>
  
</feed>
