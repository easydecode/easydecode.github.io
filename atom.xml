<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>轻松解码</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://easydecode.coding.me/"/>
  <updated>2018-10-05T08:46:53.165Z</updated>
  <id>https://easydecode.coding.me/</id>
  
  <author>
    <name>easydecode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker搭建Java开发环境</title>
    <link href="https://easydecode.coding.me/2018/10/05/6d114ae4.html"/>
    <id>https://easydecode.coding.me/2018/10/05/6d114ae4.html</id>
    <published>2018-10-05T02:52:10.000Z</published>
    <updated>2018-10-05T08:46:53.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p></blockquote><p>宿主机环境：CentOS 7</p><p>搭建目标：</p><blockquote><p>CentOS7.2 + Tomcat7 + JDK1.8</p></blockquote><a id="more"></a><h3 id="一、安装docker"><a href="#一、安装docker" class="headerlink" title="一、安装docker"></a>一、安装docker</h3><p>从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。<br>Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。</p><h4 id="移除旧的docker版本"><a href="#移除旧的docker版本" class="headerlink" title="移除旧的docker版本"></a>移除旧的docker版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove -y docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h4 id="安装所需依赖"><a href="#安装所需依赖" class="headerlink" title="安装所需依赖"></a>安装所需依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h4 id="添加软件源"><a href="#添加软件源" class="headerlink" title="添加软件源"></a>添加软件源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="更新-yum-缓存："><a href="#更新-yum-缓存：" class="headerlink" title="更新 yum 缓存："></a>更新 yum 缓存：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure><h4 id="安装-Docker-ce："><a href="#安装-Docker-ce：" class="headerlink" title="安装 Docker-ce："></a>安装 Docker-ce：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure><h4 id="启动-Docker-后台服务"><a href="#启动-Docker-后台服务" class="headerlink" title="启动 Docker 后台服务"></a>启动 Docker 后台服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h4 id="设置Docker自启动"><a href="#设置Docker自启动" class="headerlink" title="设置Docker自启动"></a>设置Docker自启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><h3 id="二、安装Java开发环境"><a href="#二、安装Java开发环境" class="headerlink" title="二、安装Java开发环境"></a>二、安装Java开发环境</h3><h4 id="获取centos7-2-docker镜像"><a href="#获取centos7-2-docker镜像" class="headerlink" title="获取centos7.2 docker镜像"></a>获取centos7.2 docker镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 通过docker search 软件名 命令获取centos</span><br><span class="line">docker search centos</span><br><span class="line"></span><br><span class="line"># 获取centos镜像</span><br><span class="line">docker pull centos</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>启动容器命令 docker run options containsID argument</p><blockquote><p>options参数说明：<br>-i：表示以“交互模式”运行容器<br>-t：表示容器启动后会进入其命令行<br>-v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;<br>–name: 指定容器的名称，如果未指定容器名称则会随机生成一个名称</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建docker文件夹</span><br><span class="line">mkdir -p /usr/local/docker/javaWeb</span><br><span class="line"></span><br><span class="line">docker run --name JavaWeb -itv /usr/local/docker/javaWeb/:/usr/local/javaWeb/ centos /bin/bash</span><br></pre></td></tr></table></figure><p>停止后需要再次启动容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动容器</span><br><span class="line">docker start JavaWeb</span><br></pre></td></tr></table></figure></p><p>退出后需要再次登录容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 登录容器</span><br><span class="line">docker attach JavaWeb</span><br></pre></td></tr></table></figure></p><h4 id="安装JDK1-8"><a href="#安装JDK1-8" class="headerlink" title="安装JDK1.8"></a>安装JDK1.8</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 安装wget库</span><br><span class="line">sudo yum install wget</span><br><span class="line"></span><br><span class="line"># 进入usr/local/src目录下</span><br><span class="line">cd /usr/local/src</span><br><span class="line"></span><br><span class="line"># 获取JDK1.8包</span><br><span class="line">wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压jdk-8u161-linux-x64.tar.gz</span><br><span class="line">tar -zxvf jdk-8u181-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"># 重命名为JDK8</span><br><span class="line">mv jdk1.8.0_181 jdk8</span><br><span class="line"></span><br><span class="line">mv jdk8 /usr/local/java/</span><br><span class="line"></span><br><span class="line"># 配置环境变量</span><br><span class="line">sed -i &apos;$a export JAVA_HOME=/usr/local/java/jdk8&apos; /etc/profile</span><br><span class="line">sed -i &apos;$a export PATH=$JAVA_HOME/bin:$PATH&apos; /etc/profiletar </span><br><span class="line">sed -i &apos;$a export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar&apos; /etc/profile</span><br><span class="line"></span><br><span class="line"># 使环境生效</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="安装Tomcat7"><a href="#安装Tomcat7" class="headerlink" title="安装Tomcat7"></a>安装Tomcat7</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取tomcat安装包</span><br><span class="line">wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.84/bin/apache-tomcat-7.0.84.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压tomcat安装包</span><br><span class="line">tar -zxvf apache-tomcat-7.0.84.tar.gz</span><br><span class="line"></span><br><span class="line"># 重命名为tomcat7</span><br><span class="line">mv apache-tomcat-7.0.84 /usr/local/tomcat/tomcat7</span><br></pre></td></tr></table></figure><h4 id="编写启动脚本"><a href="#编写启动脚本" class="headerlink" title="编写启动脚本"></a>编写启动脚本</h4><p>启动tomcat时必须通过TOMCATHOME/bin/catalina.sh实现，不能使用TOMCAT_HOME/bin/startup.sh启动，否则脚本执行后容器会马上退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建启动脚本</span><br><span class="line">vi /root/run.sh</span><br><span class="line"></span><br><span class="line"># 添加以下内容：</span><br><span class="line">#!/bin/bash</span><br><span class="line">sh /usr/local/tomcat/tomcat7/bin/catalina.sh run</span><br><span class="line"></span><br><span class="line">#添加可执行权限：</span><br><span class="line">chmod u+x /root/run.sh</span><br></pre></td></tr></table></figure></p><h4 id="构建JavaWeb镜像"><a href="#构建JavaWeb镜像" class="headerlink" title="构建JavaWeb镜像"></a>构建JavaWeb镜像</h4><p>Docker构建镜像的两种方法：<br>1.使用docker commit 命令<br>2.使用docker build命令和Dockerfile文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看正在运行的容器</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"># 查看所有的容器</span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"># 创建JavaWeb镜像</span><br><span class="line">docker commit 738cb51e2236  zhaoheqiang/JavaWeb:0.0.1</span><br><span class="line"></span><br><span class="line"># 查看容器列表</span><br><span class="line">docker images #可以发现zhaoheqiang/JavaWeb:0.0.1镜像</span><br><span class="line"></span><br><span class="line">#运行zhaoheqiang/JavaWeb:0.0.1</span><br><span class="line">docker run -d -p 28080:8080 --name javaweb zhaoheqiang/JavaWeb:0.0.1 /root/run.sh</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。&lt;br&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;br&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;宿主机环境：CentOS 7&lt;/p&gt;
&lt;p&gt;搭建目标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CentOS7.2 + Tomcat7 + JDK1.8&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
      <category term="Docker" scheme="https://easydecode.coding.me/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot打jar包瘦身</title>
    <link href="https://easydecode.coding.me/2018/09/12/a827c8e0.html"/>
    <id>https://easydecode.coding.me/2018/09/12/a827c8e0.html</id>
    <published>2018-09-12T01:55:40.000Z</published>
    <updated>2018-09-12T02:29:07.864Z</updated>
    
    <content type="html"><![CDATA[<p>随着spring boot 的流行、越来越多的来发着选择使用spring boot 来发 web 应用、 不同于传统的 web 应用 需要 war 包来发布应用、 spring boot 应用可以把整个项目打包成一个可执行的 jar 、同时也导致 jar 越来越庞大。 对于现在高速迭代项目、上传如此庞大的 jar 对开发人员来说是一件极其痛苦的事情。通常，一个工程项目架构确定后，引入的jar包基本上不会变，改变的大部分是业务逻辑。<br><strong>解决办法：将一些变化不大的依赖jar包copy到外部文件lib文件夹中</strong><br><a id="more"></a></p><h4 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h4><figure class="highlight diff"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;!-- 指定该Main Class为全局的唯一入口 --&gt;</span><br><span class="line">        &lt;mainClass&gt;com.example.Application&lt;/mainClass&gt;</span><br><span class="line"><span class="addition">+        &lt;layout&gt;ZIP&lt;/layout&gt;</span></span><br><span class="line"></span><br><span class="line">        &lt;!-- 没有该配置，devtools 不生效 --&gt;</span><br><span class="line">        &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line"></span><br><span class="line">        &lt;addResources&gt;true&lt;/addResources&gt;</span><br><span class="line">        &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+        &lt;includes&gt;</span></span><br><span class="line"><span class="addition">+            &lt;include&gt;</span></span><br><span class="line"><span class="addition">+                &lt;groupId&gt;nothing&lt;/groupId&gt;</span></span><br><span class="line"><span class="addition">+                &lt;artifactId&gt;nothing&lt;/artifactId&gt;</span></span><br><span class="line"><span class="addition">+            &lt;/include&gt;</span></span><br><span class="line"><span class="addition">+        &lt;/includes&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;repackage&lt;/goal&gt;&lt;!--可以把依赖的包都打包到生成的Jar包中--&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+&lt;plugin&gt;</span></span><br><span class="line"><span class="addition">+    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span></span><br><span class="line"><span class="addition">+    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="addition">+    &lt;version&gt;3.1.0&lt;/version&gt;</span></span><br><span class="line"><span class="addition">+    &lt;executions&gt;</span></span><br><span class="line"><span class="addition">+        &lt;execution&gt;</span></span><br><span class="line"><span class="addition">+            &lt;id&gt;copy-dependencies&lt;/id&gt;</span></span><br><span class="line"><span class="addition">+            &lt;phase&gt;package&lt;/phase&gt;</span></span><br><span class="line"><span class="addition">+            &lt;goals&gt;</span></span><br><span class="line"><span class="addition">+                &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span></span><br><span class="line"><span class="addition">+            &lt;/goals&gt;</span></span><br><span class="line"><span class="addition">+            &lt;configuration&gt;</span></span><br><span class="line"><span class="addition">+                &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt;</span></span><br><span class="line"><span class="addition">+                &lt;includeScope&gt;runtime&lt;/includeScope&gt;</span></span><br><span class="line"><span class="addition">+            &lt;/configuration&gt;</span></span><br><span class="line"><span class="addition">+        &lt;/execution&gt;</span></span><br><span class="line"><span class="addition">+    &lt;/executions&gt;</span></span><br><span class="line"><span class="addition">+&lt;/plugin&gt;</span></span><br></pre></td></tr></table></figure><p>最终会在项目target目录生成一个lib文件夹，里面存放着项目所用到的依赖jar</p><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><blockquote><p>java -jar -Dloader.path=/path/to/lib /path/to/springboot-0.0.1-SNAPSHOT.jar</p></blockquote><p>注意：根据自身情况修改lib文件夹路径（/path/to/lib）以及打包出来的SpringBoot jar包的位置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着spring boot 的流行、越来越多的来发着选择使用spring boot 来发 web 应用、 不同于传统的 web 应用 需要 war 包来发布应用、 spring boot 应用可以把整个项目打包成一个可执行的 jar 、同时也导致 jar 越来越庞大。 对于现在高速迭代项目、上传如此庞大的 jar 对开发人员来说是一件极其痛苦的事情。通常，一个工程项目架构确定后，引入的jar包基本上不会变，改变的大部分是业务逻辑。&lt;br&gt;&lt;strong&gt;解决办法：将一些变化不大的依赖jar包copy到外部文件lib文件夹中&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://easydecode.coding.me/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot使用校验框架validation校验</title>
    <link href="https://easydecode.coding.me/2018/08/29/4e9c1bdb.html"/>
    <id>https://easydecode.coding.me/2018/08/29/4e9c1bdb.html</id>
    <published>2018-08-29T07:41:04.000Z</published>
    <updated>2018-09-12T02:29:40.680Z</updated>
    
    <content type="html"><![CDATA[<p>开发 WEB 应用时参数校验必不可少。前端通过 js 校验参数合法性，后端也需要对参数进行校验。常见的做法是在 Controller 或者 Service 中通过 if 或者 assert 判断参数是否合法。这样的方式虽然简单，但是代码冗余、耦合度高。其实可以通过 Hibernate Validator 优雅的进行参数校验。<br>Spring Validation验证框架对参数的验证机制提供了@Validated（Spring’s JSR-303规范，是标准JSR-303的一个变种），javax提供了@Valid（标准JSR-303规范），配合BindingResult可以直接提供参数验证结果。<br><a id="more"></a></p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>使用 SpringBoot 开发程序时，用户不需要添加额外的依赖来使用 Hibernate Validator ，因为 spring-boot-starter-web 会自动引入它。<br>如果没用 SpringBoot ，则需要添加依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.8.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><h4 id="Bean校验注解"><a href="#Bean校验注解" class="headerlink" title="Bean校验注解"></a>Bean校验注解</h4><p>Hibernate Validator 包含一组基本的常用约束， 其中最重要的是 Bean Validation 规范定义的约束，所有这些约束都适用于字段/属性级别，Bean验证规范中没有定义类级别约束。</p><table><thead><tr><th style="text-align:center">限制</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">@AssertFalse</td><td style="text-align:center">限制必须为false</td></tr><tr><td style="text-align:center">@AssertTrue</td><td style="text-align:center">限制必须为true</td></tr><tr><td style="text-align:center">@DecimalMax</td><td style="text-align:center">限制必须为一个不大于指定值的数字</td></tr><tr><td style="text-align:center">@DecimalMin</td><td style="text-align:center">限制必须为一个不小于指定值的数字</td></tr><tr><td style="text-align:center">@Digits</td><td style="text-align:center">限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction</td></tr><tr><td style="text-align:center">@Null</td><td style="text-align:center">限制只能为null</td></tr><tr><td style="text-align:center">@NotNull</td><td style="text-align:center">限制必须不为null</td></tr><tr><td style="text-align:center">@Email</td><td style="text-align:center">验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式</td></tr><tr><td style="text-align:center">@Future</td><td style="text-align:center">限制必须是一个将来的日期</td></tr><tr><td style="text-align:center">@Max</td><td style="text-align:center">限制必须为一个不大于指定值的数字</td></tr><tr><td style="text-align:center">@Min</td><td style="text-align:center">限制必须为一个不小于指定值的数字</td></tr><tr><td style="text-align:center">@NotBlank</td><td style="text-align:center">验证注解的元素值不为null且去除空格后长度不为0，@NotBlank只用于字符串</td></tr><tr><td style="text-align:center">@NotEmpty</td><td style="text-align:center">验证注解的元素值不为null且不为空，支持字符串、集合、Map和数组类型</td></tr><tr><td style="text-align:center">@Past</td><td style="text-align:center">限制必须是一个过去的日期</td></tr><tr><td style="text-align:center">@Pattern</td><td style="text-align:center">限制必须符合指定的正则表达式</td></tr><tr><td style="text-align:center">@Range</td><td style="text-align:center">限制必须在合适的范围内</td></tr><tr><td style="text-align:center">@Size</td><td style="text-align:center">限制字符长度必须在min到max之间</td></tr></tbody></table><h4 id="附加注解"><a href="#附加注解" class="headerlink" title="附加注解"></a>附加注解</h4><p>Hibernate Validator 还提供了几个有用的自定义约束，如下所示。除了一个例外，这些约束也适用于字段/属性级别，只有@ScriptAssert类级别约束。</p><table><thead><tr><th style="text-align:center">限制</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">@CreditCardNumber</td><td style="text-align:center">检查带注释的字符序列是否通过了Luhn校验和测试</td></tr><tr><td style="text-align:center">@Currency</td><td style="text-align:center">检查带注释的货币单位javax.money.MonetaryAmount是否为指定货币单位的一部分</td></tr><tr><td style="text-align:center">@EAN</td><td style="text-align:center">检查带注释的字符序列是否为有效的EAN条形码。type确定条形码的类型。默认值为EAN-13</td></tr><tr><td style="text-align:center">@ISBN</td><td style="text-align:center">检查带注释的字符序列是否为有效的ISBN。type确定ISBN的类型。默认值为ISBN-13</td></tr><tr><td style="text-align:center">@Length</td><td style="text-align:center">验证该注释字符序列是间min和max包含</td></tr><tr><td style="text-align:center">@Range</td><td style="text-align:center">检查带注释的值是否在（包括）指定的最小值和最大值之间</td></tr><tr><td style="text-align:center">@Length</td><td style="text-align:center">限制必须为true</td></tr><tr><td style="text-align:center">@Range</td><td style="text-align:center">限制必须为一个不大于指定值的数字</td></tr><tr><td style="text-align:center">@SafeHtml</td><td style="text-align:center">检查带注释的值是否包含潜在的恶意片段</td></tr><tr><td style="text-align:center">@UniqueElements</td><td style="text-align:center">检查带注释的集合是否仅包含唯一元素</td></tr><tr><td style="text-align:center">@URL</td><td style="text-align:center">根据RFC2396检查带注释的字符序列是否为有效URL</td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="Bean-Validation"><a href="#Bean-Validation" class="headerlink" title="Bean Validation"></a>Bean Validation</h5><p>下面来看一个例子，使用 Validator 来验证 bean 参数。<br>校验 name 属性不能为空且长度不能超过 20 ，description 属性不能为空且长度不能超过 200， 若没有通过校验则使用自定义的 message 返回报错信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Length</span>(max = <span class="number">20</span>, message = <span class="string">"The length of name can not exceed 20"</span>)</span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"name can not be null"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Length</span>(max = <span class="number">200</span>, message = <span class="string">"The length of description can not exceed 200"</span>)</span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"description can not be null"</span>)</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get set 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller 方法中在需要校验的 bean 前面添加 @Validated 注解，如果参数不满足条件，将抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> 方法中在需要校验的 bean 前面添加 </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/addUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(@Validated @RequestBody User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="单个方法参数校验"><a href="#单个方法参数校验" class="headerlink" title="单个方法参数校验"></a>单个方法参数校验</h5><p>Controller 类上添加 @Validated 注解， 方法上在需要校验的参数前添加对应的注解， 比如使用 @URL 校验 url 字符串是否合法，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@URL @RequestParam String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><div id="ExceptionHandler"></div><br>当参数校验没有通过时，Hibernate Validator 会抛出异常。但是 SpringBoot 默认的异常返回结果可能并不是用户所希望的，就像上面的例子一样。我只想获取报错信息，不希望返回异常的页面。这个时候我们可以通过 @ControllerAdvice 来自定义异常处理，返回自己希望的结果。</p><p>返回结果封装类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Code</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Code</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer SUCCESS = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer NOTFOUND = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer UNAUTH = <span class="number">302</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ERROR = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>全局异常处理类，主要用来处理参数校验没有通过时的异常信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法参数校验异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = ConstraintViolationException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">constraintViolationException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Message message = Message.builder().code(Message.Code.ERROR).build();</span><br><span class="line">        <span class="keyword">if</span> (e.getMessage() != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            String[] messages = e.getMessage().split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (messages.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> index = messages[<span class="number">0</span>].indexOf(<span class="string">":"</span>);</span><br><span class="line">                message.setMessage(index != -<span class="number">1</span> ? messages[<span class="number">0</span>].substring(index + <span class="number">1</span>).trim() : messages[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = e.getMessage().indexOf(<span class="string">":"</span>);</span><br><span class="line">                message.setMessage(index != -<span class="number">1</span> ? e.getMessage().substring(index + <span class="number">1</span>).trim() : e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean 校验异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = MethodArgumentNotValidException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">notValidExceptionHandler</span><span class="params">(MethodArgumentNotValidException e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Message message = Message.builder().code(Message.Code.ERROR).build();</span><br><span class="line"></span><br><span class="line">        BindingResult bindingResult = e.getBindingResult();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bindingResult != <span class="keyword">null</span> &amp;&amp; !CollectionUtils.isEmpty(bindingResult.getAllErrors())) &#123;</span><br><span class="line">            message.setMessage(e.getBindingResult().getAllErrors().get(<span class="number">0</span>).getDefaultMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            message.setMessage(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回结果：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"不能与给定的值相等"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="Validated和-Valid区别："><a href="#Validated和-Valid区别：" class="headerlink" title="@Validated和@Valid区别："></a>@Validated和@Valid区别：</h3><p>在检验Controller的入参是否符合规范时，使用@Validated或者@Valid在基本验证功能上没有太多区别。但是在分组、注解地方、嵌套验证等功能上两个有所不同：</p><ol><li>分组</li></ol><p>@Validated：提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制，这个网上也有资料，不详述。@Valid：作为标准JSR-303规范，还没有吸收分组的功能。</p><ol><li>注解地方</li></ol><p>@Validated：可以用在类型、方法和方法参数上。但是不能用在成员属性（字段）上</p><p>@Valid：可以用在方法、构造函数、方法参数和成员属性（字段）上</p><p>两者是否能用于成员属性（字段）上直接影响能否提供嵌套验证的功能。</p><ol><li>嵌套验证</li></ol><p>在比较两者嵌套验证时，先说明下什么叫做嵌套验证。比如我们现在有个实体叫做Item：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"id不能为空"</span>)</span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">1</span>, message = <span class="string">"id必须为正整数"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"props不能为空"</span>)</span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">1</span>, message = <span class="string">"至少要有一个属性"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Prop&gt; props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Item带有很多属性，属性里面有属性id，属性值id，属性名和属性值，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"pid不能为空"</span>)</span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">1</span>, message = <span class="string">"pid必须为正整数"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long pid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"vid不能为空"</span>)</span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">1</span>, message = <span class="string">"vid必须为正整数"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long vid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"pidName不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String pidName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"vidName不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String vidName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>属性这个实体也有自己的验证机制，比如属性和属性值id不能为空，属性名和属性值不能为空等。<br>现在我们有个ItemController接受一个Item的入参，想要对Item进行验证，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/item/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(@Validated Item item, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上图中，如果Item实体的props属性不额外加注释，只有@NotNull和@Size，无论入参采用@Validated还是@Valid验证，Spring Validation框架只会对Item的id和props做非空和数量验证，不会对props字段里的Prop实体进行字段验证，也就是@Validated和@Valid加在方法参数前，都不会自动对参数进行嵌套验证。也就是说如果传的List<prop>中有Prop的pid为空或者是负数，入参验证不会检测出来。</prop></p><p>为了能够进行嵌套验证，必须手动在Item实体的props字段上明确指出这个字段里面的实体也要进行验证。由于@Validated不能用在成员属性（字段）上，但是@Valid能加在成员属性（字段）上，而且@Valid类注解上也说明了它支持嵌套验证功能，那么我们能够推断出：@Valid加在方法参数时并不能够自动进行嵌套验证，而是用在需要嵌套验证类的相应字段上，来配合方法参数上@Validated或@Valid来进行嵌套验证。</p><p>我们修改Item类如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"id不能为空"</span>)</span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">1</span>, message = <span class="string">"id必须为正整数"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span> <span class="comment">// 嵌套验证必须用@Valid</span></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"props不能为空"</span>)</span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">1</span>, message = <span class="string">"props至少要有一个自定义属性"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Prop&gt; props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们在ItemController的addItem函数上再使用@Validated或者@Valid，就能对Item的入参进行嵌套验证。此时Item里面的props如果含有Prop的相应字段为空的情况，Spring Validation框架就会检测出来，bindingResult就会记录相应的错误。(bindingResult可用统一异常处理代替，详见第三步<a href="#ExceptionHandler">异常处理</a>)</p><p><strong>总结：</strong>@Validated和@Valid在嵌套验证功能上的区别：</p><p>@Validated：用在方法入参上无法单独提供嵌套验证功能。不能用在成员属性（字段）上，也无法提示框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。</p><p>@Valid：用在方法入参上无法单独提供嵌套验证功能。能够用在成员属性（字段）上，提示验证框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。</p><p>参考：<a href="https://blog.csdn.net/qq_27680317/article/details/79970590" target="_blank" rel="noopener">@Validated和@Valid区别：Spring validation验证框架对入参实体进行嵌套验证必须在相应属性（字段）加上@Valid而不是@Validated</a></p><style type="text/css">    table th:first-of-type {        width: 30%;    }</style>]]></content>
    
    <summary type="html">
    
      我需要三件东西：爱情友谊和图书。然而这三者之间何其相通！炽热的爱情可以充实图书的内容，图书又是人们最忠实的朋友。 —— 蒙田
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://easydecode.coding.me/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Centos7安装并配置nginx</title>
    <link href="https://easydecode.coding.me/2018/06/01/4aabff58.html"/>
    <id>https://easydecode.coding.me/2018/06/01/4aabff58.html</id>
    <published>2018-06-01T12:30:59.000Z</published>
    <updated>2018-09-25T03:42:13.391Z</updated>
    
    <content type="html"><![CDATA[<p>nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现。<br>本篇文章主要介绍了Linux下源码编译安装的同时并对nginx进行优化配置<br>在Centos下，yum源不提供nginx的安装，可以通过切换yum源的方法获取安装。也可以直接下载源码进行编译安装<br><a id="more"></a></p><h4 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h4><h5 id="检查是否已经安装nginx："><a href="#检查是否已经安装nginx：" class="headerlink" title="检查是否已经安装nginx："></a>检查是否已经安装nginx：</h5><p>find / -name nginx（如果执行后无任何返回信息代表没有，反之则或许安装过）</p><h5 id="安装相关依赖："><a href="#安装相关依赖：" class="headerlink" title="安装相关依赖："></a>安装相关依赖：</h5><p>首先安装必要的库（nginx 中gzip模块需要 zlib 库，rewrite模块需要 pcre 库，ssl 功能需要openssl库）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget gcc gcc-c++ autoconf automake pcre pcre-devel zlib zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure></p><h5 id="创建用户组www-创建用户www-所属组-www-并设置不能登录："><a href="#创建用户组www-创建用户www-所属组-www-并设置不能登录：" class="headerlink" title="创建用户组www,创建用户www 所属组 www 并设置不能登录："></a>创建用户组www,创建用户www 所属组 www 并设置不能登录：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd www &amp;&amp; useradd -s /sbin/nologin -g www -M www</span><br></pre></td></tr></table></figure><h5 id="将nginx源码下载到-usr-local-src并解压："><a href="#将nginx源码下载到-usr-local-src并解压：" class="headerlink" title="将nginx源码下载到/usr/local/src并解压："></a>将nginx源码下载到/usr/local/src并解压：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src &amp;&amp; wget http://nginx.org/download/nginx-1.14.0.tar.gz &amp;&amp; tar zxvf nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure><!-- more --><h5 id="创建相关文件夹"><a href="#创建相关文件夹" class="headerlink" title="创建相关文件夹"></a>创建相关文件夹</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/nginx</span><br><span class="line">mkdir -p /var/run/nginx/</span><br><span class="line">mkdir -p /var/lock/</span><br><span class="line">mkdir -p /var/log/nginx/</span><br><span class="line">mkdir -p /var/temp/nginx/client</span><br><span class="line">mkdir -p /var/temp/nginx/proxy</span><br><span class="line">mkdir -p /var/temp/nginx/fastcgi</span><br></pre></td></tr></table></figure><h5 id="进入nginx文件夹并配置编译参数："><a href="#进入nginx文件夹并配置编译参数：" class="headerlink" title="进入nginx文件夹并配置编译参数："></a>进入nginx文件夹并配置编译参数：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.14.0</span><br><span class="line">./configure --user=www\</span><br><span class="line">--group=www \</span><br><span class="line">--prefix=/home/nginx \</span><br><span class="line">--with-stream \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure><p>编译参数解释：<br>#指定运行权限的用户<br>–user=www<br>#指定运行的权限用户组<br>–group=www<br>#指定安装路径<br>–prefix=/usr/local/nginx<br>#支持nginx状态查询<br>–with-http_stub_status_module<br>#开启ssl支持<br>–with-http_ssl_module<br>#开启GZIP功能<br>–with-http_gzip_static_module</p><h5 id="编译并安装"><a href="#编译并安装" class="headerlink" title="编译并安装"></a>编译并安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h5 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h5><p>将/home/nginx目录设置为www:www用户组，同时将权限设置为755<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R www:www /home/nginx</span><br><span class="line">chmod -R 755 /home/nginx</span><br></pre></td></tr></table></figure></p><h4 id="Nginx基本配置"><a href="#Nginx基本配置" class="headerlink" title="Nginx基本配置"></a>Nginx基本配置</h4><h5 id="安装成功后，进入安装目录，备份原配置，修改nginx-conf"><a href="#安装成功后，进入安装目录，备份原配置，修改nginx-conf" class="headerlink" title="安装成功后，进入安装目录，备份原配置，修改nginx.conf"></a>安装成功后，进入安装目录，备份原配置，修改nginx.conf</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/nginx/conf/</span><br><span class="line">cp nginx.conf nginx.conf.bak</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p>修改前                                  修改后</p><p>配置说明<br>user www www<br>指定nginx进程运行用户以及用户组<br>error_log logs/error.log;<br>debug输出日志最为详细，而crit输出日志最少<br>当前目录下的logs目录是linux下的日志存放目录</p><p>修改完成后还需要创建logs文件夹否则会报错：mkdir -p /home/nginx/logs</p><h5 id="启动nginx测试是否成功："><a href="#启动nginx测试是否成功：" class="headerlink" title="启动nginx测试是否成功："></a>启动nginx测试是否成功：</h5><p>启动：/home/nginx/sbin/nginx<br>停止：/home/nginx/sbin/nginx -s stop<br>重载：/home/nginx/sbin/nginx -s reload</p><p>执行后访问服务器地址查看</p><h5 id="nginx优化"><a href="#nginx优化" class="headerlink" title="nginx优化"></a>nginx优化</h5><p>页面直接传输过于占用带宽，对页面进行gzip压缩，然后传到用户那里，再解压，这样可以有效的减少带宽</p><figure class="highlight diff"><figcaption><span>文件位置：/home/nginx/conf/nginx.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">    #                  '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">    #                  '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    charset utf-8; #设置编码为utf-8</span><br><span class="line"></span><br><span class="line">    #开启gzip</span><br><span class="line"><span class="addition">+    gzip on;</span></span><br><span class="line"></span><br><span class="line">    #允许压缩的最小字节数</span><br><span class="line"><span class="addition">+    gzip_min_length 1k;</span></span><br><span class="line"></span><br><span class="line">    #4个单位为16k的内存作为压缩结果流缓存</span><br><span class="line"><span class="addition">+    gzip_buffers 4 16k;</span></span><br><span class="line"></span><br><span class="line">    #设置识别HTTP协议版本，默认是1.1</span><br><span class="line"><span class="addition">+    gzip_http_version 1.1;</span></span><br><span class="line"></span><br><span class="line">    #gzip压缩比，可在1~9中设置，1压缩比最小，速度最快，9压缩比最大，速度最慢，消耗CPU</span><br><span class="line"><span class="addition">+    gzip_comp_level 2;</span></span><br><span class="line"></span><br><span class="line">    #压缩的类型</span><br><span class="line"><span class="addition">+    gzip_types text/plain application/x-javascript text/css application/xml;</span></span><br><span class="line">    </span><br><span class="line">    #让前端的缓存服务器混村经过的gzip压缩的页面</span><br><span class="line"><span class="addition">+    gzip_vary on;</span></span><br></pre></td></tr></table></figure><h4 id="Nginx负载均衡配置"><a href="#Nginx负载均衡配置" class="headerlink" title="Nginx负载均衡配置"></a>Nginx负载均衡配置</h4><h5 id="编辑nginx-conf文件"><a href="#编辑nginx-conf文件" class="headerlink" title="编辑nginx.conf文件"></a>编辑nginx.conf文件</h5><p>在server节点的上面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat_server&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">    server 127.0.0.1:8090;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+    upstream tomcat_server &#123;</span></span><br><span class="line"><span class="addition">+        ip_hash;</span></span><br><span class="line"><span class="addition">+        server 127.0.0.1:8080 weight=1;</span></span><br><span class="line"><span class="addition">+        server 127.0.0.1:8090 weight=1;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p>server后面的IP跟端口需要根据具体情况进行调整<br>ip_hash：每个请求按照ip的hash结果分配，同一个ip的访客固定访问一个后端服务器，可解决动态网页session共享问题。</p><p>将location节点修改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><br><span class="line">    proxy_set_header        Host $host;</span><br><span class="line">    proxy_set_header        X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_pass http://tomcat_server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置说明</p><p>proxy_next_upstream http_502 http_504 error timeout invalid_header;<br>当502或504时，将请求转发到负载均衡中正常server中</p><p>proxy_set_header Host  $host;<br>这一句必须有，否则代理不了</p><p>proxy_pass <a href="http://tomcat_server" target="_blank" rel="noopener">http://tomcat_server</a>;<br>将请求交给反向代理服务器处理</p><h4 id="Nginx动静分离配置"><a href="#Nginx动静分离配置" class="headerlink" title="Nginx动静分离配置"></a>Nginx动静分离配置</h4><p>将nginx.conf文件的server节点里面添加如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取</span><br><span class="line">location ~ .*\.(js|css|png|jpg)$ &#123;</span><br><span class="line">root html/static; </span><br><span class="line">expires 3d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力</p><h4 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h4><h5 id="nginx-反向代理websocket问题"><a href="#nginx-反向代理websocket问题" class="headerlink" title="nginx 反向代理websocket问题"></a>nginx 反向代理websocket问题</h5><p>官方文档说 Nginx 在 1.3 以后的版本才支持 websocket 反向代理，所以要想使用支持 websocket 的功能，必须升级到 1.3 以后的版本</p><p>NGINX通过允许一个在客户端和后端服务器之间建立的隧道来支持WebSocket。为了NGINX发送来至于客户端Upgrade请求到后端服务器，Upgrade和Connection头部必须被设置明确</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream wsbackend &#123;</span><br><span class="line">  server 127.0.0.1:8080;</span><br><span class="line">  server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  location / &#123;</span><br><span class="line">   proxy_pass http://wsbackend;</span><br><span class="line">   proxy_http_version 1.1;</span><br><span class="line">   proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">   proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6、    完整nginx配置文件：<a class="btn" href="/static/downloads/code/nginx.conf"><i class="fa fa-download fa-lg fa-fw"></i>点击下载</a></p>]]></content>
    
    <summary type="html">
    
      一定要有自信的勇气，才会有工作的勇气。 —— 鲁迅
    
    </summary>
    
    
      <category term="Nginx" scheme="https://easydecode.coding.me/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Spring中ContextLoaderListener和DispatcherServlet所加载的context的关系</title>
    <link href="https://easydecode.coding.me/2018/03/11/f7940b2b.html"/>
    <id>https://easydecode.coding.me/2018/03/11/f7940b2b.html</id>
    <published>2018-03-11T02:29:02.000Z</published>
    <updated>2018-08-31T08:54:59.148Z</updated>
    
    <content type="html"><![CDATA[<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>ContextLoaderListener加载的applicationContext是web应用全局的上下文，而DispatcherServlet加载的applicationContext是spring MVC的上下文</p></li><li><p>ContextLoaderListener所加载的context被spring通过<br><code>servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context)</code>存放到ServletContext的attribute中。<br>该上下文可通过WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext)或WebApplicationContextUtils.getWebApplicationContext(servletContext)方法来获取。</p></li><li><p>DispatcherServlet加载context完成后，如果publishContext属性的值设置为true的话(缺省为true) 会将context存放在ServletContext的key为org.springframework.web.servlet.FrameworkServlet.CONTEXT. + (servletName)的attribute中。</p></li></ul><a id="more"></a><figure class="highlight xml"><figcaption><span>web.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:dispatcher-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>DispatcherServlet所加载的applicationContext可以认为是mvc私有的context，由于保存在servletContext中的key值与通过ContextLoaderListener加载进来的applicationContext使用的key值不相同，因此如果只使用DispatcherServlet加载context的话，如果程序中有地方使用WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext) 来试图获取applicationContext时，就会抛出”No WebApplicationContext found: no ContextLoaderListener registered?”的exception。</li></ul><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><ul><li><p>Spring的ContextLoaderListener所创建出来的context和Spring MVC DispatcherServlet所创建出来的context是父子关系，FrameworkServlet在实例化对应的applicationContext后通过setParent将从ServletContext中获取到的ContextLoaderListener创建的applicaitonContext设置成父上下文，然后加载在对应的xml配置文件对其初始化。</p></li><li><p>father WebApplicationContext里的bean可以被注入到child WebApplicationContext里的bean，而child WebApplicationContext的bean则不能被注入到parent WebApplicationContext里的bean。所以在使用Spring MVC时启用自动检测功能，应在applicationContext.xml里只component-scan非Controller的类，而在Spring MVC里只component-scan Controller类</p></li></ul><figure class="highlight xml"><figcaption><span>applicationContext.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.test"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:exclude-filter</span>  <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> <span class="attr">type</span>=<span class="string">"annotation"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><figcaption><span>dispatcher-servlet.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.test.web"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"annotation"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不这么分开扫描的话，那么父容器和子容器中都会有相对应的bean实例。他们因为不在同一个容器中，所以虽然他们bean的id相同也不报错，但这无疑会加应用的负担。同时会造成难以发现的问题。比如我遇到的一个问题：</p><blockquote><p>将一个ApplicationListener实现加上@Component注解，在applicationContext.xml和dispatcherServlet.xml中配置了相同的扫描方案。在触发监听事件的时候调用两次onApplicationEvent方法。这是因为在Spring的上下文和Spring MVC的上下文有两个相同名称的bean，在调用完子类中的监听器后Spring回去查看父容器中是否也有监听器在监听对应的事件。如果有则调用监听器方法</p></blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><font color="red">虽然这两个context上下文是一对父子关系，但它们加载的bean不是合并存储的，所以个人建议，基于mvc相关的spring配置由DispatcherServlet加载，而其余的JavaBean都交给ContextLoaderListener加载</font>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ContextLoaderListener加载的applicationContext是web应用全局的上下文，而DispatcherServlet加载的applicationContext是spring MVC的上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ContextLoaderListener所加载的context被spring通过&lt;br&gt;&lt;code&gt;servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context)&lt;/code&gt;存放到ServletContext的attribute中。&lt;br&gt;该上下文可通过WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext)或WebApplicationContextUtils.getWebApplicationContext(servletContext)方法来获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DispatcherServlet加载context完成后，如果publishContext属性的值设置为true的话(缺省为true) 会将context存放在ServletContext的key为org.springframework.web.servlet.FrameworkServlet.CONTEXT. + (servletName)的attribute中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java,Spring" scheme="https://easydecode.coding.me/tags/Java-Spring/"/>
    
  </entry>
  
  <entry>
    <title>Union和Union All的区别</title>
    <link href="https://easydecode.coding.me/2018/01/22/6bd305d7.html"/>
    <id>https://easydecode.coding.me/2018/01/22/6bd305d7.html</id>
    <published>2018-01-22T09:27:30.000Z</published>
    <updated>2018-08-28T08:36:08.712Z</updated>
    
    <content type="html"><![CDATA[<p>Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All<br>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；<br>如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。<br>union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。<br><a id="more"></a></p><p>假设我们有一个表Student，包括以下字段与数据：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student  </span><br><span class="line">(  </span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,  </span><br><span class="line"><span class="keyword">name</span> <span class="keyword">nvarchar2</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,  </span><br><span class="line">score <span class="built_in">number</span> <span class="keyword">not</span> <span class="literal">null</span>  </span><br><span class="line">);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Aaron'</span>,<span class="number">78</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'Bill'</span>,<span class="number">76</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Cindy'</span>,<span class="number">89</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'Damon'</span>,<span class="number">90</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'Ella'</span>,<span class="number">73</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">'Frado'</span>,<span class="number">61</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">'Gill'</span>,<span class="number">99</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">'Hellen'</span>,<span class="number">56</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">9</span>,<span class="string">'Ivan'</span>,<span class="number">93</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">10</span>,<span class="string">'Jay'</span>,<span class="number">90</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>首先，我们来看一下UNION的例子：</p><figure class="highlight"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select *  </span><br><span class="line">  2  from student  </span><br><span class="line">  3  where id&amp;lt;4  </span><br><span class="line">  4  union  </span><br><span class="line">  5  <span class="keyword">select</span> *  </span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student  </span><br><span class="line">  <span class="number">7</span>  <span class="keyword">where</span> <span class="keyword">id</span>&amp;gt;2 and id&amp;lt;6  </span><br><span class="line">  8  ;  </span><br><span class="line"></span><br><span class="line">        ID NAME                                SCORE  </span><br><span class="line"><span class="comment">---------- ------------------------------ ----------  </span></span><br><span class="line">         1 Aaron                                  78  </span><br><span class="line">         2 Bill                                   76  </span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line">         4 Damon                                  90  </span><br><span class="line">         5 Ella                                   73  </span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>如果换成Union All连接两个结果集，则结果如下：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select *  </span><br><span class="line">  2  from student  </span><br><span class="line">  3  where id&amp;lt;4  </span><br><span class="line">  4  union all  </span><br><span class="line">  5  <span class="keyword">select</span> *  </span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student  </span><br><span class="line">  <span class="number">7</span>  <span class="keyword">where</span> <span class="keyword">id</span>&amp;gt;2 and id&amp;lt;6  </span><br><span class="line">  8  ;  </span><br><span class="line"></span><br><span class="line">        ID NAME                                SCORE  </span><br><span class="line"><span class="comment">---------- ------------------------------ ----------  </span></span><br><span class="line">         1 Aaron                                  78  </span><br><span class="line">         2 Bill                                   76  </span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line">         4 Damon                                  90  </span><br><span class="line">         5 Ella                                   73  </span><br><span class="line"></span><br><span class="line">6 rows selected.</span><br></pre></td></tr></table></figure><p>可以看到，<span style="color: #ff6600;">Union和Union All的区别之一在于对重复结果的处理。</span></p><p>接下来，我们交换一个两个SELECT语句的顺序，看看结果是怎样的。</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select *  </span><br><span class="line">  2  from student  </span><br><span class="line">  3  where id&gt;2 and id&lt;6  </span><br><span class="line">  4  union  </span><br><span class="line">  5  <span class="keyword">select</span> *  </span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student  </span><br><span class="line">  <span class="number">7</span>  <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">4</span>  </span><br><span class="line">  <span class="number">8</span>  ;  </span><br><span class="line"></span><br><span class="line">        ID NAME                                SCORE  </span><br><span class="line"><span class="comment">---------- ------------------------------ ----------  </span></span><br><span class="line">         1 Aaron                                  78  </span><br><span class="line">         2 Bill                                   76  </span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line">         4 Damon                                  90  </span><br><span class="line">         5 Ella                                   73  </span><br><span class="line"></span><br><span class="line">SQL&gt; select *  </span><br><span class="line">  2  from student  </span><br><span class="line">  3  where id&gt;2 and id&lt;6  </span><br><span class="line">  4  union all  </span><br><span class="line">  5  <span class="keyword">select</span> *  </span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student  </span><br><span class="line">  <span class="number">7</span>  <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">4</span>  </span><br><span class="line">  <span class="number">8</span>  ;  </span><br><span class="line"></span><br><span class="line">        ID NAME                                SCORE  </span><br><span class="line"><span class="comment">---------- ------------------------------ ----------  </span></span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line">         4 Damon                                  90  </span><br><span class="line">         5 Ella                                   73  </span><br><span class="line">         1 Aaron                                  78  </span><br><span class="line">         2 Bill                                   76  </span><br><span class="line">         3 Cindy                                  89  </span><br><span class="line"></span><br><span class="line">6 rows selected.</span><br></pre></td></tr></table></figure><p>可以看到，对于UNION来说，交换两个SELECT语句的顺序后结果仍然是一样的，这是因为<span style="color: #ff6600;">UNION会自动排序</span>。而UNION ALL在交换了SELECT语句的顺序后结果则不相同，因为UNION ALL不会对结果自动进行排序。</p><p>那么这个自动排序的规则是什么呢？我们交换一下SELECT后面选择字段的顺序（前面使用SELECT * 相当于SELECT ID,NAME,SCORE），看看结果如何：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select score,id,name  </span><br><span class="line">  2  from student  </span><br><span class="line">  3  where id&lt;4  </span><br><span class="line">  4  union  </span><br><span class="line">  5  <span class="keyword">select</span> score,<span class="keyword">id</span>,<span class="keyword">name</span>  </span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student  </span><br><span class="line">  <span class="number">7</span>  <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">6</span>  </span><br><span class="line">  <span class="number">8</span>  ;  </span><br><span class="line"></span><br><span class="line">     SCORE         ID NAME  </span><br><span class="line"><span class="comment">---------- ---------- ------------------------------  </span></span><br><span class="line">        73          5 Ella  </span><br><span class="line">        76          2 Bill  </span><br><span class="line">        78          1 Aaron  </span><br><span class="line">        89          3 Cindy  </span><br><span class="line">        90          4 Damon</span><br></pre></td></tr></table></figure><p>可以看到，此时是按照字段SCORE来对结果进行排序的（前面SELECT * 的时候是按照ID进行排序的）。</p><p>那么有人会问，如果我想自行控制排序，能不能使用ORDER BY呢？当然可以。不过在写法上有需要注意的地方：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> score,<span class="keyword">id</span>,<span class="keyword">name</span>  </span><br><span class="line"><span class="keyword">from</span> student  </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt; <span class="number">7</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> score,<span class="keyword">id</span>,<span class="keyword">name</span>  </span><br><span class="line"><span class="keyword">from</span> student  </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">4</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> score,<span class="keyword">id</span>,<span class="keyword">name</span>  </span><br><span class="line"><span class="keyword">from</span> student  </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">8</span>  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>order by子句必须写在最后一个结果集里，并且其排序规则将改变操作后的排序结果。对于Union、Union All、Intersect、Minus都有效。</p><p>其他的集合操作符，如Intersect和Minus的操作和Union基本一致，这里一起总结一下：</p><p>Union，对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</p><p>Union All，对两个结果集进行并集操作，包括重复行，不进行排序；</p><p>Intersect，对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序；</p><p>Minus，对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。</p><p>可以在最后一个结果集中指定Order by子句改变排序方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All&lt;br&gt;两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；&lt;br&gt;如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。&lt;br&gt;union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。&lt;br&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://easydecode.coding.me/categories/DataBase/"/>
    
    
      <category term="DataBase" scheme="https://easydecode.coding.me/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Streams API：对Stream分组和分区</title>
    <link href="https://easydecode.coding.me/2017/12/13/8d4c56cb.html"/>
    <id>https://easydecode.coding.me/2017/12/13/8d4c56cb.html</id>
    <published>2017-12-13T08:06:03.000Z</published>
    <updated>2018-08-28T08:17:03.380Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章展示了如何使用 Streams API 中的 Collector 及 groupingBy 和 partitioningBy 来对流中的元素进行分组和分区。<br>思考一下 Employee 对象流，每个对象对应一个名字、城市和销售数量，如下表所示：</p><pre><code>+----------+------------+-----------------+| Name     | City       | Number of Sales |+----------+------------+-----------------+| Alice    | London     | 200             || Bob      | London     | 150             || Charles  | New York   | 160             || Dorothy  | Hong Kong  | 190             |+----------+------------+-----------------+</code></pre><a id="more"></a><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>首先，我们利用（lambda表达式出现之前的）命令式风格Java 程序对流中的雇员按城市进行分组：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Employee e : employees) &#123;</span><br><span class="line">  String city = e.getCity();</span><br><span class="line">  List&lt;Employee&gt; empsInCity = result.get(city);</span><br><span class="line">  <span class="keyword">if</span> (empsInCity == <span class="keyword">null</span>) &#123;</span><br><span class="line">    empsInCity = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    result.put(city, empsInCity);</span><br><span class="line">  &#125;</span><br><span class="line">  empsInCity.add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能很熟悉写这样的代码，你也看到了，一个如此简单的任务就需要这么多代码！</p><p>而在 Java 8 中，你可以使用 groupingBy 收集器，一条语句就能完成相同的功能，像这样：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; employeesByCity = employees.stream().collect(groupingBy(Employee::getCity));</span><br></pre></td></tr></table></figure><p>结果如下面的 map 所示：</p><div class="note success"><p>{New York=[Charles], Hong Kong=[Dorothy], London=[Alice, Bob]}</p></div><p>还可以计算每个城市中雇员的数量，只需传递一个计数收集器给 groupingBy 收集器。第二个收集器的作用是在流分类的同一个组中对每个元素进行递归操作。</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt;; numEmployeesByCity = employees.stream().collect(groupingBy(Employee::getCity, counting()));</span><br></pre></td></tr></table></figure><p>结果如下面的 map 所示：</p><div class="note success"><p>{New York=1, Hong Kong=1, London=2}</p></div><p>顺便提一下，该功能与下面的 SQL 语句是等同的：</p><figure class="highlight sql"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city, <span class="keyword">count</span>(*) <span class="keyword">from</span> Employee <span class="keyword">group</span> <span class="keyword">by</span> city</span><br></pre></td></tr></table></figure><p>另一个例子是计算每个城市的平均年龄，这可以联合使用 averagingInt 和 groupingBy 收集器：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Double&gt; avgSalesByCity = employees.stream().collect(groupingBy(Employee::getCity,averagingInt(Employee::getNumSales)));</span><br></pre></td></tr></table></figure><p>结果如下 map 所示：</p><div class="note success"><p>{New York=160.0, Hong Kong=190.0, London=175.0}</p></div><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>分区是一种特殊的分组，结果 map 至少包含两个不同的分组——一个true，一个false。例如，如果想找出最优秀的员工，你可以将所有雇员分为两组，一组销售量大于 N，另一组小于 N，使用 partitioningBy 收集器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Employee&gt;&gt; partitioned = employees.stream().collect(partitioningBy(e -&gt; e.getNumSales() &gt; <span class="number">150</span>));</span><br></pre></td></tr></table></figure><p>输出如下结果：</p><div class="note success"><p>{false=[Bob], true=[Alice, Charles, Dorothy]}</p></div><p>你也可以将 groupingBy 收集器传递给 partitioningBy 收集器来将联合使用分区和分组。例如，你可以统计每个分区中的每个城市的雇员人数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Map&lt;String, Long&gt;&gt; result = employees.stream().collect(partitioningBy(e -&gt; e.getNumSales() &gt; <span class="number">150</span>,groupingBy(Employee::getCity, counting())));</span><br></pre></td></tr></table></figure><p>这样会生成一个二级 Map:</p><div class="note success"><p>{false={London=1}, true={New York=1, Hong Kong=1, London=1}}</p></div><p>原文链接： <a href="http://www.javacodegeeks.com/2015/11/java-8-streams-api-grouping-partitioning-stream.html" target="_blank" rel="noopener">javacodegeeks</a> 翻译： <a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew.com </a>- <a href="http://www.importnew.com/author/paddx" target="_blank" rel="noopener">paddx</a></p><p>译文链接： <a href="http://www.importnew.com/17313.html" target="_blank" rel="noopener">http://www.importnew.com/17313.html</a></p><p>[ <strong>转载请保留原文出处、译者和译文链接。</strong>]</p>]]></content>
    
    <summary type="html">
    
      在人生的路上，将血一滴一滴地滴过去，以饲别人，虽自觉渐渐瘦弱，也以为快乐。 —— 鲁迅
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux（CentOS）上安装openoffice+SWFTools</title>
    <link href="https://easydecode.coding.me/2017/08/27/f5307712.html"/>
    <id>https://easydecode.coding.me/2017/08/27/f5307712.html</id>
    <published>2017-08-27T12:56:05.000Z</published>
    <updated>2018-08-28T08:19:49.908Z</updated>
    
    <content type="html"><![CDATA[<p>openoffice是Apache下的一个开放免费的文字处理软件，可以将word、excel、ppt、txt等文件转换为pdf文件。SWFTools是一组用来处理Flash的swf文件的工具包，我们使用它将pdf文件转成swf文！FlexPaper是一个开源轻量级的在浏览器上显示各种文档的组件<br>这篇文章教大家如何在Linux（CentOS）上安装实现在线文档预览的两大软件openoffice + SWFTools，首先说明openoffice需要jdk支持，请先安装jdk。<br><a id="more"></a></p><h2 id="一、openoffice安装"><a href="#一、openoffice安装" class="headerlink" title="一、openoffice安装"></a>一、openoffice安装</h2><p><span style="color: #008000;">1、在官网<a href="http://www.openoffice.org/download/index.html" target="_blank" rel="noopener">http://www.openoffice.org/download/index.html</a>下载最新的Apache OpenOffice 4.1.3</span></p><p><span style="color: #008000;">2、解压压缩包：</span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar Apache_OpenOffice_4.1.3_Linux_x86-64_install-rpm_zh-CN.tar.gz</span><br></pre></td></tr></table></figure><p>解压后的目录是zh-CN，里面有RPMS、readmes、licenses</p><p><span style="color: #008000;">3、进入zh-CN/RPMS目录下，执行</span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall *.rpm</span><br></pre></td></tr></table></figure><p><span style="color: #008000;">4、</span>再进入到zh-CN/RPMS/desktop-integration目录下安装openoffice4.1.3-redhat-menus-4.1.3-9783.noarch.rpm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall openoffice4.1.3-redhat-menus-4.1.3-9783.noarch.rpm</span><br></pre></td></tr></table></figure><p><span style="color: #008000;">5、启动</span></p><p>临时启动（如果连接断开，服务也就停止了，Ctrl+C也会停止）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/openoffice4/program/soffice -headless -accept=<span class="string">"socket,host=127.0.0.1,port=8100;urp;"</span> -nofirststartwizard</span><br></pre></td></tr></table></figure><p>后台运行（服务会一直运行在后台）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup  /opt/openoffice4/program/soffice -headless -accept=<span class="string">"socket,host=127.0.0.1,port=8100;urp;"</span> -nofirststartwizard &amp;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/openoffice4/program/soffice -headless -accept=<span class="string">"socket,host=127.0.0.1,port=8100;urp;"</span> -nofirststartwizard &amp; &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><span style="color: #008000;">6、查看服务是否启动</span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnp | grep 8100</span><br></pre></td></tr></table></figure><p>如果出现类似如下信息，则说明已经成功启动</p><div class="note success"><p>tcp 0 0 127.0.0.1:8100 0.0.0.0:* LISTEN 19501/soffice.bin</p></div><h2 id="二、swftools安装"><a href="#二、swftools安装" class="headerlink" title="二、swftools安装"></a>二、swftools安装</h2><figure class="highlight bash"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line"></span><br><span class="line">yum install giflib-devel libjpeg-devel freetype-devel t1lib-devel</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载swftools</span></span><br><span class="line">wget http://www.swftools.org/swftools-0.9.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压swftools</span></span><br><span class="line">tar vxzf swftools-0.9.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> swftools-0.9.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置</span></span><br><span class="line">./configure –prefix=/usr/<span class="built_in">local</span>/swftools</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>上面的命令一步一步执行完即可完成安装，安装完成后需要将swftools添加至PATH变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=\$PATH:/usr/local/swftools/bin/"</span> /etc/profile</span><br></pre></td></tr></table></figure><p>执行下<span style="color: #008000;">source /etc/profile</span> 使环境变量生效</p>]]></content>
    
    <summary type="html">
    
      人生最苦痛的是梦醒了无路可走。做梦的人是幸福的；倘没有看出可走的路，最要紧的是不要去惊醒他。 —— 鲁迅
    
    </summary>
    
      <category term="CentOS" scheme="https://easydecode.coding.me/categories/CentOS/"/>
    
    
      <category term="Linux" scheme="https://easydecode.coding.me/tags/Linux/"/>
    
      <category term="Centos" scheme="https://easydecode.coding.me/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>十步完成Linux（CentOS）下安装oracle 12c（上篇）</title>
    <link href="https://easydecode.coding.me/2017/08/07/fc662c52.html"/>
    <id>https://easydecode.coding.me/2017/08/07/fc662c52.html</id>
    <published>2017-08-06T20:35:30.000Z</published>
    <updated>2018-09-13T02:36:02.409Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍CentOS下安装oracle 12c的方法(图形化安装+命令行安装），博主亲自搭建了一遍，需要安装的朋友可以参考下面的步骤一步步进行。安装oracle12C官方要求物理内存和虚拟内存（swap）都不能低于2G，如果还没有为CentOS设置虚拟内存的，可以参考这篇文章：<a href="http://blog.easydcode.com/1050.html" title="CentOS添加SWAP" target="_blank" rel="noopener">http://blog.easydcode.com/1050.html</a><br><a id="more"></a></p><h2 id="一、关闭无用服务"><a href="#一、关闭无用服务" class="headerlink" title="一、关闭无用服务"></a>一、关闭无用服务</h2><p>1、关闭防火墙</p><p>如果系统是centos6，执行</p><blockquote><p>service iptables stop</p></blockquote><p>如果系统是centos7，执行</p><blockquote><p>systemctl stop firewalld.service</p><p>systemctl stop iptables.service</p></blockquote><p>2、禁用SELINUX</p><blockquote><p>sed -i ‘s/SELINUX=enforcing/SELINUX=disabled/‘ /etc/selinux/config</p></blockquote><h2 id="二、安装oracle所需依赖"><a href="#二、安装oracle所需依赖" class="headerlink" title="二、安装oracle所需依赖"></a>二、安装oracle所需依赖</h2><blockquote><p>yum install binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc glibc-devel ksh libgcc libstdc++ libstdc++-devel libaio libaio-devel libXext libXtst libX11 libXau libxcb libXi make sysstat</p></blockquote><p>安装调用图形化需要的包，下面会用到</p><blockquote><p>yum -y install unixODBC unixODBC-devel xterm</p></blockquote><p>xterm是调用图形化用的包</p><h2 id="三、添加相关用户及目录"><a href="#三、添加相关用户及目录" class="headerlink" title="三、添加相关用户及目录"></a>三、添加相关用户及目录</h2><p>添加安装oracle所需的用户组，以及为oracle用户设置密码（123456）</p><blockquote><p>groupadd oinstall</p><p>groupadd oper</p><p>groupadd dba</p><p>useradd -g oinstall -G dba,oper oracle</p><p>echo “123456” | passwd –stdin oracle</p></blockquote><p>创建oracle安装目录</p><blockquote><p>mkdir -p /usr/local/oracle/product/12.1.0/dbhome_1</p><p>mkdir -p /usr/local/oracle/oradata</p><p>mkdir -p /usr/local/oracle/flash_recovery_area</p><p>mkdir -p /usr/local/oracle/archlog</p><p>chown -R oracle:oinstall /usr/local/oracle</p></blockquote><h2 id="四、配置内核参数"><a href="#四、配置内核参数" class="headerlink" title="四、配置内核参数"></a>四、配置内核参数</h2><p>执行下面的命令</p><blockquote><p>echo -e “fs.aio-max-nr = 1048576\nfs.file-max = 6815744\nkernel.shmall = 2097152\nkernel.shmmax = 4098955264\nkernel.shmmni = 4096\nkernel.sem = 250 32000 100 128\nnet.ipv4.ip_local_port_range = 9000 65500\nnet.core.rmem_default = 262144\nnet.core.rmem_max = 4194304\nnet.core.wmem_default = 262144\nnet.core.wmem_max = 1048586” &gt;&gt;/etc/sysctl.conf</p></blockquote><p>执行上面的命令完成后，执行如下命令使修改生效</p><blockquote><p>sysctl -p</p></blockquote><p>&nbsp;</p><p>执行下面的命令修改系统限制</p><blockquote><p>echo -e “oracle soft nofile 1024\noracle hard nofile 65536\noracle soft nproc 2048\noracle hard nproc 16384\noracle stack nproc 10240” &gt;&gt;/etc/security/limits.conf</p></blockquote><p>设置PAM，确保加载了最新版本的 PAM</p><blockquote><p>echo -e “session required /lib/security/pam_limits.so\nsession required pam_limits.so” &gt;&gt;/etc/pam.d/login</p></blockquote><p>验证当前 ulimit，如果需要则增大</p><blockquote><p>echo -e “if [ $USER = “oracle” ]; then\nif [ $SHELL = “/bin/ksh” ]; then\nulimit -p 16384\nulimit -n 65536a\nelseulimit -u 16384 -n 65536\nfi\nfi” &gt;&gt;/etc/profile</p></blockquote><h2 id="五、修改操作系统发行版本"><a href="#五、修改操作系统发行版本" class="headerlink" title="五、修改操作系统发行版本"></a>五、修改操作系统发行版本</h2><p>由于 oracle 还没有推出支持 CentOS 的安装包，所以需要修改发行版本</p><blockquote><p>vi /etc/redhat-release</p></blockquote><p>把CentOS release 6.5 (Final) 注释掉，前面加上一行redhat-6，当oracle安装完成后,可以再修改回来。</p><h2 id="六、修改-etc-hosts"><a href="#六、修改-etc-hosts" class="headerlink" title="六、修改/etc/hosts"></a>六、修改/etc/hosts</h2><blockquote><p>vi /etc/hosts</p></blockquote><p>把127.0.0.1那一行改为：127.0.0.1 localhost</p><h2 id="七、配置环境变量"><a href="#七、配置环境变量" class="headerlink" title="七、配置环境变量"></a>七、配置环境变量</h2><p>此处博主将oracle环境变量添加为全局变量，如果你只需要oracle用户才能操作，则执行vi /home/oracle/.bash_profile</p><blockquote><p>echo -e “\n#set oracle environment\nORACLE_BASE=/usr/local/oracle\nORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1\nORACLE_SID=orcl\nexport ORACLE_BASE ORACLE_HOME ORACLE_SID\nPATH=$ORACLE_HOME/bin:$PATH\nexport PATH” &gt;&gt;/etc/profile</p></blockquote><p>注意：如果你的ORACLE_BASE和我不同，里面的内容可以根据实际情况进行改动，如可以改动ORACLE_SID和ORACLE_BASE，修改完后用：<span style="color: #008000;">source /etc/profile（source /home/oracle/.bash_profile）</span>使修改生效。</p><h2 id="九、下载Oracle安装包并解压"><a href="#九、下载Oracle安装包并解压" class="headerlink" title="九、下载Oracle安装包并解压"></a>九、下载Oracle安装包并解压</h2><p>1、前往<a href="http://www.oracle.com/" target="_blank" rel="noopener">Oracle</a>官网下载Linux版本的Oracle安装包，最新的Linux安装包将两个压缩包合并为一个了</p><p>下载地址：<a href="http://www.oracle.com/technetwork/database/enterprise-edition/downloads/oracle12c-linux-12201-3608234.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/database/enterprise-edition/downloads/oracle12c-linux-12201-3608234.html</a></p><p>2、解压oracle安装包到任意目录，博主就在/root目录下解压</p><blockquote><p>unzip linuxx64_12201_database.zip /root</p></blockquote><p>若提示：bash：unzip：command not found</p><p>则可执行如下命令安装压缩/解压缩工具</p><blockquote><p>yum install -y unzip zip</p></blockquote><h2 id="十、安装Oracle"><a href="#十、安装Oracle" class="headerlink" title="十、安装Oracle"></a>十、安装Oracle</h2><p>远程调用图形安装oracle软件，此处使用的X-manager软件</p><p>详情请见下篇：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍CentOS下安装oracle 12c的方法(图形化安装+命令行安装），博主亲自搭建了一遍，需要安装的朋友可以参考下面的步骤一步步进行。安装oracle12C官方要求物理内存和虚拟内存（swap）都不能低于2G，如果还没有为CentOS设置虚拟内存的，可以参考这篇文章：&lt;a href=&quot;http://blog.easydcode.com/1050.html&quot; title=&quot;CentOS添加SWAP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.easydcode.com/1050.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CentOS" scheme="https://easydecode.coding.me/categories/CentOS/"/>
    
      <category term="Oracle" scheme="https://easydecode.coding.me/categories/CentOS/Oracle/"/>
    
    
      <category term="Oracle" scheme="https://easydecode.coding.me/tags/Oracle/"/>
    
      <category term="Centos" scheme="https://easydecode.coding.me/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Java异常汇总（一）</title>
    <link href="https://easydecode.coding.me/2017/08/01/6efc2b5a.html"/>
    <id>https://easydecode.coding.me/2017/08/01/6efc2b5a.html</id>
    <published>2017-08-01T03:23:27.000Z</published>
    <updated>2018-08-31T08:53:59.400Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/Java/85979" target="_blank" rel="noopener">Java</a>是一门<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">面向对象</a>编程语言，不仅吸收了<a href="https://baike.baidu.com/item/C%2B%2B" target="_blank" rel="noopener">C++</a>语言的各种优点，还摒弃了C++里难以理解的<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BB%A7%E6%89%BF" target="_blank" rel="noopener">多继承</a>、<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p><a id="more"></a><h3 id="问题一、Tomcat7中文Cookie问题"><a href="#问题一、Tomcat7中文Cookie问题" class="headerlink" title="问题一、Tomcat7中文Cookie问题"></a>问题一、Tomcat7中文Cookie问题</h3><p>主要报错信息：</p><blockquote><p>java.lang.IllegalArgumentException: Control character in cookie value or attribute.</p></blockquote><p>问题描述及解决办法：</p><p>tomcat7中cookie写入中文引发Control character in cookie value or attribute异常，本地测试通过的程序，部署到测试环境遇到一个问题，如果登陆名称为中文时将引发如上所示的异常，而英文字母或者数字的登陆名称则是正常的，该报错是由于中文的编码的问题，中文采用的是unicode编码，而英文采用的是ASCII编码，所以当COOkie保存中文的时候需要对中文进行编码，而且从Cookie中取出内容的时候也要进行解码，编码和解码可以使用</p><p>在保存cookie之前把值编码下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URLEncoder.encode(cookieValue, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p>取cookie值时解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URLDecoder.decode(localCookieValue, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><h3 id="问题二、Struts2-json插件问题"><a href="#问题二、Struts2-json插件问题" class="headerlink" title="问题二、Struts2 json插件问题"></a>问题二、Struts2 json插件问题</h3><p>主要报错信息：</p><blockquote><p>Caused by: There is no result type defined for type ‘json’ mapped with name ‘ajaxerror’. Did you mean ‘json’?</p></blockquote><p>这个错误是在使用Struts2过程中很容易遇到的</p><p>解决步骤：</p><p>1、首先查看Jar有没有少</p><blockquote><p>commons-beanutils-1.7.0.jar</p><p>commons-collections-3.2.jar</p><p>commons-lang-2.3.jar</p><p>commons-logging-1.1.jar</p><p>ezmorph-1.0.4.jar</p><p>json-lib-2.2.3-jdk15.jar</p><p>jsonplugin-0.33.jar</p></blockquote><p><span style="color: #008000;">注意：struts2-json-plugin-2.2.1.1.jar 和 jsonplugin-0.33.jar会冲突不能同时存在</span></p><p>2、看Struts配置文件的继承部分对不对，json-default是必须的</p><h3 id="问题三、内存泄露"><a href="#问题三、内存泄露" class="headerlink" title="问题三、内存泄露"></a>问题三、内存泄露</h3><p>主要报错信息：</p><blockquote><p>The background cache eviction process was unable to free [10] percent of the cache for Context [/qishiMusic] - consider increasing the maximum size of the cache. After eviction approximately [9,741] KB of data remained in the cache.</p></blockquote><p>解决：检查是否有资源没有关闭，可以在底层关闭资源的方法中调试例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">4<span class="keyword">this</span>.rs.close();</span><br><span class="line">4System.out.println(<span class="string">"ResultSet已关闭"</span>);</span><br><span class="line">4<span class="keyword">this</span>.rs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题四、Failed-to-start-component"><a href="#问题四、Failed-to-start-component" class="headerlink" title="问题四、Failed to start component"></a>问题四、Failed to start component</h3><p>主要报错信息：</p><blockquote><p>java.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/test]]</p></blockquote><p>原因及解决方法：</p><p>@WebServlet(“TestServlet”)缺少”/“</p><p>应写成：@WebServlet(“/TestServlet”)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/Java/85979&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java&lt;/a&gt;是一门&lt;a href=&quot;https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面向对象&lt;/a&gt;编程语言，不仅吸收了&lt;a href=&quot;https://baike.baidu.com/item/C%2B%2B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++&lt;/a&gt;语言的各种优点，还摒弃了C++里难以理解的&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E7%BB%A7%E6%89%BF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多继承&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/%E6%8C%87%E9%92%88&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;指针&lt;/a&gt;等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CentOS配置静态IP</title>
    <link href="https://easydecode.coding.me/2017/07/26/cbf4ff77.html"/>
    <id>https://easydecode.coding.me/2017/07/26/cbf4ff77.html</id>
    <published>2017-07-26T09:49:47.000Z</published>
    <updated>2018-09-13T02:34:40.204Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 是一个基于Red Hat Linux（收费） 提供的可自由使用源代码的企业级Linux发行版本。而且在RHEL的基础上修正了不少已知的 Bug ，相对于其他 Linux 发行版，其稳定性值得信赖。更重要的是免费的，所以，它受到了很多企业的青睐！<br>很多时候，Centos系统都是使用命令来管理的，如果当时安装系统时没有设置IP地址的话，那就只能在命令行设置了。下面简单说说配置静态ip的操作。<br><a id="more"></a></p><p>首先登陆root帐户，用命令<span style="color: #0000ff;">ifconfig</span>查看一下IP配置</p><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/07/centos-1.png" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/07/centos-1.png" alt="Centos6配置静态ip" title="Centos6配置静态ip"></a></p><p>只有一个本地回环地址，网卡并没有启用，接下来我们就开始网络配置</p><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eht0</span><br></pre></td></tr></table></figure><p>在这里的eth0，指的第一块网卡，如果你的电脑/服务器有多个网卡，注意区分</p><p>输入如上命令后按键盘上 i 键即可进入编辑模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0  </span><br><span class="line">HWADDR=00:0C:29:C1:48:03  </span><br><span class="line">TYPE=Ethernet  </span><br><span class="line">UUID=b2bbb718-caa6-46c3-ae12-587cbedfd5fa  </span><br><span class="line">ONBOOT=no  </span><br><span class="line">NM_CONTROLLED=yes  </span><br><span class="line">BOOTPROTO=dhcp</span><br></pre></td></tr></table></figure><p>上面的是默认配置，下面我们将ip修改为静态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0  </span><br><span class="line">HWADDR=00:0C:29:C1:48:03  </span><br><span class="line">TYPE=Ethernet  </span><br><span class="line">UUID=b2bbb718-caa6-46c3-ae12-587cbedfd5fa  </span><br><span class="line">ONBOOT=yes</span><br><span class="line">NM_CONTROLLED=yes  </span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.233.128</span><br><span class="line">GATEWAY=192.168.233.2</span><br><span class="line">NETMASK=255.255.255.0</span><br></pre></td></tr></table></figure><p>IPADDR要配置为跟你路由器在同一个网段，如果是用VMware装的虚拟机，那么一般vmnet8就相当于一个路由器，要配置为跟他在同一网段，IPADDR，GATEWAY，NETMASK这三个是设置静态ip一定要配置的</p><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/07/centos-2.jpg" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/07/centos-2.jpg" alt=""></a></p><p>配置信息修改后按ESC退出编辑状态，然后输入 :wq 保存并退出</p><p>如果你是第一次将ONBOOT=no改为ONBOOT=yes，那么输入reboot重启机器即可</p><p>如果你之前已经将修改ONBOOT修改为yes，但是没配置静态ip，那么输入如下指令重启网卡即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/init.d/network restart</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>如果出现connect: Network is unreachable（connect: 网络不可达），请检查GATEWAY（网关）是否配置正确。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS 是一个基于Red Hat Linux（收费） 提供的可自由使用源代码的企业级Linux发行版本。而且在RHEL的基础上修正了不少已知的 Bug ，相对于其他 Linux 发行版，其稳定性值得信赖。更重要的是免费的，所以，它受到了很多企业的青睐！&lt;br&gt;很多时候，Centos系统都是使用命令来管理的，如果当时安装系统时没有设置IP地址的话，那就只能在命令行设置了。下面简单说说配置静态ip的操作。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://easydecode.coding.me/categories/Linux/"/>
    
      <category term="CentOS" scheme="https://easydecode.coding.me/categories/Linux/CentOS/"/>
    
    
      <category term="Linux" scheme="https://easydecode.coding.me/tags/Linux/"/>
    
      <category term="CentOS" scheme="https://easydecode.coding.me/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Oracle中导入导出dmp数据库文件</title>
    <link href="https://easydecode.coding.me/2017/07/06/25287513.html"/>
    <id>https://easydecode.coding.me/2017/07/06/25287513.html</id>
    <published>2017-07-06T03:00:47.000Z</published>
    <updated>2018-09-13T02:36:43.037Z</updated>
    
    <content type="html"><![CDATA[<p>Oracle数据导入导出imp/exp就相当于oracle数据还原与备份。exp命令可以把数据从远程数据库服务器导出到本地的dmp文件，imp命令可以把dmp文件从本地导入到远处的数据库服务器中。 利用这个功能可以构建两个相同的数据库，一个用来测试，一个用来正式使用。<br><a id="more"></a></p><p>执行环境：可以在<span style="color: #3366ff;">SQLPLUS.EXE</span>或者<span style="color: #3366ff;">DOS</span>（命令行）中执行，</p><p> 　　DOS中可以执行是因为在<span style="color: #3366ff;">%ORACLE_HOME%/BIN</span>目录下有EXP.EXE与IMP.EXE文件被用来执行导入导出。</p><p>oracle用java编写，SQLPLUS.EXE、EXP.EXE、IMP.EXE这几个文件有可能是被包装后的类文件。</p><p>SQLPLUS.EXE调用EXP.EXE、IMP.EXE所包裹的类，完成导入导出功能。</p><p>下面介绍的是导入导出的不同场景的实例。</p><h4 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h4><p>1、将数据库TEST完全导出,用户名system 密码manager 导出到D:\daochu.dmp中　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp system/manager@TEST file=d:\test.dmp full=y</span><br></pre></td></tr></table></figure><p>2、将数据库中system用户与sys用户的表导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp system/manager@TEST file=d:\test.dmp owner=(system,sys)</span><br></pre></td></tr></table></figure><p>3、将数据库中的inner_notify、notify_staff_relat表导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp testuser/123456@TESTDB2 file= d:\data\TESTDB2.dmp tables=(inner_notify,notify_staff_relat)</span><br></pre></td></tr></table></figure><p>4、将数据库中的表table1中的字段filed1以”00”打头的数据导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp system/manager@TEST file=d:\test.dmp tables=(table1) query=\&quot;where filed1 like &apos;00%&apos;\&quot;</span><br></pre></td></tr></table></figure><p>上面是常用的导出，如果相对导出的dmp文件进行压缩，可以在上面命令后面加上 <span style="color: #0000ff;">compress=y </span>来实现。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp system/manager@TEST file=d:\test.dmp full=y compress=y</span><br></pre></td></tr></table></figure><h4 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h4><p>1、将D:\test.dmp 中的数据导入ORCL数据库中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp system/manager@ORCL file=d:\test.dmp</span><br></pre></td></tr></table></figure><p>上面的语句可能会出现问题，如果有一些表已经存在，它就会报错，对该表就不进行导入，解决：在后面加上 <span style="color: #0000ff;">ignore=y</span> 或者 <span style="color: #0000ff;">table_exists_action=replace</span> （具体使用哪个请根据oracle数据库版本而定，在oracle 10以后引入了数据泵技术impdp，可以在导入时使用table_exists_action=replace参数）就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imp system/manager@ORCL full=y file= d:\test.dmp ignore=y</span><br><span class="line"></span><br><span class="line">impdp system/manager@ORCL directory=Dir dumpfile= d:\test.dmp full=y table_exists_action=replace</span><br></pre></td></tr></table></figure><p>2、将d:\test.dmp中的表table1导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp system/manager@ORCL file=d:\test.dmp tables=(table1)</span><br></pre></td></tr></table></figure><p>基本上上面的导入导出够用了。不少情况要先是将表彻底删除，然后导入。</p><p><span style="color: #008000;">操作时注意以下几点：</span></p><p> 　　1、操作者要有足够的权限，权限不够它会提示。</p><p>给用户授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--用sys用户登录</span><br><span class="line"></span><br><span class="line">sqlplus sys/123456 as sysdba</span><br><span class="line"></span><br><span class="line">--授予testuser用户dba权限，dba权限过高，请谨慎操作</span><br><span class="line"></span><br><span class="line">grant dba to testuser</span><br></pre></td></tr></table></figure><p>2、数据库是可以连上的。可以用<span style="color: #0000ff;">tnsping TEST</span> 来获得数据库TEST能否连上。</p><h4 id="exp-imp和expdp-impdp的区别"><a href="#exp-imp和expdp-impdp的区别" class="headerlink" title="exp/imp和expdp/impdp的区别"></a>exp/imp和expdp/impdp的区别</h4><p>Oracle10g提出的数据泵技术，在以下几个方面优于exp/imp命令：</p><p>　　1、数据泵工具运行于服务器端，相比客户端的exp/imp其性能更好，并能实现exp/imp的全部功能。</p><p>　　2、通过使用exclude,include,content等参数，数据泵可以为数据及数据对象提供更细微级别的选择性。</p><p>　　3、通过设定数据库版本号，数据泵可以兼容老版本的数据库系统。</p><p>　　4、并行执行。</p><p>　　5、通过estimate_only参数，数据泵可以预估导出作业所需的磁盘空间。</p><p>　　6、支持分布式环境中通过数据库连接实现导入\导出。</p><p>　　7、支持导入时重新映射功能（即将对象导入到新的目标数据文件、架构及表空间等）。</p><p>　　8、支持元数据压缩及数据采样。</p><p><strong>实际对比：</strong></p><p>1、把用户usera的对象导入到userb</p><p>emp/imp用法：<span style="color: #0000ff;">formuser=usera touser=userb</span></p><p>empdp/impdp用法：<span style="color: #0000ff;">remap_schema=’usera’:’userb’</span></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imp system/password fromuser=usera touser=userb file=back.dmp log=backlog.log;</span><br><span class="line"></span><br><span class="line">impdp system/password directory=expdp dumpfile=back.dmp remap_schema=&apos;usera&apos;:&apos;userb&apos; logfile=backlog.log</span><br></pre></td></tr></table></figure><p>2、更改表空间</p><p>用exp/imp，想要更改表空间，需要手动处理，</p><p>而impdp只要用：<span style="color: #0000ff;">remap_tablespace=’tablespace_old’ : ‘tablespace_new’</span></p><p>3、当制定多个表的时候</p><p>exp/imp用法：tables(‘table1’,’table2’,’table3’)</p><p>expdp/impdp用法：tables=’table1’,’table2’,’table3’</p><p>4、是否要导出数据行</p><p>exp：rows=y,导出数据行，rows=n不导出数据行</p><p>expdp：content(all:对象+数据行，data_only：只导出对象，metadata_only：只导出数据的记录）</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>问题描述</p><blockquote><p>ORA-39001: 参数值无效</p><p>ORA-39000: 转储文件说明错误</p><p>ORA-39143: 转储文件 “.dmp” 可能是原始的导出转储文件</p></blockquote><p>原因及解决</p><p>.dmp文件是使用exp命令导出的，而使用impdp 无法识别exp命令导出的文件，需要使用imp命令进行导入</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Oracle数据导入导出imp/exp就相当于oracle数据还原与备份。exp命令可以把数据从远程数据库服务器导出到本地的dmp文件，imp命令可以把dmp文件从本地导入到远处的数据库服务器中。 利用这个功能可以构建两个相同的数据库，一个用来测试，一个用来正式使用。&lt;br&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://easydecode.coding.me/categories/DataBase/"/>
    
      <category term="Oracle" scheme="https://easydecode.coding.me/categories/DataBase/Oracle/"/>
    
    
      <category term="DataBase" scheme="https://easydecode.coding.me/tags/DataBase/"/>
    
      <category term="Oracle" scheme="https://easydecode.coding.me/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Java程序员常犯的10个错误</title>
    <link href="https://easydecode.coding.me/2017/07/03/f3cb340d.html"/>
    <id>https://easydecode.coding.me/2017/07/03/f3cb340d.html</id>
    <published>2017-07-03T07:04:47.000Z</published>
    <updated>2018-08-28T08:15:51.785Z</updated>
    
    <content type="html"><![CDATA[<p>人非圣贤，孰能无过。都说Java语言是一门简单的编程语言，基于C++演化而来，剔除了很多C++中的复杂特性，但这并不能保证Java程序员不会犯错。那么对于广大的Java程序员来说，它们最常犯的10个错误是什么呢？本文通过总结出Java程序员最常犯的10大错误，可以有效地帮组Java后来者少走弯路，少加班，并写出更健壮的应用程序。<br><a id="more"></a></p><h3 id="一、数组转ArrayList"><a href="#一、数组转ArrayList" class="headerlink" title="一、数组转ArrayList"></a>一、数组转ArrayList</h3><p>为了实现把一个数组转换成一个ArrayList，很多Java程序员会使用如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure><p>Arrays.asList确实会返回一个 ArrayList对象，但是该类是 Arrays类 中一个私有静态内部类，而不是常见的 java.util.ArrayList类。这个 java.util.Arrays.ArrayList 类具有 set()，get()，contains()等方法，但是不具有任何添加或移除元素的任何方法。因为该类的大小(size)是固定的。为了创建出一个真正的 java.util.ArrayList,代码应该如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(arr));</span><br></pre></td></tr></table></figure><p>我们知道，ArrayList的构造方法可以接受一个 Collection 类型的对象，而我们的 java.util.Arrays.ArrayList 正好也是它的一个子类。实际上，更加高效的代码示例是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(arr.length);</span><br><span class="line">Collections.addAll(arrayList, arr);</span><br></pre></td></tr></table></figure><h3 id="二、数组是否包含特定值"><a href="#二、数组是否包含特定值" class="headerlink" title="二、数组是否包含特定值"></a>二、数组是否包含特定值</h3><p>为了检查数组中是否包含某个特定值，很多Java程序员会使用如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));</span><br><span class="line"><span class="keyword">return</span> set.contains(targetValue);</span><br></pre></td></tr></table></figure><p>就功能而言，该代码是正确无误的，但在数组转List,List再转Set的过程中消耗了大量的性能。我们可以优化成如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(arr).contains(targetValue);</span><br></pre></td></tr></table></figure><p>或者，进一步优化成如下所示最高效的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line">4<span class="keyword">if</span>(s.equals(targetValue))</span><br><span class="line">4<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="三、在迭代时移除List中的元素"><a href="#三、在迭代时移除List中的元素" class="headerlink" title="三、在迭代时移除List中的元素"></a>三、在迭代时移除List中的元素</h3><p>首先，看一下在迭代过程中移除List中元素的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">4list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>这个示例代码的输出结果是：</p><blockquote><p>[b, d]</p></blockquote><p>这个示例代码中存在一个非常严重的错误。当一个元素被移除时，该List的大小(size)就会缩减，同时也改变了索引的指向。所以，在迭代的过程中使用索引，将无法从List中正确地删除多个指定的元素。</p><p>你可能知道解决这个错误的方式之一是使用迭代器(iterator)。而且，你可能认为Java中的 foreach 语句与迭代器(iterator)是非常相似的，但实际情况并不是这样。我们考虑一下如下的示例代码：</p><p>这个示例代码会抛出来一个 ConcurrentModificationException。我们应该修改成如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&amp;lt;String&amp;gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>));</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">4<span class="keyword">if</span> (<span class="string">"a"</span>.equals(s))</span><br><span class="line">4list.remove(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color: #3366ff;">next()方法必须在remove()方法之前被调用</span>。</p><p>在 foreach 循环中，编译器使得 remove()方法先于next()方法被调用，这就导致了 ConcurrentModificationException 异常。具体细节可以查看 ArrayList.iterator()的源码。</p><h3 id="四、Hashtable-vs-HashMap"><a href="#四、Hashtable-vs-HashMap" class="headerlink" title="四、Hashtable vs HashMap"></a>四、Hashtable vs HashMap</h3><p>学习过数据结构的读者都知道一种非常重要的数据结构叫做 哈希表。在Java中，对应哈希表的的类是 HashMap 而不是 Hashtable。HashMap与Hashtable之间的最核心区别就是：HashMap是非同步的，Hashtable是同步的。</p><h3 id="五、在Collection中使用原始类型"><a href="#五、在Collection中使用原始类型" class="headerlink" title="五、在Collection中使用原始类型"></a>五、在Collection中使用原始类型</h3><p>在Java中，很容易把原始类型与无限通配类型混淆。我们举个Set相关的例子：Set就是原始类型；Set&lt;?&gt;就是无限通配类型。我们看一个使用在List中使用原始类型的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List list, Object o)</span></span>&#123;</span><br><span class="line">4list.add(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">4List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">4add(list, <span class="number">10</span>);</span><br><span class="line">4String s = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例代码会抛出来一个异常：</p><blockquote><p>Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at …</p></blockquote><p>在Collection使用原始类型是具有很多的类型错误风险的，因为原始类型没有静态类型检查。实际上，Set、Set&lt;?&gt;和Set之间具有非常大的差异。</p><h3 id="六、访问权限"><a href="#六、访问权限" class="headerlink" title="六、访问权限"></a>六、访问权限</h3><p>很多的Java初学者喜欢使用 public 来修饰类的成员。这样可以很方便地直接访问和存取该成员。但是，这是一种非常糟糕的编程风格，正确的设计风格应该是尽可能降低类成员的访问权限。</p><h3 id="七、ArrayList-vs-LinkedList"><a href="#七、ArrayList-vs-LinkedList" class="headerlink" title="七、ArrayList vs LinkedList"></a>七、ArrayList vs LinkedList</h3><p>很多的Java初学者不明白ArrayList与LinkedList之间的区别，所以，他们完全只用相对简单的ArrayList，甚至不知道JDK中还存在LinkedList。但是，在某些具体场景下，这两种List的选择会导致程序性能的巨大差异。简单而言：当应用场景中有很多的 add/remove 操作，只有少量的随机访问操作时，应该选择LinkedList;在其他的场景下，考虑使用ArrayList。</p><h3 id="八、可变-vs-不可变"><a href="#八、可变-vs-不可变" class="headerlink" title="八、可变 vs 不可变"></a>八、可变 vs 不可变</h3><p>不可变的对象具有非常多的优势，比如简单，安全等。但是，对于每一个不同的值，都需要该类的一个对象。而且，生成很多对象带来的问题就是可能导致频繁的垃圾回收。所以，在选择可变类还是不可变类时，应该综合考虑后再做抉择。</p><p>通常而言，可变对象可以避免创建大量的中间对象。一个非常经典的例子就是链接大量的短String对象为一个长的String对象。如果使用不可变String类，链接的过程将产生大量的，适合立即被垃圾回收的中间String对象，这将消耗大量的CPU性能和内存空间。此时，使用一个可变的StringBuilder或StringBuffer才是正确的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line">4result = result + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上述情况，可变对象在其他场景下可能由于不可变对象。比如，传递一个可变的对象到方法内部，利用该对象可以收集多个结果，而不用在多个循环层次中跳进跳出。。</p><h3 id="九、继承中的构造函数"><a href="#九、继承中的构造函数" class="headerlink" title="九、继承中的构造函数"></a>九、继承中的构造函数</h3><p>上图中出现的两个编译时错误是因为：父类中没有定义默认构造函数，而子类中又调用了父类的默认构造函数。在Java中，如果一个类不定义任何构造函数，编译期将自动插入一个默认构造函数到给类中。一旦一个类定义了任何一个构造函数，编译期就不会插入任何构造函数到类中。在上面的示例中，Super类定义了一个参数类型为String的构造函数，所以该类中只有一个构造函数，不会有默认构造函数了。</p><p> &amp;emps;在我们的子类 Sub 中，我们定义了两个构造函数：一个参数类型为String的构造函数，另一个为午餐的默认函数。由于它们都没有在函数体的第一行指定调用父类的哪一个构造函数，所以它们都需要调用父类 Super 的默认构造函数。但是，父类 Super 的默认构造函数是不存在的，所以编译器报告了这两个错误信息。</p><h3 id="十、字符串对象的两个构建方式"><a href="#十、字符串对象的两个构建方式" class="headerlink" title="十、字符串对象的两个构建方式"></a>十、字符串对象的两个构建方式</h3><p>Java中的字符串对象具有两个常见的创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. use double quotes</span></span><br><span class="line">String x = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 2. use constructor&lt;/span&gt;</span></span><br><span class="line">String y = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p>它们之间的区别是什么呢？我们再看一下如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"abcd"</span>;</span><br><span class="line">String b = <span class="string">"abcd"</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// True</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">// True</span></span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(c == d); <span class="comment">// False</span></span><br><span class="line">System.out.println(c.equals(d)); <span class="comment">// True</span></span><br></pre></td></tr></table></figure><p>本文源自：<a href="http://www.cnblogs.com/tiantianbianma/p/7077463.html" target="_blank" rel="noopener">http://www.cnblogs.com/tiantianbianma/p/7077463.html</a></p>]]></content>
    
    <summary type="html">
    
      如果一个人没有能力帮助他所爱的人，最好不要随便谈什么爱与不爱。当然，帮助不等于爱情，但爱情不能不包括帮助。 —— 鲁迅
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>35个Java代码性能优化总结</title>
    <link href="https://easydecode.coding.me/2017/06/23/1075e992.html"/>
    <id>https://easydecode.coding.me/2017/06/23/1075e992.html</id>
    <published>2017-06-23T09:06:53.000Z</published>
    <updated>2018-08-28T08:17:48.032Z</updated>
    
    <content type="html"><![CDATA[<p>代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。<br><strong>代码优化的目标是：</strong></p><p>1、减小代码的体积</p><p>2、提高代码运行的效率<br><a id="more"></a></p><h3 id="1、尽量指定类、方法的final修饰符"><a href="#1、尽量指定类、方法的final修饰符" class="headerlink" title="1、尽量指定类、方法的final修饰符"></a>1、尽量指定类、方法的final修饰符</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。</p><h3 id="2、尽量重用对象"><a href="#2、尽量重用对象" class="headerlink" title="2、尽量重用对象"></a>2、尽量重用对象</h3><p>特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><h3 id="3、尽可能使用局部变量"><a href="#3、尽可能使用局部变量" class="headerlink" title="3、尽可能使用局部变量"></a>3、尽可能使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p><h3 id="4、及时关闭流"><a href="#4、及时关闭流" class="headerlink" title="4、及时关闭流"></a>4、及时关闭流</h3><p>Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p><h3 id="5、尽量减少对变量的重复计算"><a href="#5、尽量减少对变量的重复计算" class="headerlink" title="5、尽量减少对变量的重复计算"></a>5、尽量减少对变量的重复计算</h3><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> length = list.size(); i &lt; length; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在list.size()很大的时候，就减少了很多的消耗</p><h3 id="6、尽量采用懒加载的策略，即在需要的时候才创建"><a href="#6、尽量采用懒加载的策略，即在需要的时候才创建" class="headerlink" title="6、尽量采用懒加载的策略，即在需要的时候才创建"></a>6、尽量采用懒加载的策略，即在需要的时候才创建</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"aaa"</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">    String str = <span class="string">"aaa"</span>;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、慎用异常"><a href="#7、慎用异常" class="headerlink" title="7、慎用异常"></a>7、慎用异常</h3><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><h3 id="8、不要在循环中使用try…catch…，应该把其放在最外层"><a href="#8、不要在循环中使用try…catch…，应该把其放在最外层" class="headerlink" title="8、不要在循环中使用try…catch…，应该把其放在最外层"></a>8、不要在循环中使用try…catch…，应该把其放在最外层</h3><p>除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了</p><h3 id="9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度"><a href="#9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度" class="headerlink" title="9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度"></a>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</h3><p>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：</p><p>（1）StringBuilder()　　　　　　// 默认分配16个字符的空间</p><p>（2）StringBuilder(int size)　　// 默认分配size个字符的空间</p><p>（3）StringBuilder(String str)　// 默认分配16个字符+str.length()个字符空间</p><p>可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p><p>（1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间</p><p>（2）把原来的4096个字符拷贝到新的的字符数组中去</p><p>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</p><h3 id="10、当复制大量数据时，使用System-arraycopy-命令"><a href="#10、当复制大量数据时，使用System-arraycopy-命令" class="headerlink" title="10、当复制大量数据时，使用System.arraycopy()命令"></a>10、当复制大量数据时，使用System.arraycopy()命令</h3><h3 id="11、乘法和除法使用移位操作"><a href="#11、乘法和除法使用移位操作" class="headerlink" title="11、乘法和除法使用移位操作"></a>11、乘法和除法使用移位操作</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>)&#123;</span><br><span class="line">    a = val * <span class="number">8</span>;</span><br><span class="line">    b = val / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>)&#123;</span><br><span class="line">    a = val &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    b = val &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p><h3 id="12、循环内不要不断创建对象引用"><a href="#12、循环内不要不断创建对象引用" class="headerlink" title="12、循环内不要不断创建对象引用"></a>12、循环内不要不断创建对象引用</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++)&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123;</span><br><span class="line">    obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p><h3 id="13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList"><a href="#13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList" class="headerlink" title="13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList"></a>13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</h3><h3 id="14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销"><a href="#14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销" class="headerlink" title="14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销"></a>14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</h3><h3 id="15、不要将数组声明为public-static-final"><a href="#15、不要将数组声明为public-static-final" class="headerlink" title="15、不要将数组声明为public static final"></a>15、不要将数组声明为public static final</h3><p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变</p><h3 id="16、尽量在合适的场合使用单例"><a href="#16、尽量在合适的场合使用单例" class="headerlink" title="16、尽量在合适的场合使用单例"></a>16、尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><p>（1）控制资源的使用，通过线程同步来控制资源的并发访问</p><p>（2）控制实例的产生，以达到节约资源的目的</p><p>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p><h3 id="17、尽量避免随意使用静态变量"><a href="#17、尽量避免随意使用静态变量" class="headerlink" title="17、尽量避免随意使用静态变量"></a>17、尽量避免随意使用静态变量</h3><p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止</p><h3 id="18、及时清除不再需要的会话"><a href="#18、及时清除不再需要的会话" class="headerlink" title="18、及时清除不再需要的会话"></a>18、及时清除不再需要的会话</h3><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。</p><h3 id="19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历"><a href="#19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历" class="headerlink" title="19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历"></a>19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</h3><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterable();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        iterator.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p><h3 id="20、使用同步代码块替代同步方法"><a href="#20、使用同步代码块替代同步方法" class="headerlink" title="20、使用同步代码块替代同步方法"></a>20、使用同步代码块替代同步方法</h3><p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p><h3 id="21、将常量声明为static-final，并以大写命名"><a href="#21、将常量声明为static-final，并以大写命名" class="headerlink" title="21、将常量声明为static final，并以大写命名"></a>21、将常量声明为static final，并以大写命名</h3><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p><h3 id="22、不要创建一些不使用的对象，不要导入一些不使用的类"><a href="#22、不要创建一些不使用的对象，不要导入一些不使用的类" class="headerlink" title="22、不要创建一些不使用的对象，不要导入一些不使用的类"></a>22、不要创建一些不使用的对象，不要导入一些不使用的类</h3><p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p><h3 id="23、程序运行过程中避免使用反射"><a href="#23、程序运行过程中避免使用反射" class="headerlink" title="23、程序运行过程中避免使用反射"></a>23、程序运行过程中避免使用反射</h3><p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p><h3 id="24、使用数据库连接池和线程池"><a href="#24、使用数据库连接池和线程池" class="headerlink" title="24、使用数据库连接池和线程池"></a>24、使用数据库连接池和线程池</h3><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</p><h3 id="25、使用带缓冲的输入输出流进行IO操作"><a href="#25、使用带缓冲的输入输出流进行IO操作" class="headerlink" title="25、使用带缓冲的输入输出流进行IO操作"></a>25、使用带缓冲的输入输出流进行IO操作</h3><p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率</p><h3 id="26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList"><a href="#26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList" class="headerlink" title="26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList"></a>26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList</h3><p>这个，理解ArrayList和LinkedList的原理就知道了</p><h3 id="27、不要让public方法中有太多的形参"><a href="#27、不要让public方法中有太多的形参" class="headerlink" title="27、不要让public方法中有太多的形参"></a>27、不要让public方法中有太多的形参</h3><p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p><p>1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</p><p>2、参数太多势必导致方法调用的出错概率增加</p><p>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参</p><h3 id="28、字符串变量和字符串常量equals的时候将字符串常量写在前面"><a href="#28、字符串变量和字符串常量equals的时候将字符串常量写在前面" class="headerlink" title="28、字符串变量和字符串常量equals的时候将字符串常量写在前面"></a>28、字符串变量和字符串常量equals的时候将字符串常量写在前面</h3><p>这是一个比较常见的小技巧了，如果有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">"123"</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>; <span class="keyword">if</span> (<span class="string">"123"</span>.equals(str))&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做主要是可以避免空指针异常</p><h3 id="29、请知道，在java中if-i-1-和if-1-i-是没有区别的，但从阅读习惯上讲，建议使用前者"><a href="#29、请知道，在java中if-i-1-和if-1-i-是没有区别的，但从阅读习惯上讲，建议使用前者" class="headerlink" title="29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者"></a>29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者</h3><p>平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。</p><p>在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C/C++判断”i==1″不成立，所以以0表示，即false。但是如果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (i = <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p><p>但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p><h3 id="30、不要对数组使用toString-方法"><a href="#30、不要对数组使用toString-方法" class="headerlink" title="30、不要对数组使用toString()方法"></a>30、不要对数组使用toString()方法</h3><p>看一下对数组使用toString()打印出来的是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] is = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(is.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><blockquote><p>[I@18a992f</p></blockquote><p>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections&lt;E&gt;重写了Object的toString()方法。</p><h3 id="31、不要对超出范围的基本数据类型做向下强制转型"><a href="#31、不要对超出范围的基本数据类型做向下强制转型" class="headerlink" title="31、不要对超出范围的基本数据类型做向下强制转型"></a>31、不要对超出范围的基本数据类型做向下强制转型</h3><p>这绝不会得到想要的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">12345678901234L</span>;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)l;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可能期望得到其中的某几位，但是结果却是：</p><p>1942892530</p><p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p><p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p><p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p><p>0111 0011 1100 1110 0010 1111 1111 0010</p><p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p><p>1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f = 3.5f”</p><p>2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int</p><h3 id="32、公用的集合类中不使用的数据一定要及时remove掉"><a href="#32、公用的集合类中不使用的数据一定要及时remove掉" class="headerlink" title="32、公用的集合类中不使用的数据一定要及时remove掉"></a>32、公用的集合类中不使用的数据一定要及时remove掉</h3><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p><h3 id="33、把一个基本数据类型转为字符串，基本数据类型-toString-是最快的方式、String-valueOf-数据-次之、数据-””最慢"><a href="#33、把一个基本数据类型转为字符串，基本数据类型-toString-是最快的方式、String-valueOf-数据-次之、数据-””最慢" class="headerlink" title="33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢"></a>33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢</h3><p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loopTime = <span class="number">50000</span>;</span><br><span class="line">    Integer i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)&#123;</span><br><span class="line">        String str = String.valueOf(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"String.valueOf()："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)&#123;</span><br><span class="line">        String str = i.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Integer.toString()："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)&#123;</span><br><span class="line">        String str = i + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"i + \"\"："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>String.valueOf()：11ms Integer.toString()：5ms i + “”：25ms</p></blockquote><p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单：</p><p>1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断</p><p>2、Integer.toString()方法就不说了，直接调用了</p><p>3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串</p><p>三者对比下来，明显是2最快、1次之、3最慢</p><h3 id="34、使用最有效率的方式去遍历Map"><a href="#34、使用最有效率的方式去遍历Map" class="headerlink" title="34、使用最有效率的方式去遍历Map"></a>34、使用最有效率的方式去遍历Map</h3><p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; hm = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    hm.put(<span class="string">"111"</span>, <span class="string">"222"</span>);</span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, String&gt; entry = iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"\t"</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你只是想遍历一下这个Map的key值，那用”Set&lt;String&gt; keySet = hm.keySet();”会比较合适一些</p><h3 id="35、对资源的close-建议分开操作"><a href="#35、对资源的close-建议分开操作" class="headerlink" title="35、对资源的close()建议分开操作"></a>35、对资源的close()建议分开操作</h3><p>意思是，比如我有这么一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     XXX.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉。</p><p>本文源自：<a href="https://www.oschina.net/question/2978416_2243019" target="_blank" rel="noopener">https://www.oschina.net/question/2978416_2243019</a></p>]]></content>
    
    <summary type="html">
    
      人必须生活着，爱才有所附丽。 —— 鲁迅
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程的三种实现方式</title>
    <link href="https://easydecode.coding.me/2017/06/21/6f73f99b.html"/>
    <id>https://easydecode.coding.me/2017/06/21/6f73f99b.html</id>
    <published>2017-06-21T11:47:20.000Z</published>
    <updated>2018-08-30T06:19:02.930Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的多线程有三种实现方式：</p><p>1.继承Thread类，重写run方法。Thread本质上也是一个实现了Runnable的实例，他代表一个线程的实例，并且启动线程的唯一方法就是通过Thread类的start方法。</p><p>2.实现Runnable接口，并实现该接口的run()方法.创建一个Thread对象，用实现的Runnable接口的对象作为参数实例化Thread对象，调用此对象的start方法。</p><p>3.实现Callable接口，重写call方法。<br><a id="more"></a></p><p>Callable接口与Runnable接口的功能类似，但提供了比Runnable更强大的功能。有以下三点：</p><p>1）.Callable可以在任务结束后提供一个返回值，Runnable没有提供这个功能。</p><p>2）.Callable中的call方法可以抛出异常，而Runnable的run方法不能抛出异常。</p><p>3）.运行Callable可以拿到一个Future对象，表示异步计算的结果，提供了检查计算是否完成的方法。</p><p><span style="color: #0000ff;">需要注意的是，无论用那种方式实现了多线程，调用start方法并不意味着立即执行多线程代码，而是使得线程变为可运行状态。</span></p><p>以下为大家提供一个简单的代码实例：</p><p>分别用Runnable和Thread方法实现，展示各个方法的</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> SourceA s;</span><br><span class="line">    <span class="keyword">private</span> String id = <span class="string">"001"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestRunnable</span><span class="params">(SourceA s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"i will sleep"</span>+ time);</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(s)&#123;</span><br><span class="line">            s.notify();</span><br><span class="line">            System.out.println(<span class="string">"我唤醒了002！"</span>);</span><br><span class="line">            System.out.println(<span class="string">"我存入了id"</span>+id);</span><br><span class="line">            s.setSource(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> SourceA s = <span class="keyword">null</span>;</span><br><span class="line">    String id = <span class="string">"002"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(SourceA s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"i will sleep"</span>+ time);</span><br><span class="line">            sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(s)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"我"</span>+ id +<span class="string">"要进行等待了"</span>);</span><br><span class="line">                s.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"我被唤醒了"</span>);</span><br><span class="line">            System.out.println(<span class="string">"我存入了id"</span>+id);</span><br><span class="line">            s.setSource(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SourceA类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&amp;lt;String&amp;gt; list = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&amp;lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSource</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        list.add(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test测试类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SourceA s = <span class="keyword">new</span> SourceA();</span><br><span class="line">    TestThread tt = <span class="keyword">new</span> TestThread(s);</span><br><span class="line">    TestRunnable tr = <span class="keyword">new</span> TestRunnable(s);</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(tr);</span><br><span class="line">    System.out.println(<span class="string">"调用线程1"</span>);</span><br><span class="line">    tt.start();</span><br><span class="line">    System.out.println(<span class="string">"调用线程2"</span>);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><a href="http://blog.easydcode.com/wp-content/uploads/2017/06/161856034387471.png" target="_blank" rel="noopener"><img src="http://blog.easydcode.com/wp-content/uploads/2017/06/161856034387471.png" alt="Java多线程的三种实现方式" title="Java多线程的三种实现方式"></a></p><h4 id="run-start的区别"><a href="#run-start的区别" class="headerlink" title="run start的区别"></a>run start的区别</h4><p>start方法是启动一个线程，而线程中的run方法来完成实际的操作。</p><p>如果开发人员直接调用run方法，那么就会将这个方法当作一个普通函数来调用，并没有多开辟线程，开发人员如果希望多线程异步执行，则需要调用start方法。</p><h4 id="sleep、wait的区别"><a href="#sleep、wait的区别" class="headerlink" title="sleep、wait的区别"></a>sleep、wait的区别</h4><p>1.两者处理的机制不同，sleep方法主要是，让线程暂停执行一段时间，时间一到自动恢复，并不会释放所占用的锁，当调用wait方法以后，他会释放所占用的对象锁，等待其他线程调用notify方法才会再次醒来。</p><p>2.sleep是Threa的静态方法，是用来控制线程自身流程的，而wait是object的方法，用于进行线程通信。</p><p>3.两者使用的区域不同。sleep可以在任何地方使用，wait必须放在同步控制方法，或者语句块中执行。</p><h4 id="synchronized、notify、wait的运用"><a href="#synchronized、notify、wait的运用" class="headerlink" title="synchronized、notify、wait的运用"></a>synchronized、notify、wait的运用</h4><p>synchronized关键字有两种用法，synchronized方法和synchronized语句块。</p><p>public synchronized void function(){}</p><p>synchronized(object){}</p><p>当某个资源被synchronized所修饰，线程1线程2等多个线程在共同请求这个资源，线程1先请求到，调用了对象的wait方法释放了对象的锁，此时线程2可以对这个对象进行访问，在工作结束时可以调用对象的notify方法，唤醒等待队列中正在等待的线程，此时被唤醒的线程将会再一次拿到对象锁，对对象进行操作。可以调用notifyAll方法，唤醒等待队列中的所有线程。</p><p>需要注意的是一个线程被唤醒不代表立即获取对象锁，必须等调用的线程对象的方法推出synchronized块释放对象锁后，被唤醒的进程才会获得对象锁。</p><p>本文源自：<a href="http://www.cnblogs.com/yfsmooth/p/4652206.html" target="_blank" rel="noopener">http://www.cnblogs.com/yfsmooth/p/4652206.html</a></p>]]></content>
    
    <summary type="html">
    
      笨蛋自以为聪明，聪明人才知道自己是笨蛋。 —— 莎士比亚
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JBOSS安装使用和配置教程</title>
    <link href="https://easydecode.coding.me/2017/06/02/9b504b05.html"/>
    <id>https://easydecode.coding.me/2017/06/02/9b504b05.html</id>
    <published>2017-06-02T01:06:39.000Z</published>
    <updated>2018-08-30T05:50:20.875Z</updated>
    
    <content type="html"><![CDATA[<p>JBoss是一个基于J2EE的开放源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。</p><p>JBoss是一个管理EJB（Enterprise JavaBean）的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。这篇文章记录了一下自己安装jboss的过程。<br><a id="more"></a></p><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><p>下载安装 <a href="http://jbossas.jboss.org/downloads/" target="_blank" rel="noopener">http://jbossas.jboss.org/downloads/</a></p><p>我下载的是：JBoss AS7.1.1.Final</p><h4 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h4><p>解压安装包  D:\jboss-as-7.1.1.Final</p><h4 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h4><p>环境变量的设置  JBoss的使用必须有JDK，只有JRE是不行的，所以你的电脑必须首先配置Java环境变量</p><p><span style="background-color: #ffffff; color: #0000ff;">注意：最新的jboss7同样不支持JDK1.8，请使用JDK1.7或者以下的版本运行jboss</span></p><div><br><br>   系统变量→新建 JAVA_HOME 变量。 变量值填写jdk的安装目录<br><br></div><br><div><br><br>   系统变量→寻找 Path 变量→编辑  在变量值最后输入%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;<br><br>  系统变量→新建<span lang="EN-US"> CLASSPATH</span>变量<br><br>  变量值填写<span lang="EN-US">  .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</span>（注意最前面有一点）<br><br></div><p>  在环境变量新建一个：JBOSS_HOME   路径为你解压JBOSS的路径：D:\jboss-as-7.1.1.Final</p><h4 id="4、启动测试JBOSS"><a href="#4、启动测试JBOSS" class="headerlink" title="4、启动测试JBOSS"></a>4、启动测试JBOSS</h4><p>打开%JBOSS_HOME%\bin目录下面的standalone.bat（Linux上是standalone.sh）启动JBOSS</p><p><img src="/images/javaWeb/jboss-1.png" alt=""></p><p>然后在IE中输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>能看到jboss欢迎界面即表示安装成功，如下图所示</p><p><img src="/images/javaWeb/jboss-2.png" alt="JBOSS安装使用和配置教程"></p><h4 id="5、部署服务"><a href="#5、部署服务" class="headerlink" title="5、部署服务"></a>5、部署服务</h4><p>把待部署的war文件或者其他文件拷贝到D:\jboss-as-7.1.1.Final\standalone\deployments下面，支持热部署。比如Test.war拷贝到上述目录下面，然后在IE中输入<a href="http://localhost:8080/***.jsp？***&amp;***&amp;***就可以进行服务访问了。" target="_blank" rel="noopener">http://localhost:8080/***.jsp？***&amp;***&amp;***就可以进行服务访问了。</a></p><h4 id="6、添加管理员用户"><a href="#6、添加管理员用户" class="headerlink" title="6、添加管理员用户"></a>6、添加管理员用户</h4><p>如果想要访问后台，需要增加用户才能访问。可在服务端JBoss的bin目录下执行add-user.bat（add-user.sh） 来添加管理员用户<img src="/images/javaWeb/jboss-3.png" alt=""></p><p>访问<a href="http://localhost:9990/console" target="_blank" rel="noopener">http://localhost:9990/console</a>，进入以下页面：</p><p><img src="/images/javaWeb/jboss-4.png" alt=""></p><h4 id="7、修改默认端口号"><a href="#7、修改默认端口号" class="headerlink" title="7、修改默认端口号"></a>7、修改默认端口号</h4><p>jboss7.1.1的默认端口号是8080，我将修改为8888。</p><p>首先打开jboss7.1.1的配置文件standalond.xml,它在D:\profession\jboss-as-7.1.1.Final\standalone\configuration路径下。</p><p>然后，查找节点 &lt;socket-binding-group&gt;。里面有 &lt;socket-binding name=”http” port=”8080”/&gt;，将8080修改为8888。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JBoss是一个基于J2EE的开放源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。&lt;/p&gt;
&lt;p&gt;JBoss是一个管理EJB（Enterprise JavaBean）的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。这篇文章记录了一下自己安装jboss的过程。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SQLServer连接错误</title>
    <link href="https://easydecode.coding.me/2017/05/17/95d600c2.html"/>
    <id>https://easydecode.coding.me/2017/05/17/95d600c2.html</id>
    <published>2017-05-17T13:48:01.000Z</published>
    <updated>2018-09-13T02:17:33.405Z</updated>
    
    <content type="html"><![CDATA[<p>错误信息：</p><blockquote><p>无法连接到 windows。</p><hr><p>在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: 命名管道提供程序, error: 40 - 无法打开到 SQL Server 的连接) (Microsoft SQL Server，错误: 53)</p></blockquote><!-- [![SQLServer连接错误](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-1-e1501392570484.png "SQLServer连接错误")](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-1.png) --><p><img src="/images/database/sqlserver-1.png" alt="SQLServer连接错误"></p><p>今天打开SQL Server 2008 的 SQL Server Management Studio，输入sa的密码发现，无法登陆数据库，提示信息如上：</p><a id="more"></a><p><strong> 解决方案： </strong></p><p><strong> 1、先查看计算机名（Win7系统） </strong></p><!-- [![](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-2.png)](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-2.png) --><p><img src="/images/database/sqlserver-2.png" alt=""></p><p>2、 然后在SQL Server Management Studio登录界面选择这个服务器</p><!-- ![](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-3.png) --><p><img src="/images/database/sqlserver-3.png" alt=""></p><p>3、 如果在列表里没有的话就点击 浏览更多 ，就可以找到了</p><!-- [![](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-4.png)](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-4.png) --><p><img src="/images/database/sqlserver-4.png" alt=""></p><p>选择好正确的服务器就可以正常登录了</p><p>如果还是不行，修改一下计算机名重启后再按照上面的步骤进行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;错误信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无法连接到 windows。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: 命名管道提供程序, error: 40 - 无法打开到 SQL Server 的连接) (Microsoft SQL Server，错误: 53)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- [![SQLServer连接错误](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-1-e1501392570484.png &quot;SQLServer连接错误&quot;)](http://blog.easydcode.com/wp-content/uploads/2017/05/sqlserver-1.png) --&gt;
&lt;p&gt;&lt;img src=&quot;/images/database/sqlserver-1.png&quot; alt=&quot;SQLServer连接错误&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天打开SQL Server 2008 的 SQL Server Management Studio，输入sa的密码发现，无法登陆数据库，提示信息如上：&lt;/p&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://easydecode.coding.me/categories/DataBase/"/>
    
      <category term="MSSQL" scheme="https://easydecode.coding.me/categories/DataBase/MSSQL/"/>
    
    
      <category term="DataBase" scheme="https://easydecode.coding.me/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>springMVC重定向+传参</title>
    <link href="https://easydecode.coding.me/2017/05/14/cfef625d.html"/>
    <id>https://easydecode.coding.me/2017/05/14/cfef625d.html</id>
    <published>2017-05-14T02:29:02.000Z</published>
    <updated>2018-08-25T00:12:37.941Z</updated>
    
    <content type="html"><![CDATA[<p>strtuts有两种跳转方式转发和重定向，那么springMVC的重定向应该如何定义呢？springMVC重定向有几种情况：不带参数跳转，带参数拼接url形式跳转，带参数不拼接参数跳转</p><h4 id="不带参重定向"><a href="#不带参重定向" class="headerlink" title="不带参重定向"></a>不带参重定向</h4><p>方式一：使用ModelAndView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/toList"</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>这样可以重定向到toList这个方法</p><pre><code>方式二：返回String</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/toList"</span>;</span><br></pre></td></tr></table></figure><h4 id="带参拼接url重定向"><a href="#带参拼接url重定向" class="headerlink" title="带参拼接url重定向"></a>带参拼接url重定向</h4><p>方式一：自己手动拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/toListparam1="</span>+value1+<span class="string">"&amp;&amp;param2="</span>+value2);</span><br></pre></td></tr></table></figure><p>这样有个弊端，就是传中文可能会有乱码问题</p><p>方式二：用RedirectAttributes，这个是发现的一个比较好用的一个类</p><p>这里用它的addAttribute方法，这个实际上重定向过去以后你看url，是它自动给你拼了你的url</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attr.addAttribute(<span class="string">"param"</span>, value);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/namespace/toController"</span>;</span><br></pre></td></tr></table></figure><p>这样在toController这个方法中就可以通过获得参数的方式获得这个参数，再传递到页面。过去的url还是和方式一一样的</p><h4 id="带参不拼接url重定向"><a href="#带参不拼接url重定向" class="headerlink" title="带参不拼接url重定向"></a>带参不拼接url重定向</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(@ModelAttribute(<span class="string">"form"</span>)</span> Bean form,RedirectAttributes attr)</span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">4String code =  service.save(form);</span><br><span class="line">4<span class="keyword">if</span>(code.equals(<span class="string">"000"</span>))&#123;</span><br><span class="line">44attr.addFlashAttribute(<span class="string">"name"</span>, form.getName());  </span><br><span class="line">44attr.addFlashAttribute(<span class="string">"success"</span>, <span class="string">"添加成功!"</span>);</span><br><span class="line">44<span class="keyword">return</span> <span class="string">"redirect:/index"</span>;</span><br><span class="line">4&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">44attr.addAttribute(<span class="string">"projectName"</span>, form.getProjectName());  </span><br><span class="line">44attr.addAttribute(<span class="string">"enviroment"</span>, form.getEnviroment());  </span><br><span class="line">44attr.addFlashAttribute(<span class="string">"msg"</span>, <span class="string">"添加出错!错误码为："</span>+rsp.getCode().getCode()+<span class="string">",错误为："</span>+rsp.getCode().getName());</span><br><span class="line">44<span class="keyword">return</span> <span class="string">"redirect:/maintenance/toAddConfigCenter"</span>;</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(@ModelAttribute(<span class="string">"form"</span>)</span> Bean form,RedirectAttributes attr)</span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">4<span class="keyword">return</span> <span class="string">"redirect:/main/list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;strtuts有两种跳转方式转发和重定向，那么springMVC的重定向应该如何定义呢？springMVC重定向有几种情况：不带参数跳转，带参数拼接url形式跳转，带参数不拼接参数跳转&lt;/p&gt;
&lt;h4 id=&quot;不带参重定向&quot;&gt;&lt;a href=&quot;#不带参重定向&quot; class=&quot;headerlink&quot; title=&quot;不带参重定向&quot;&gt;&lt;/a&gt;不带参重定向&lt;/h4&gt;&lt;p&gt;方式一：使用ModelAndView&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ModelAndView(&lt;span class=&quot;string&quot;&gt;&quot;redirect:/toList&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="java" scheme="https://easydecode.coding.me/tags/java/"/>
    
      <category term="springMVC" scheme="https://easydecode.coding.me/tags/springMVC/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate映射问题</title>
    <link href="https://easydecode.coding.me/2017/05/12/6512d67b.html"/>
    <id>https://easydecode.coding.me/2017/05/12/6512d67b.html</id>
    <published>2017-05-12T06:51:26.000Z</published>
    <updated>2018-08-29T07:42:55.771Z</updated>
    
    <content type="html"><![CDATA[<p>错误的关键部分：</p><blockquote><p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘articleDaoImpl’: Injection of resource methods failed;</p><p>nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined in class path resource [applicationContext.xml]: Invocation of init method failed;</p><p>nested exception is org.hibernate.AnnotationException: <span style="color: #0000ff;">mappedBy reference an unknown target entity property</span>: com.wangzhe.model.Keyword.Articles in com.wangzhe.model.Article.keywords</p></blockquote><a id="more"></a><p>错误原因：</p><p>在one-to-many注解配置： @OneToMany (mappedBy = “Articles”),mappedBy指向的是要关联的属性，而不是要关联的类，如果这样配置，hibernate则会找com.wangzhe.model.Keyword类下面的Articles 属性。但实际上没有这个属性，就会报上面的异常</p><p>解决方法：</p><p>指定到实际关联的属性：即：@OneToMany (mappedBy = “articles “)</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;错误的关键部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘articleDaoImpl’: Injection of resource methods failed;&lt;/p&gt;
&lt;p&gt;nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined in class path resource [applicationContext.xml]: Invocation of init method failed;&lt;/p&gt;
&lt;p&gt;nested exception is org.hibernate.AnnotationException: &lt;span style=&quot;color: #0000ff;&quot;&gt;mappedBy reference an unknown target entity property&lt;/span&gt;: com.wangzhe.model.Keyword.Articles in com.wangzhe.model.Article.keywords&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>每天十道Java面试题（三）</title>
    <link href="https://easydecode.coding.me/2017/05/11/8372df0e.html"/>
    <id>https://easydecode.coding.me/2017/05/11/8372df0e.html</id>
    <published>2017-05-11T03:04:31.000Z</published>
    <updated>2018-08-28T09:39:09.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、HashMap和Hashtable的区别"><a href="#一、HashMap和Hashtable的区别" class="headerlink" title="一、HashMap和Hashtable的区别"></a>一、HashMap和Hashtable的区别</h4><p>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。</p><p>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</p><p>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</p><p>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。</p><p>最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</p><p>Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</p><a id="more"></a><h4 id="二、GC是什么-为什么要有GC"><a href="#二、GC是什么-为什么要有GC" class="headerlink" title="二、GC是什么? 为什么要有GC?"></a>二、GC是什么? 为什么要有GC?</h4><p>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p><h4 id="三、应用服务器有那些？"><a href="#三、应用服务器有那些？" class="headerlink" title="三、应用服务器有那些？"></a>三、应用服务器有那些？</h4><p>BEA <span style="color: #0000ff;">WebLogic</span> Server，IBM <span style="color: #0000ff;">WebSphere</span> Application Server，<span style="color: #0000ff;">Oracle9i</span> Application Server，<span style="color: #0000ff;">jBoss</span>，<span style="color: #0000ff;">Tomcat</span></p><h4 id="四、说出数据连接池的工作机制是什么"><a href="#四、说出数据连接池的工作机制是什么" class="headerlink" title="四、说出数据连接池的工作机制是什么?"></a>四、说出数据连接池的工作机制是什么?</h4><p>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接标记为空闲，其他调用就可以使用这个连接。</p><h4 id="五、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"><a href="#五、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？" class="headerlink" title="五、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"></a>五、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">translate</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">4String tempStr = <span class="string">""</span>;</span><br><span class="line">4<span class="keyword">try</span> &#123;</span><br><span class="line">44tempStr = <span class="keyword">new</span> String(str.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">44tempStr = tempStr.trim();</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">44System.err.println(e.getMessage());</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="keyword">return</span> tempStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="六、什么是java序列化，如何实现java序列化？"><a href="#六、什么是java序列化，如何实现java序列化？" class="headerlink" title="六、什么是java序列化，如何实现java序列化？"></a>六、什么是java序列化，如何实现java序列化？</h4><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。</p><p>序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p><h4 id="七、BS与CS的联系与区别"><a href="#七、BS与CS的联系与区别" class="headerlink" title="七、BS与CS的联系与区别"></a>七、BS与CS的联系与区别</h4><p>C/S是Client/Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。</p><p>B/Ｓ是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。</p><p>C/S 与 B/S 区别：</p><p>１．硬件环境不同:</p><p>C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务.</p><p>B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行</p><p>２．对安全要求不同</p><p>C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息.</p><p>B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。</p><p>３．对程序架构不同</p><p>C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.</p><p>B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟.</p><p>４．软件重用不同</p><p>C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好.</p><p>B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子</p><p>５．系统维护不同</p><p>C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统</p><p>B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级.</p><p>６．处理问题不同</p><p>C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统</p><p>B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小.</p><p>７．用户接口不同</p><p>C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高</p><p>B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本.</p><p>８．信息流不同</p><p>C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低</p><p>B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心</p><h4 id="八、写一个函数要求输入一个字符串和一个字符长度，对该字符串进行分隔；-Core-Java"><a href="#八、写一个函数要求输入一个字符串和一个字符长度，对该字符串进行分隔；-Core-Java" class="headerlink" title="八、写一个函数要求输入一个字符串和一个字符长度，对该字符串进行分隔；(Core Java)"></a>八、写一个函数要求输入一个字符串和一个字符长度，对该字符串进行分隔；(Core Java)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String str, <span class="keyword">int</span> chars)&#123;</span><br><span class="line">4<span class="keyword">int</span> n = (str.length()+ chars - <span class="number">1</span>)/chars;</span><br><span class="line">4String ret[] = <span class="keyword">new</span> String[n];</span><br><span class="line">4<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;n; i++)&#123;</span><br><span class="line">44<span class="keyword">if</span>(i &amp;lt; n-<span class="number">1</span>)&#123;</span><br><span class="line">444ret[i] = str.substring(i*chars , (i+<span class="number">1</span>)*chars);</span><br><span class="line">44&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">444ret[i] = str.substring(i*chars);</span><br><span class="line">44&#125;</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="九、写一种常见排序；（算法）"><a href="#九、写一种常见排序；（算法）" class="headerlink" title="九、写一种常见排序；（算法）"></a>九、写一种常见排序；（算法）</h4><p>答：C++中冒泡排序：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span>&amp;amp; a, <span class="keyword">int</span>&amp;amp; b )</span></span>&#123;</span><br><span class="line">4<span class="keyword">int</span> c=a; a = b; b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble</span><span class="params">( <span class="keyword">int</span>* p, <span class="keyword">int</span> len )</span></span>&#123;</span><br><span class="line">4bool bSwapped;</span><br><span class="line">4<span class="keyword">do</span> &#123;</span><br><span class="line">44bSwapped = <span class="keyword">false</span>;</span><br><span class="line">44<span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&amp;lt;len; i++ )&#123;</span><br><span class="line">444<span class="keyword">if</span>( p[i-<span class="number">1</span>]&amp;gt;p[i] )&#123;</span><br><span class="line">4444swap( p[i-<span class="number">1</span>], p[i] );</span><br><span class="line">4444bSwapped = <span class="keyword">true</span>;</span><br><span class="line">444&#125;</span><br><span class="line">44&#125;</span><br><span class="line">4&#125;<span class="keyword">while</span>( bSwapped );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="十、写四个线程，两个对j加1，两个对j减1；-Core-Java"><a href="#十、写四个线程，两个对j加1，两个对j减1；-Core-Java" class="headerlink" title="十、写四个线程，两个对j加1，两个对j减1；(Core Java)"></a>十、写四个线程，两个对j加1，两个对j减1；(Core Java)</h4><p>答：代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">4<span class="keyword">int</span> j;</span><br><span class="line">4<span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">44<span class="keyword">this</span>.j = j;</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">44j++;</span><br><span class="line">44System.out.println(j + <span class="string">"--Inc--"</span> + Thread.currentThread().getName());</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line">44j--;</span><br><span class="line">44System.out.println(j + <span class="string">"--Dec--"</span> + Thread.currentThread().getName());</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">44(<span class="keyword">new</span> Dec()).start();</span><br><span class="line">44<span class="keyword">new</span> Thread(<span class="keyword">new</span> Inc()).start();</span><br><span class="line">44(<span class="keyword">new</span> Dec()).start();</span><br><span class="line">44<span class="keyword">new</span> Thread(<span class="keyword">new</span> Inc()).start();</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="class"><span class="keyword">class</span> <span class="title">Dec</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">44<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">444<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">4444dec();</span><br><span class="line">444&#125;</span><br><span class="line">44&#125;</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="class"><span class="keyword">class</span> <span class="title">Inc</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">44<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">444<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">4444inc();</span><br><span class="line">444&#125;</span><br><span class="line">44&#125;</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">44(<span class="keyword">new</span> TestThread(<span class="number">5</span>)).run();</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、HashMap和Hashtable的区别&quot;&gt;&lt;a href=&quot;#一、HashMap和Hashtable的区别&quot; class=&quot;headerlink&quot; title=&quot;一、HashMap和Hashtable的区别&quot;&gt;&lt;/a&gt;一、HashMap和Hashtable的区别&lt;/h4&gt;&lt;p&gt;HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。&lt;/p&gt;
&lt;p&gt;HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。&lt;/p&gt;
&lt;p&gt;HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。&lt;/p&gt;
&lt;p&gt;Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。&lt;/p&gt;
&lt;p&gt;最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。&lt;/p&gt;
&lt;p&gt;Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://easydecode.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://easydecode.coding.me/tags/Java/"/>
    
  </entry>
  
</feed>
