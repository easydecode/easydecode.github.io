<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Centos7安装并配置nginx]]></title>
    <url>%2F2018%2F06%2F01%2F4aabff58.html</url>
    <content type="text"><![CDATA[nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现。本篇文章主要介绍了Linux下源码编译安装的同时并对nginx进行优化配置在Centos下，yum源不提供nginx的安装，可以通过切换yum源的方法获取安装。也可以直接下载源码进行编译安装 nginx安装检查是否已经安装nginx：find / -name nginx（如果执行后无任何返回信息代表没有，反之则或许安装过） 安装相关依赖：首先安装必要的库（nginx 中gzip模块需要 zlib 库，rewrite模块需要 pcre 库，ssl 功能需要openssl库）1yum -y install wget gcc gcc-c++ autoconf automake pcre pcre-devel zlib zlib-devel openssl openssl-devel 创建用户组www,创建用户www 所属组 www 并设置不能登录：1groupadd www &amp;&amp; useradd -s /sbin/nologin -g www -M www 将nginx源码下载到/usr/local/src并解压：1cd /usr/local/src &amp;&amp; wget http://nginx.org/download/nginx-1.14.0.tar.gz &amp;&amp; tar zxvf nginx-1.14.0.tar.gz 创建相关文件夹1234567mkdir -p /home/nginxmkdir -p /var/run/nginx/mkdir -p /var/lock/mkdir -p /var/log/nginx/mkdir -p /var/temp/nginx/clientmkdir -p /var/temp/nginx/proxymkdir -p /var/temp/nginx/fastcgi 进入nginx文件夹并配置编译参数：1234567891011121314151617cd nginx-1.14.0./configure --user=www\--group=www \--prefix=/home/nginx \--with-stream \--with-http_stub_status_module \--with-http_ssl_module \--with-http_gzip_static_module \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi 编译参数解释：#指定运行权限的用户–user=www#指定运行的权限用户组–group=www#指定安装路径–prefix=/usr/local/nginx#支持nginx状态查询–with-http_stub_status_module#开启ssl支持–with-http_ssl_module#开启GZIP功能–with-http_gzip_static_module 编译并安装1make &amp;&amp; make install 权限控制将/home/nginx目录设置为www:www用户组，同时将权限设置为75512chown -R www:www /home/nginxchmod -R 755 /home/nginx Nginx基本配置安装成功后，进入安装目录，备份原配置，修改nginx.conf123cd /home/nginx/conf/cp nginx.conf nginx.conf.bakvim nginx.conf 修改前 修改后 配置说明user www www指定nginx进程运行用户以及用户组error_log logs/error.log;debug输出日志最为详细，而crit输出日志最少当前目录下的logs目录是linux下的日志存放目录 修改完成后还需要创建logs文件夹否则会报错：mkdir -p /home/nginx/logs 启动nginx测试是否成功：启动：/home/nginx/sbin/nginx停止：/home/nginx/sbin/nginx -s stop重载：/home/nginx/sbin/nginx -s reload 执行后访问服务器地址查看 nginx优化页面直接传输过于占用带宽，对页面进行gzip压缩，然后传到用户那里，再解压，这样可以有效的减少带宽 文件位置：/home/nginx/conf/nginx.conf1234567891011121314151617181920212223242526272829303132333435363738http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; charset utf-8; #设置编码为utf-8 #开启gzip+ gzip on; #允许压缩的最小字节数+ gzip_min_length 1k; #4个单位为16k的内存作为压缩结果流缓存+ gzip_buffers 4 16k; #设置识别HTTP协议版本，默认是1.1+ gzip_http_version 1.1; #gzip压缩比，可在1~9中设置，1压缩比最小，速度最快，9压缩比最大，速度最慢，消耗CPU+ gzip_comp_level 2; #压缩的类型+ gzip_types text/plain application/x-javascript text/css application/xml; #让前端的缓存服务器混村经过的gzip压缩的页面+ gzip_vary on; Nginx负载均衡配置编辑nginx.conf文件在server节点的上面添加12345upstream tomcat_server&#123; ip_hash; server 127.0.0.1:8080; server 127.0.0.1:8090;&#125; 例如：1234567891011121314+ upstream tomcat_server &#123;+ ip_hash;+ server 127.0.0.1:8080 weight=1;+ server 127.0.0.1:8090 weight=1;+ &#125; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; ... server后面的IP跟端口需要根据具体情况进行调整ip_hash：每个请求按照ip的hash结果分配，同一个ip的访客固定访问一个后端服务器，可解决动态网页session共享问题。 将location节点修改为如下：1234567location / &#123; proxy_next_upstream http_502 http_504 error timeout invalid_header; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://tomcat_server;&#125; 配置说明 proxy_next_upstream http_502 http_504 error timeout invalid_header;当502或504时，将请求转发到负载均衡中正常server中 proxy_set_header Host $host;这一句必须有，否则代理不了 proxy_pass http://tomcat_server;将请求交给反向代理服务器处理 Nginx动静分离配置将nginx.conf文件的server节点里面添加如下配置：12345#配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取location ~ .*\.(js|css|png|jpg)$ &#123;root html/static; expires 3d;&#125; expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力 常见问题解决nginx 反向代理websocket问题官方文档说 Nginx 在 1.3 以后的版本才支持 websocket 反向代理，所以要想使用支持 websocket 的功能，必须升级到 1.3 以后的版本 NGINX通过允许一个在客户端和后端服务器之间建立的隧道来支持WebSocket。为了NGINX发送来至于客户端Upgrade请求到后端服务器，Upgrade和Connection头部必须被设置明确 示例：1234567891011121314upstream wsbackend &#123; server 127.0.0.1:8080; server 127.0.0.1:8081;&#125;server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://wsbackend; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; &#125;&#125; 6、 完整nginx配置文件：点击下载]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中ContextLoaderListener和DispatcherServlet所加载的context的关系]]></title>
    <url>%2F2018%2F03%2F11%2Ff7940b2b.html</url>
    <content type="text"><![CDATA[区别 ContextLoaderListener加载的applicationContext是web应用全局的上下文，而DispatcherServlet加载的applicationContext是spring MVC的上下文 ContextLoaderListener所加载的context被spring通过servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context)存放到ServletContext的attribute中。该上下文可通过WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext)或WebApplicationContextUtils.getWebApplicationContext(servletContext)方法来获取。 DispatcherServlet加载context完成后，如果publishContext属性的值设置为true的话(缺省为true) 会将context存放在ServletContext的key为org.springframework.web.servlet.FrameworkServlet.CONTEXT. + (servletName)的attribute中。 web.xml12345678&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; DispatcherServlet所加载的applicationContext可以认为是mvc私有的context，由于保存在servletContext中的key值与通过ContextLoaderListener加载进来的applicationContext使用的key值不相同，因此如果只使用DispatcherServlet加载context的话，如果程序中有地方使用WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext) 来试图获取applicationContext时，就会抛出”No WebApplicationContext found: no ContextLoaderListener registered?”的exception。 关联 Spring的ContextLoaderListener所创建出来的context和Spring MVC DispatcherServlet所创建出来的context是父子关系，FrameworkServlet在实例化对应的applicationContext后通过setParent将从ServletContext中获取到的ContextLoaderListener创建的applicaitonContext设置成父上下文，然后加载在对应的xml配置文件对其初始化。 father WebApplicationContext里的bean可以被注入到child WebApplicationContext里的bean，而child WebApplicationContext的bean则不能被注入到parent WebApplicationContext里的bean。所以在使用Spring MVC时启用自动检测功能，应在applicationContext.xml里只component-scan非Controller的类，而在Spring MVC里只component-scan Controller类 applicationContext.xml1234&lt;context:component-scan base-package="com.test"&gt; &lt;context:exclude-filter expression="org.springframework.stereotype.Controller" type="annotation" /&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice" /&gt;&lt;/context:component-scan&gt; dispatcher-servlet.xml12345&lt;context:component-scan base-package="com.test.web" use-default-filters="false"&gt; &lt;context:include-filter expression="org.springframework.stereotype.Controller" type="annotation" /&gt; &lt;context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice" /&gt;&lt;/context:component-scan&gt; 如果不这么分开扫描的话，那么父容器和子容器中都会有相对应的bean实例。他们因为不在同一个容器中，所以虽然他们bean的id相同也不报错，但这无疑会加应用的负担。同时会造成难以发现的问题。比如我遇到的一个问题： 将一个ApplicationListener实现加上@Component注解，在applicationContext.xml和dispatcherServlet.xml中配置了相同的扫描方案。在触发监听事件的时候调用两次onApplicationEvent方法。这是因为在Spring的上下文和Spring MVC的上下文有两个相同名称的bean，在调用完子类中的监听器后Spring回去查看父容器中是否也有监听器在监听对应的事件。如果有则调用监听器方法 注意虽然这两个context上下文是一对父子关系，但它们加载的bean不是合并存储的，所以个人建议，基于mvc相关的spring配置由DispatcherServlet加载，而其余的JavaBean都交给ContextLoaderListener加载]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union和Union All的区别]]></title>
    <url>%2F2018%2F01%2F22%2F6bd305d7.html</url>
    <content type="text"><![CDATA[Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 假设我们有一个表Student，包括以下字段与数据： mysql123456789101112131415161718192021drop table student; create table student ( id int primary key, name nvarchar2(50) not null, score number not null ); insert into student values(1,'Aaron',78); insert into student values(2,'Bill',76); insert into student values(3,'Cindy',89); insert into student values(4,'Damon',90); insert into student values(5,'Ella',73); insert into student values(6,'Frado',61); insert into student values(7,'Gill',99); insert into student values(8,'Hellen',56); insert into student values(9,'Ivan',93); insert into student values(10,'Jay',90); commit; 首先，我们来看一下UNION的例子： mysql123456789101112131415161718SQL&gt; select * 2 from student 3 where id&amp;lt;4 4 union 5 select * 6 from student 7 where id&amp;gt;2 and id&amp;lt;6 8 ; ID NAME SCORE ---------- ------------------------------ ---------- 1 Aaron 78 2 Bill 76 3 Cindy 89 4 Damon 90 5 Ella 73 SQL&gt; 如果换成Union All连接两个结果集，则结果如下： mysql12345678910111213141516171819SQL&gt; select * 2 from student 3 where id&amp;lt;4 4 union all 5 select * 6 from student 7 where id&amp;gt;2 and id&amp;lt;6 8 ; ID NAME SCORE ---------- ------------------------------ ---------- 1 Aaron 78 2 Bill 76 3 Cindy 89 3 Cindy 89 4 Damon 90 5 Ella 73 6 rows selected. 可以看到，Union和Union All的区别之一在于对重复结果的处理。 接下来，我们交换一个两个SELECT语句的顺序，看看结果是怎样的。 mysql123456789101112131415161718192021222324252627282930313233343536SQL&gt; select * 2 from student 3 where id&gt;2 and id&lt;6 4 union 5 select * 6 from student 7 where id&gt;4 8 ; ID NAME SCORE ---------- ------------------------------ ---------- 1 Aaron 78 2 Bill 76 3 Cindy 89 4 Damon 90 5 Ella 73 SQL&gt; select * 2 from student 3 where id&gt;2 and id&lt;6 4 union all 5 select * 6 from student 7 where id&gt;4 8 ; ID NAME SCORE ---------- ------------------------------ ---------- 3 Cindy 89 4 Damon 90 5 Ella 73 1 Aaron 78 2 Bill 76 3 Cindy 89 6 rows selected. 可以看到，对于UNION来说，交换两个SELECT语句的顺序后结果仍然是一样的，这是因为UNION会自动排序。而UNION ALL在交换了SELECT语句的顺序后结果则不相同，因为UNION ALL不会对结果自动进行排序。 那么这个自动排序的规则是什么呢？我们交换一下SELECT后面选择字段的顺序（前面使用SELECT * 相当于SELECT ID,NAME,SCORE），看看结果如何： mysql12345678910111213141516SQL&gt; select score,id,name 2 from student 3 where id&lt;4 4 union 5 select score,id,name 6 from student 7 where id&gt;2 and id&lt;6 8 ; SCORE ID NAME ---------- ---------- ------------------------------ 73 5 Ella 76 2 Bill 78 1 Aaron 89 3 Cindy 90 4 Damon 可以看到，此时是按照字段SCORE来对结果进行排序的（前面SELECT * 的时候是按照ID进行排序的）。 那么有人会问，如果我想自行控制排序，能不能使用ORDER BY呢？当然可以。不过在写法上有需要注意的地方： mysql12345678910111213141516select score,id,name from student where id &gt; 2 and id &lt; 7 union select score,id,name from student where id &lt; 4 union select score,id,name from student where id &gt; 8 order by id desc order by子句必须写在最后一个结果集里，并且其排序规则将改变操作后的排序结果。对于Union、Union All、Intersect、Minus都有效。 其他的集合操作符，如Intersect和Minus的操作和Union基本一致，这里一起总结一下： Union，对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序； Union All，对两个结果集进行并集操作，包括重复行，不进行排序； Intersect，对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序； Minus，对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。 可以在最后一个结果集中指定Order by子句改变排序方式。]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 Streams API：对Stream分组和分区]]></title>
    <url>%2F2017%2F12%2F13%2F8d4c56cb.html</url>
    <content type="text"><![CDATA[这篇文章展示了如何使用 Streams API 中的 Collector 及 groupingBy 和 partitioningBy 来对流中的元素进行分组和分区。思考一下 Employee 对象流，每个对象对应一个名字、城市和销售数量，如下表所示： +----------+------------+-----------------+ | Name | City | Number of Sales | +----------+------------+-----------------+ | Alice | London | 200 | | Bob | London | 150 | | Charles | New York | 160 | | Dorothy | Hong Kong | 190 | +----------+------------+-----------------+ 分组首先，我们利用（lambda表达式出现之前的）命令式风格Java 程序对流中的雇员按城市进行分组： java12345678910Map&lt;String, List&lt;Employee&gt;&gt; result = new HashMap&lt;&gt;();for (Employee e : employees) &#123; String city = e.getCity(); List&lt;Employee&gt; empsInCity = result.get(city); if (empsInCity == null) &#123; empsInCity = new ArrayList&lt;&gt;(); result.put(city, empsInCity); &#125; empsInCity.add(e);&#125; 你可能很熟悉写这样的代码，你也看到了，一个如此简单的任务就需要这么多代码！ 而在 Java 8 中，你可以使用 groupingBy 收集器，一条语句就能完成相同的功能，像这样： java1Map&lt;String, List&lt;Employee&gt;&gt; employeesByCity = employees.stream().collect(groupingBy(Employee::getCity)); 结果如下面的 map 所示： {New York=[Charles], Hong Kong=[Dorothy], London=[Alice, Bob]} 还可以计算每个城市中雇员的数量，只需传递一个计数收集器给 groupingBy 收集器。第二个收集器的作用是在流分类的同一个组中对每个元素进行递归操作。 java1Map&lt;String, Long&gt;; numEmployeesByCity = employees.stream().collect(groupingBy(Employee::getCity, counting())); 结果如下面的 map 所示： {New York=1, Hong Kong=1, London=2} 顺便提一下，该功能与下面的 SQL 语句是等同的： mysql1select city, count(*) from Employee group by city 另一个例子是计算每个城市的平均年龄，这可以联合使用 averagingInt 和 groupingBy 收集器： java1Map&lt;String, Double&gt; avgSalesByCity = employees.stream().collect(groupingBy(Employee::getCity,averagingInt(Employee::getNumSales))); 结果如下 map 所示： {New York=160.0, Hong Kong=190.0, London=175.0} 分区分区是一种特殊的分组，结果 map 至少包含两个不同的分组——一个true，一个false。例如，如果想找出最优秀的员工，你可以将所有雇员分为两组，一组销售量大于 N，另一组小于 N，使用 partitioningBy 收集器： 1Map&lt;Boolean, List&lt;Employee&gt;&gt; partitioned = employees.stream().collect(partitioningBy(e -&gt; e.getNumSales() &gt; 150)); 输出如下结果： {false=[Bob], true=[Alice, Charles, Dorothy]} 你也可以将 groupingBy 收集器传递给 partitioningBy 收集器来将联合使用分区和分组。例如，你可以统计每个分区中的每个城市的雇员人数： 1Map&lt;Boolean, Map&lt;String, Long&gt;&gt; result = employees.stream().collect(partitioningBy(e -&gt; e.getNumSales() &gt; 150,groupingBy(Employee::getCity, counting()))); 这样会生成一个二级 Map: {false={London=1}, true={New York=1, Hong Kong=1, London=1}} 原文链接： javacodegeeks 翻译： ImportNew.com - paddx 译文链接： http://www.importnew.com/17313.html [ 转载请保留原文出处、译者和译文链接。]]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux（CentOS）上安装openoffice+SWFTools]]></title>
    <url>%2F2017%2F08%2F27%2Ff5307712.html</url>
    <content type="text"><![CDATA[openoffice是Apache下的一个开放免费的文字处理软件，可以将word、excel、ppt、txt等文件转换为pdf文件。SWFTools是一组用来处理Flash的swf文件的工具包，我们使用它将pdf文件转成swf文！FlexPaper是一个开源轻量级的在浏览器上显示各种文档的组件这篇文章教大家如何在Linux（CentOS）上安装实现在线文档预览的两大软件openoffice + SWFTools，首先说明openoffice需要jdk支持，请先安装jdk。 一、openoffice安装1、在官网http://www.openoffice.org/download/index.html下载最新的Apache OpenOffice 4.1.3 2、解压压缩包： 1tar Apache_OpenOffice_4.1.3_Linux_x86-64_install-rpm_zh-CN.tar.gz 解压后的目录是zh-CN，里面有RPMS、readmes、licenses 3、进入zh-CN/RPMS目录下，执行 1yum localinstall *.rpm 4、再进入到zh-CN/RPMS/desktop-integration目录下安装openoffice4.1.3-redhat-menus-4.1.3-9783.noarch.rpm 1yum localinstall openoffice4.1.3-redhat-menus-4.1.3-9783.noarch.rpm 5、启动 临时启动（如果连接断开，服务也就停止了，Ctrl+C也会停止）： 1/opt/openoffice4/program/soffice -headless -accept="socket,host=127.0.0.1,port=8100;urp;" -nofirststartwizard 后台运行（服务会一直运行在后台）： 1nohup /opt/openoffice4/program/soffice -headless -accept="socket,host=127.0.0.1,port=8100;urp;" -nofirststartwizard &amp; 或者 1/opt/openoffice4/program/soffice -headless -accept="socket,host=127.0.0.1,port=8100;urp;" -nofirststartwizard &amp; &gt;/dev/null 2&gt;&amp;1 6、查看服务是否启动 1netstat -lnp | grep 8100 如果出现类似如下信息，则说明已经成功启动 tcp 0 0 127.0.0.1:8100 0.0.0.0:* LISTEN 19501/soffice.bin 二、swftools安装bash12345678910111213141516171819#安装依赖yum install giflib-devel libjpeg-devel freetype-devel t1lib-devel#下载swftoolswget http://www.swftools.org/swftools-0.9.1.tar.gz#解压swftoolstar vxzf swftools-0.9.1.tar.gzcd swftools-0.9.1#配置./configure –prefix=/usr/local/swftools#编译make#安装make install 上面的命令一步一步执行完即可完成安装，安装完成后需要将swftools添加至PATH变量 1echo "export PATH=\$PATH:/usr/local/swftools/bin/" /etc/profile 执行下source /etc/profile 使环境变量生效]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十步完成Linux（CentOS）下安装oracle 12c（上篇）]]></title>
    <url>%2F2017%2F08%2F07%2Ffc662c52.html</url>
    <content type="text"><![CDATA[这篇文章主要介绍CentOS下安装oracle 12c的方法(图形化安装+命令行安装），博主亲自搭建了一遍，需要安装的朋友可以参考下面的步骤一步步进行。安装oracle12C官方要求物理内存和虚拟内存（swap）都不能低于2G，如果还没有为CentOS设置虚拟内存的，可以参考这篇文章：http://blog.easydcode.com/1050.html 一、关闭无用服务1、关闭防火墙 如果系统是centos6，执行 service iptables stop 如果系统是centos7，执行 systemctl stop firewalld.service systemctl stop iptables.service 2、禁用SELINUX sed -i ‘s/SELINUX=enforcing/SELINUX=disabled/‘ /etc/selinux/config 二、安装oracle所需依赖 yum install binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc glibc-devel ksh libgcc libstdc++ libstdc++-devel libaio libaio-devel libXext libXtst libX11 libXau libxcb libXi make sysstat 安装调用图形化需要的包，下面会用到 yum -y install unixODBC unixODBC-devel xterm xterm是调用图形化用的包 三、添加相关用户及目录添加安装oracle所需的用户组，以及为oracle用户设置密码（123456） groupadd oinstall groupadd oper groupadd dba useradd -g oinstall -G dba,oper oracle echo “123456” | passwd –stdin oracle 创建oracle安装目录 mkdir -p /usr/local/oracle/product/12.1.0/dbhome_1 mkdir -p /usr/local/oracle/oradata mkdir -p /usr/local/oracle/flash_recovery_area mkdir -p /usr/local/oracle/archlog chown -R oracle:oinstall /usr/local/oracle 四、配置内核参数执行下面的命令 echo -e “fs.aio-max-nr = 1048576\nfs.file-max = 6815744\nkernel.shmall = 2097152\nkernel.shmmax = 4098955264\nkernel.shmmni = 4096\nkernel.sem = 250 32000 100 128\nnet.ipv4.ip_local_port_range = 9000 65500\nnet.core.rmem_default = 262144\nnet.core.rmem_max = 4194304\nnet.core.wmem_default = 262144\nnet.core.wmem_max = 1048586” &gt;&gt;/etc/sysctl.conf 执行上面的命令完成后，执行如下命令使修改生效 sysctl -p &nbsp; 执行下面的命令修改系统限制 echo -e “oracle soft nofile 1024\noracle hard nofile 65536\noracle soft nproc 2048\noracle hard nproc 16384\noracle stack nproc 10240” &gt;&gt;/etc/security/limits.conf 设置PAM，确保加载了最新版本的 PAM echo -e “session required /lib/security/pam_limits.so\nsession required pam_limits.so” &gt;&gt;/etc/pam.d/login 验证当前 ulimit，如果需要则增大 echo -e “if [ $USER = “oracle” ]; then\nif [ $SHELL = “/bin/ksh” ]; then\nulimit -p 16384\nulimit -n 65536a\nelseulimit -u 16384 -n 65536\nfi\nfi” &gt;&gt;/etc/profile 五、修改操作系统发行版本由于 oracle 还没有推出支持 CentOS 的安装包，所以需要修改发行版本 vi /etc/redhat-release 把CentOS release 6.5 (Final) 注释掉，前面加上一行redhat-6，当oracle安装完成后,可以再修改回来。 六、修改/etc/hosts vi /etc/hosts 把127.0.0.1那一行改为：127.0.0.1 localhost 七、配置环境变量此处博主将oracle环境变量添加为全局变量，如果你只需要oracle用户才能操作，则执行vi /home/oracle/.bash_profile echo -e “\n#set oracle environment\nORACLE_BASE=/usr/local/oracle\nORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1\nORACLE_SID=orcl\nexport ORACLE_BASE ORACLE_HOME ORACLE_SID\nPATH=$ORACLE_HOME/bin:$PATH\nexport PATH” &gt;&gt;/etc/profile 注意：如果你的ORACLE_BASE和我不同，里面的内容可以根据实际情况进行改动，如可以改动ORACLE_SID和ORACLE_BASE，修改完后用：source /etc/profile（source /home/oracle/.bash_profile）使修改生效。 九、下载Oracle安装包并解压1、前往Oracle官网下载Linux版本的Oracle安装包，最新的Linux安装包将两个压缩包合并为一个了 下载地址：http://www.oracle.com/technetwork/database/enterprise-edition/downloads/oracle12c-linux-12201-3608234.html 2、解压oracle安装包到任意目录，博主就在/root目录下解压 unzip linuxx64_12201_database.zip /root 若提示：bash：unzip：command not found 则可执行如下命令安装压缩/解压缩工具 yum install -y unzip zip 十、安装Oracle远程调用图形安装oracle软件，此处使用的X-manager软件 详情请见下篇：]]></content>
      <categories>
        <category>CentOS</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常汇总（一）]]></title>
    <url>%2F2017%2F08%2F01%2F6efc2b5a.html</url>
    <content type="text"><![CDATA[Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 问题一、Tomcat7中文Cookie问题主要报错信息： java.lang.IllegalArgumentException: Control character in cookie value or attribute. 问题描述及解决办法： tomcat7中cookie写入中文引发Control character in cookie value or attribute异常，本地测试通过的程序，部署到测试环境遇到一个问题，如果登陆名称为中文时将引发如上所示的异常，而英文字母或者数字的登陆名称则是正常的，该报错是由于中文的编码的问题，中文采用的是unicode编码，而英文采用的是ASCII编码，所以当COOkie保存中文的时候需要对中文进行编码，而且从Cookie中取出内容的时候也要进行解码，编码和解码可以使用 在保存cookie之前把值编码下： 1URLEncoder.encode(cookieValue, "UTF-8"); 取cookie值时解码： 1URLDecoder.decode(localCookieValue, "UTF-8"); 问题二、Struts2 json插件问题主要报错信息： Caused by: There is no result type defined for type ‘json’ mapped with name ‘ajaxerror’. Did you mean ‘json’? 这个错误是在使用Struts2过程中很容易遇到的 解决步骤： 1、首先查看Jar有没有少 commons-beanutils-1.7.0.jar commons-collections-3.2.jar commons-lang-2.3.jar commons-logging-1.1.jar ezmorph-1.0.4.jar json-lib-2.2.3-jdk15.jar jsonplugin-0.33.jar 注意：struts2-json-plugin-2.2.1.1.jar 和 jsonplugin-0.33.jar会冲突不能同时存在 2、看Struts配置文件的继承部分对不对，json-default是必须的 问题三、内存泄露主要报错信息： The background cache eviction process was unable to free [10] percent of the cache for Context [/qishiMusic] - consider increasing the maximum size of the cache. After eviction approximately [9,741] KB of data remained in the cache. 解决：检查是否有资源没有关闭，可以在底层关闭资源的方法中调试例如 12345if(this.rs != null)&#123;4this.rs.close();4System.out.println("ResultSet已关闭");4this.rs = null;&#125; 问题四、Failed to start component主要报错信息： java.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/test]] 原因及解决方法： @WebServlet(“TestServlet”)缺少”/“ 应写成：@WebServlet(“/TestServlet”)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS配置静态ip]]></title>
    <url>%2F2017%2F07%2F26%2Fcbf4ff77.html</url>
    <content type="text"><![CDATA[CentOS 是一个基于Red Hat Linux（收费） 提供的可自由使用源代码的企业级Linux发行版本。而且在RHEL的基础上修正了不少已知的 Bug ，相对于其他 Linux 发行版，其稳定性值得信赖。更重要的是免费的，所以，它受到了很多企业的青睐！很多时候，Centos系统都是使用命令来管理的，如果当时安装系统时没有设置IP地址的话，那就只能在命令行设置了。下面简单说说配置静态ip的操作。 首先登陆root帐户，用命令ifconfig查看一下IP配置 只有一个本地回环地址，网卡并没有启用，接下来我们就开始网络配置 命令： 1vi /etc/sysconfig/network-scripts/ifcfg-eht0 在这里的eth0，指的第一块网卡，如果你的电脑/服务器有多个网卡，注意区分 输入如上命令后按键盘上 i 键即可进入编辑模式 1234567DEVICE=eth0 HWADDR=00:0C:29:C1:48:03 TYPE=Ethernet UUID=b2bbb718-caa6-46c3-ae12-587cbedfd5fa ONBOOT=no NM_CONTROLLED=yes BOOTPROTO=dhcp 上面的是默认配置，下面我们将ip修改为静态 12345678910DEVICE=eth0 HWADDR=00:0C:29:C1:48:03 TYPE=Ethernet UUID=b2bbb718-caa6-46c3-ae12-587cbedfd5fa ONBOOT=yesNM_CONTROLLED=yes BOOTPROTO=staticIPADDR=192.168.233.128GATEWAY=192.168.233.2NETMASK=255.255.255.0 IPADDR要配置为跟你路由器在同一个网段，如果是用VMware装的虚拟机，那么一般vmnet8就相当于一个路由器，要配置为跟他在同一网段，IPADDR，GATEWAY，NETMASK这三个是设置静态ip一定要配置的 配置信息修改后按ESC退出编辑状态，然后输入 :wq 保存并退出 如果你是第一次将ONBOOT=no改为ONBOOT=yes，那么输入reboot重启机器即可 如果你之前已经将修改ONBOOT修改为yes，但是没配置静态ip，那么输入如下指令重启网卡即可 1/etc/rc.d/init.d/network restart 或者 1service network restart 如果出现connect: Network is unreachable（connect: 网络不可达），请检查GATEWAY（网关）是否配置正确。]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle中导入导出dmp数据库文件]]></title>
    <url>%2F2017%2F07%2F06%2F25287513.html</url>
    <content type="text"><![CDATA[Oracle数据导入导出imp/exp就相当于oracle数据还原与备份。exp命令可以把数据从远程数据库服务器导出到本地的dmp文件，imp命令可以把dmp文件从本地导入到远处的数据库服务器中。 利用这个功能可以构建两个相同的数据库，一个用来测试，一个用来正式使用。 执行环境：可以在SQLPLUS.EXE或者DOS（命令行）中执行， DOS中可以执行是因为在%ORACLE_HOME%/BIN目录下有EXP.EXE与IMP.EXE文件被用来执行导入导出。 oracle用java编写，SQLPLUS.EXE、EXP.EXE、IMP.EXE这几个文件有可能是被包装后的类文件。 SQLPLUS.EXE调用EXP.EXE、IMP.EXE所包裹的类，完成导入导出功能。 下面介绍的是导入导出的不同场景的实例。 数据导出1、将数据库TEST完全导出,用户名system 密码manager 导出到D:\daochu.dmp中 1exp system/manager@TEST file=d:\test.dmp full=y 2、将数据库中system用户与sys用户的表导出 1exp system/manager@TEST file=d:\test.dmp owner=(system,sys) 3、将数据库中的inner_notify、notify_staff_relat表导出 1exp testuser/123456@TESTDB2 file= d:\data\TESTDB2.dmp tables=(inner_notify,notify_staff_relat) 4、将数据库中的表table1中的字段filed1以”00”打头的数据导出 1exp system/manager@TEST file=d:\test.dmp tables=(table1) query=\&quot;where filed1 like &apos;00%&apos;\&quot; 上面是常用的导出，如果相对导出的dmp文件进行压缩，可以在上面命令后面加上 compress=y 来实现。 例如： 1exp system/manager@TEST file=d:\test.dmp full=y compress=y 数据导入1、将D:\test.dmp 中的数据导入ORCL数据库中。 1imp system/manager@ORCL file=d:\test.dmp 上面的语句可能会出现问题，如果有一些表已经存在，它就会报错，对该表就不进行导入，解决：在后面加上 ignore=y 或者 table_exists_action=replace （具体使用哪个请根据oracle数据库版本而定，在oracle 10以后引入了数据泵技术impdp，可以在导入时使用table_exists_action=replace参数）就可以了。 123imp system/manager@ORCL full=y file= d:\test.dmp ignore=yimpdp system/manager@ORCL directory=Dir dumpfile= d:\test.dmp full=y table_exists_action=replace 2、将d:\test.dmp中的表table1导入 1imp system/manager@ORCL file=d:\test.dmp tables=(table1) 基本上上面的导入导出够用了。不少情况要先是将表彻底删除，然后导入。 操作时注意以下几点： 1、操作者要有足够的权限，权限不够它会提示。 给用户授权 1234567--用sys用户登录sqlplus sys/123456 as sysdba--授予testuser用户dba权限，dba权限过高，请谨慎操作grant dba to testuser 2、数据库是可以连上的。可以用tnsping TEST 来获得数据库TEST能否连上。 exp/imp和expdp/impdp的区别Oracle10g提出的数据泵技术，在以下几个方面优于exp/imp命令： 1、数据泵工具运行于服务器端，相比客户端的exp/imp其性能更好，并能实现exp/imp的全部功能。 2、通过使用exclude,include,content等参数，数据泵可以为数据及数据对象提供更细微级别的选择性。 3、通过设定数据库版本号，数据泵可以兼容老版本的数据库系统。 4、并行执行。 5、通过estimate_only参数，数据泵可以预估导出作业所需的磁盘空间。 6、支持分布式环境中通过数据库连接实现导入\导出。 7、支持导入时重新映射功能（即将对象导入到新的目标数据文件、架构及表空间等）。 8、支持元数据压缩及数据采样。 实际对比： 1、把用户usera的对象导入到userb emp/imp用法：formuser=usera touser=userb empdp/impdp用法：remap_schema=’usera’:’userb’ 例如： 123imp system/password fromuser=usera touser=userb file=back.dmp log=backlog.log;impdp system/password directory=expdp dumpfile=back.dmp remap_schema=&apos;usera&apos;:&apos;userb&apos; logfile=backlog.log 2、更改表空间 用exp/imp，想要更改表空间，需要手动处理， 而impdp只要用：remap_tablespace=’tablespace_old’ : ‘tablespace_new’ 3、当制定多个表的时候 exp/imp用法：tables(‘table1’,’table2’,’table3’) expdp/impdp用法：tables=’table1’,’table2’,’table3’ 4、是否要导出数据行 exp：rows=y,导出数据行，rows=n不导出数据行 expdp：content(all:对象+数据行，data_only：只导出对象，metadata_only：只导出数据的记录） 常见问题问题描述 ORA-39001: 参数值无效 ORA-39000: 转储文件说明错误 ORA-39143: 转储文件 “.dmp” 可能是原始的导出转储文件 原因及解决 .dmp文件是使用exp命令导出的，而使用impdp 无法识别exp命令导出的文件，需要使用imp命令进行导入]]></content>
      <categories>
        <category>Oracle</category>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序员常犯的10个错误]]></title>
    <url>%2F2017%2F07%2F03%2Ff3cb340d.html</url>
    <content type="text"><![CDATA[人非圣贤，孰能无过。都说Java语言是一门简单的编程语言，基于C++演化而来，剔除了很多C++中的复杂特性，但这并不能保证Java程序员不会犯错。那么对于广大的Java程序员来说，它们最常犯的10个错误是什么呢？本文通过总结出Java程序员最常犯的10大错误，可以有效地帮组Java后来者少走弯路，少加班，并写出更健壮的应用程序。 一、数组转ArrayList为了实现把一个数组转换成一个ArrayList，很多Java程序员会使用如下的代码： 1List&lt;String&gt; list = Arrays.asList(arr); Arrays.asList确实会返回一个 ArrayList对象，但是该类是 Arrays类 中一个私有静态内部类，而不是常见的 java.util.ArrayList类。这个 java.util.Arrays.ArrayList 类具有 set()，get()，contains()等方法，但是不具有任何添加或移除元素的任何方法。因为该类的大小(size)是固定的。为了创建出一个真正的 java.util.ArrayList,代码应该如下所示： 1ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arr)); 我们知道，ArrayList的构造方法可以接受一个 Collection 类型的对象，而我们的 java.util.Arrays.ArrayList 正好也是它的一个子类。实际上，更加高效的代码示例是： 12ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(arr.length);Collections.addAll(arrayList, arr); 二、数组是否包含特定值为了检查数组中是否包含某个特定值，很多Java程序员会使用如下的代码： 12Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(arr));return set.contains(targetValue); 就功能而言，该代码是正确无误的，但在数组转List,List再转Set的过程中消耗了大量的性能。我们可以优化成如下形式： 1Arrays.asList(arr).contains(targetValue); 或者，进一步优化成如下所示最高效的代码： 12345for(String s: arr)&#123;4if(s.equals(targetValue))4return true;&#125;return false; 三、在迭代时移除List中的元素首先，看一下在迭代过程中移除List中元素的代码： 12345ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList("a", "b", "c", "d"));for (int i = 0; i &lt; list.size(); i++) &#123;4list.remove(i);&#125;System.out.println(list); 这个示例代码的输出结果是： [b, d] 这个示例代码中存在一个非常严重的错误。当一个元素被移除时，该List的大小(size)就会缩减，同时也改变了索引的指向。所以，在迭代的过程中使用索引，将无法从List中正确地删除多个指定的元素。 你可能知道解决这个错误的方式之一是使用迭代器(iterator)。而且，你可能认为Java中的 foreach 语句与迭代器(iterator)是非常相似的，但实际情况并不是这样。我们考虑一下如下的示例代码： 这个示例代码会抛出来一个 ConcurrentModificationException。我们应该修改成如下所示： 12345ArrayList&amp;lt;String&amp;gt; list = new ArrayList&lt;String&gt;(Arrays.asList("a", "b", "c", "d"));for (String s : list) &#123;4if ("a".equals(s))4list.remove(s);&#125; next()方法必须在remove()方法之前被调用。 在 foreach 循环中，编译器使得 remove()方法先于next()方法被调用，这就导致了 ConcurrentModificationException 异常。具体细节可以查看 ArrayList.iterator()的源码。 四、Hashtable vs HashMap学习过数据结构的读者都知道一种非常重要的数据结构叫做 哈希表。在Java中，对应哈希表的的类是 HashMap 而不是 Hashtable。HashMap与Hashtable之间的最核心区别就是：HashMap是非同步的，Hashtable是同步的。 五、在Collection中使用原始类型在Java中，很容易把原始类型与无限通配类型混淆。我们举个Set相关的例子：Set就是原始类型；Set&lt;?&gt;就是无限通配类型。我们看一个使用在List中使用原始类型的例子： 12345678public static void add(List list, Object o)&#123;4list.add(o);&#125;public static void main(String[] args)&#123;4List&lt;String&gt; list = new ArrayList&lt;String&gt;();4add(list, 10);4String s = list.get(0);&#125; 这个示例代码会抛出来一个异常： Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at … 在Collection使用原始类型是具有很多的类型错误风险的，因为原始类型没有静态类型检查。实际上，Set、Set&lt;?&gt;和Set之间具有非常大的差异。 六、访问权限很多的Java初学者喜欢使用 public 来修饰类的成员。这样可以很方便地直接访问和存取该成员。但是，这是一种非常糟糕的编程风格，正确的设计风格应该是尽可能降低类成员的访问权限。 七、ArrayList vs LinkedList很多的Java初学者不明白ArrayList与LinkedList之间的区别，所以，他们完全只用相对简单的ArrayList，甚至不知道JDK中还存在LinkedList。但是，在某些具体场景下，这两种List的选择会导致程序性能的巨大差异。简单而言：当应用场景中有很多的 add/remove 操作，只有少量的随机访问操作时，应该选择LinkedList;在其他的场景下，考虑使用ArrayList。 八、可变 vs 不可变不可变的对象具有非常多的优势，比如简单，安全等。但是，对于每一个不同的值，都需要该类的一个对象。而且，生成很多对象带来的问题就是可能导致频繁的垃圾回收。所以，在选择可变类还是不可变类时，应该综合考虑后再做抉择。 通常而言，可变对象可以避免创建大量的中间对象。一个非常经典的例子就是链接大量的短String对象为一个长的String对象。如果使用不可变String类，链接的过程将产生大量的，适合立即被垃圾回收的中间String对象，这将消耗大量的CPU性能和内存空间。此时，使用一个可变的StringBuilder或StringBuffer才是正确的。 1234String result = "";for(String s: arr)&#123;4result = result + s;&#125; 除了上述情况，可变对象在其他场景下可能由于不可变对象。比如，传递一个可变的对象到方法内部，利用该对象可以收集多个结果，而不用在多个循环层次中跳进跳出。。 九、继承中的构造函数上图中出现的两个编译时错误是因为：父类中没有定义默认构造函数，而子类中又调用了父类的默认构造函数。在Java中，如果一个类不定义任何构造函数，编译期将自动插入一个默认构造函数到给类中。一旦一个类定义了任何一个构造函数，编译期就不会插入任何构造函数到类中。在上面的示例中，Super类定义了一个参数类型为String的构造函数，所以该类中只有一个构造函数，不会有默认构造函数了。 &amp;emps;在我们的子类 Sub 中，我们定义了两个构造函数：一个参数类型为String的构造函数，另一个为午餐的默认函数。由于它们都没有在函数体的第一行指定调用父类的哪一个构造函数，所以它们都需要调用父类 Super 的默认构造函数。但是，父类 Super 的默认构造函数是不存在的，所以编译器报告了这两个错误信息。 十、字符串对象的两个构建方式Java中的字符串对象具有两个常见的创建方式： 1234// 1. use double quotesString x = "abc";// 2. use constructor&lt;/span&gt;String y = new String("abc"); 它们之间的区别是什么呢？我们再看一下如下的代码： 12345678String a = "abcd";String b = "abcd";System.out.println(a == b); // TrueSystem.out.println(a.equals(b)); // TrueString c = new String("abcd");String d = new String("abcd");System.out.println(c == d); // FalseSystem.out.println(c.equals(d)); // True 本文源自：http://www.cnblogs.com/tiantianbianma/p/7077463.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[35个Java代码性能优化总结]]></title>
    <url>%2F2017%2F06%2F23%2F1075e992.html</url>
    <content type="text"><![CDATA[代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。代码优化的目标是： 1、减小代码的体积 2、提高代码运行的效率 1、尽量指定类、方法的final修饰符带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。 2、尽量重用对象特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。 3、尽可能使用局部变量调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 4、及时关闭流Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。 5、尽量减少对变量的重复计算明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作： 123for (int i = 0; i &lt; list.size(); i++) &#123; ...&#125; 建议替换为： 123for (int i = 0, int length = list.size(); i &lt; length; i++) &#123; ...&#125; 这样，在list.size()很大的时候，就减少了很多的消耗 6、尽量采用懒加载的策略，即在需要的时候才创建例如： 1234String str = "aaa";if (i == 1)&#123; list.add(str);&#125; 建议替换为： 1234if (i == 1)&#123; String str = "aaa"; list.add(str);&#125; 7、慎用异常异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 8、不要在循环中使用try…catch…，应该把其放在最外层除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了 9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例： （1）StringBuilder() // 默认分配16个字符的空间 （2）StringBuilder(int size) // 默认分配size个字符的空间 （3）StringBuilder(String str) // 默认分配16个字符+str.length()个字符空间 可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么： （1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间 （2）把原来的4096个字符拷贝到新的的字符数组中去 这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。 10、当复制大量数据时，使用System.arraycopy()命令11、乘法和除法使用移位操作例如： 1234for (val = 0; val &lt; 100000; val += 5)&#123; a = val * 8; b = val / 2;&#125; 用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： 1234for (val = 0; val &lt; 100000; val += 5)&#123; a = val &lt;&lt; 3; b = val &gt;&gt; 1;&#125; 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。 12、循环内不要不断创建对象引用例如： 123for (int i = 1; i &lt;= count; i++)&#123; Object obj = new Object();&#125; 这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为： 1234Object obj = null;for (int i = 0; i &lt;= count; i++) &#123; obj = new Object();&#125; 这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。 13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销15、不要将数组声明为public static final因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变 16、尽量在合适的场合使用单例使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： （1）控制资源的使用，通过线程同步来控制资源的并发访问 （2）控制实例的产生，以达到节约资源的目的 （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 17、尽量避免随意使用静态变量要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如： 123public class A&#123; private static B b = new B();&#125; 此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止 18、及时清除不再需要的会话为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。 19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断： 12345678if (list instanceof RandomAccess)&#123; for (int i = 0; i &lt; list.size(); i++)&#123;&#125;&#125;else&#123; Iterator&lt;?&gt; iterator = list.iterable(); while(iterator.hasNext())&#123; iterator.next() &#125;&#125; foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。 20、使用同步代码块替代同步方法这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。 21、将常量声明为static final，并以大写命名这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量 22、不要创建一些不使用的对象，不要导入一些不使用的类这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容 23、程序运行过程中避免使用反射关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。 24、使用数据库连接池和线程池这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程 25、使用带缓冲的输入输出流进行IO操作带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率 26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了 27、不要让public方法中有太多的形参public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处： 1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合 2、参数太多势必导致方法调用的出错概率增加 至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参 28、字符串变量和字符串常量equals的时候将字符串常量写在前面这是一个比较常见的小技巧了，如果有以下代码： 1234String str = "123";if (str.equals("123")) &#123; ...&#125; 建议修改为： 123String str = "123"; if ("123".equals(str))&#123; ...&#125; 这么做主要是可以避免空指针异常 29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。 在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码： 123456int i = 2;if (i == 1)&#123; ...&#125;else&#123; ...&#125; C/C++判断”i==1″不成立，所以以0表示，即false。但是如果： 123456int i = 2;if (i = 1) &#123; ...&#125;else&#123; ...&#125; 万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为： 123456int i = 2;if (1 == i) &#123; ...&#125;else&#123; ...&#125; 这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。 但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。 30、不要对数组使用toString()方法看一下对数组使用toString()打印出来的是什么： 1234public static void main(String[] args)&#123; int[] is = new int[]&#123;1, 2, 3&#125;; System.out.println(is.toString());&#125; 结果是： [I@18a992f 本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections&lt;E&gt;重写了Object的toString()方法。 31、不要对超出范围的基本数据类型做向下强制转型这绝不会得到想要的结果： 12345public static void main(String[] args)&#123; long l = 12345678901234L; int i = (int)l; System.out.println(i);&#125; 我们可能期望得到其中的某几位，但是结果却是： 1942892530 解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是： 0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010 一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是： 0111 0011 1100 1110 0010 1111 1111 0010 这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论： 1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f = 3.5f” 2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int 32、公用的集合类中不使用的数据一定要及时remove掉如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。 33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试： 12345678910111213141516171819public static void main(String[] args)&#123; int loopTime = 50000; Integer i = 0; long startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++)&#123; String str = String.valueOf(i); &#125; System.out.println("String.valueOf()：" + (System.currentTimeMillis() - startTime) + "ms"); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++)&#123; String str = i.toString(); &#125; System.out.println("Integer.toString()：" + (System.currentTimeMillis() - startTime) + "ms"); startTime = System.currentTimeMillis(); for(int j = 0; j &lt; loopTime; j++)&#123; String str = i + ""; &#125; System.out.println("i + \"\"：" + (System.currentTimeMillis() - startTime) + "ms"); &#125; 运行结果为： String.valueOf()：11ms Integer.toString()：5ms i + “”：25ms 所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单： 1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断 2、Integer.toString()方法就不说了，直接调用了 3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串 三者对比下来，明显是2最快、1次之、3最慢 34、使用最有效率的方式去遍历Map遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是： 12345678910public static void main(String[] args)&#123; HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); hm.put("111", "222"); Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet(); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); while (iter.hasNext())&#123; Map.Entry&lt;String, String&gt; entry = iter.next(); System.out.println(entry.getKey() + "\t" + entry.getValue()); &#125;&#125; 如果你只是想遍历一下这个Map的key值，那用”Set&lt;String&gt; keySet = hm.keySet();”会比较合适一些 35、对资源的close()建议分开操作意思是，比如我有这么一段代码： 123456try&#123; XXX.close(); YYY.close();&#125;catch (Exception e)&#123; ...&#125; 建议修改为： 12345678910try&#123; XXX.close();&#125;catch (Exception e) &#123; ...&#125;try&#123; YYY.close();&#125;catch (Exception e) &#123; ...&#125; 虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉。 本文源自：https://www.oschina.net/question/2978416_2243019]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程的三种实现方式]]></title>
    <url>%2F2017%2F06%2F21%2F6f73f99b.html</url>
    <content type="text"><![CDATA[Java中的多线程有三种实现方式： 1.继承Thread类，重写run方法。Thread本质上也是一个实现了Runnable的实例，他代表一个线程的实例，并且启动线程的唯一方法就是通过Thread类的start方法。 2.实现Runnable接口，并实现该接口的run()方法.创建一个Thread对象，用实现的Runnable接口的对象作为参数实例化Thread对象，调用此对象的start方法。 3.实现Callable接口，重写call方法。 Callable接口与Runnable接口的功能类似，但提供了比Runnable更强大的功能。有以下三点： 1）.Callable可以在任务结束后提供一个返回值，Runnable没有提供这个功能。 2）.Callable中的call方法可以抛出异常，而Runnable的run方法不能抛出异常。 3）.运行Callable可以拿到一个Future对象，表示异步计算的结果，提供了检查计算是否完成的方法。 需要注意的是，无论用那种方式实现了多线程，调用start方法并不意味着立即执行多线程代码，而是使得线程变为可运行状态。 以下为大家提供一个简单的代码实例： 分别用Runnable和Thread方法实现，展示各个方法的 实现Runnable接口12345678910111213141516171819202122232425262728293031public class TestRunnable implements Runnable &#123; private int time=1; private SourceA s; private String id = "001"; public TestRunnable(SourceA s)&#123; this.s = s; &#125; public void setTime(int time) &#123; this.time = time; &#125; @Override public void run() &#123; try &#123; System.out.println("i will sleep"+ time); Thread.sleep(time); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; synchronized(s)&#123; s.notify(); System.out.println("我唤醒了002！"); System.out.println("我存入了id"+id); s.setSource(id); &#125; &#125;&#125; 继承Thread类1234567891011121314151617181920212223242526272829303132333435363738public class TestThread extends Thread &#123; private int time = 1; private SourceA s = null; String id = "002"; public void setTime(int time) &#123; this.time = time; &#125; public TestThread(SourceA s)&#123; this.s = s ; &#125; @Override public void run() &#123; try &#123; System.out.println("i will sleep"+ time); sleep(time); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; synchronized(s)&#123; try &#123; System.out.println("我"+ id +"要进行等待了"); s.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println("我被唤醒了"); System.out.println("我存入了id"+id); s.setSource(id); &#125; &#125;&#125; SourceA类代码： 1234567891011public class SourceA &#123; private List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); public synchronized void getSource()&#123; for(int i=0;i&amp;lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125; &#125; public synchronized void setSource(String id)&#123; list.add(id); &#125;&#125; Test测试类代码： 12345678910public void test()&#123; SourceA s = new SourceA(); TestThread tt = new TestThread(s); TestRunnable tr = new TestRunnable(s); Thread t = new Thread(tr); System.out.println("调用线程1"); tt.start(); System.out.println("调用线程2"); t.start();&#125; 运行结果： run start的区别start方法是启动一个线程，而线程中的run方法来完成实际的操作。 如果开发人员直接调用run方法，那么就会将这个方法当作一个普通函数来调用，并没有多开辟线程，开发人员如果希望多线程异步执行，则需要调用start方法。 sleep、wait的区别1.两者处理的机制不同，sleep方法主要是，让线程暂停执行一段时间，时间一到自动恢复，并不会释放所占用的锁，当调用wait方法以后，他会释放所占用的对象锁，等待其他线程调用notify方法才会再次醒来。 2.sleep是Threa的静态方法，是用来控制线程自身流程的，而wait是object的方法，用于进行线程通信。 3.两者使用的区域不同。sleep可以在任何地方使用，wait必须放在同步控制方法，或者语句块中执行。 synchronized、notify、wait的运用synchronized关键字有两种用法，synchronized方法和synchronized语句块。 public synchronized void function(){} synchronized(object){} 当某个资源被synchronized所修饰，线程1线程2等多个线程在共同请求这个资源，线程1先请求到，调用了对象的wait方法释放了对象的锁，此时线程2可以对这个对象进行访问，在工作结束时可以调用对象的notify方法，唤醒等待队列中正在等待的线程，此时被唤醒的线程将会再一次拿到对象锁，对对象进行操作。可以调用notifyAll方法，唤醒等待队列中的所有线程。 需要注意的是一个线程被唤醒不代表立即获取对象锁，必须等调用的线程对象的方法推出synchronized块释放对象锁后，被唤醒的进程才会获得对象锁。 本文源自：http://www.cnblogs.com/yfsmooth/p/4652206.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JBOSS安装使用和配置教程]]></title>
    <url>%2F2017%2F06%2F02%2F9b504b05.html</url>
    <content type="text"><![CDATA[JBoss是一个基于J2EE的开放源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。 JBoss是一个管理EJB（Enterprise JavaBean）的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。这篇文章记录了一下自己安装jboss的过程。 1、下载下载安装 http://jbossas.jboss.org/downloads/ 我下载的是：JBoss AS7.1.1.Final 2、解压解压安装包 D:\jboss-as-7.1.1.Final 3、配置环境变量环境变量的设置 JBoss的使用必须有JDK，只有JRE是不行的，所以你的电脑必须首先配置Java环境变量 注意：最新的jboss7同样不支持JDK1.8，请使用JDK1.7或者以下的版本运行jboss 系统变量→新建 JAVA_HOME 变量。 变量值填写jdk的安装目录 系统变量→寻找 Path 变量→编辑 在变量值最后输入%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 系统变量→新建 CLASSPATH变量 变量值填写 .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar（注意最前面有一点） 在环境变量新建一个：JBOSS_HOME 路径为你解压JBOSS的路径：D:\jboss-as-7.1.1.Final 4、启动测试JBOSS打开%JBOSS_HOME%\bin目录下面的standalone.bat（Linux上是standalone.sh）启动JBOSS 然后在IE中输入http://localhost:8080能看到jboss欢迎界面即表示安装成功，如下图所示 5、部署服务把待部署的war文件或者其他文件拷贝到D:\jboss-as-7.1.1.Final\standalone\deployments下面，支持热部署。比如Test.war拷贝到上述目录下面，然后在IE中输入http://localhost:8080/***.jsp？***&amp;***&amp;***就可以进行服务访问了。 6、添加管理员用户如果想要访问后台，需要增加用户才能访问。可在服务端JBoss的bin目录下执行add-user.bat（add-user.sh） 来添加管理员用户 访问http://localhost:9990/console，进入以下页面： 7、修改默认端口号jboss7.1.1的默认端口号是8080，我将修改为8888。 首先打开jboss7.1.1的配置文件standalond.xml,它在D:\profession\jboss-as-7.1.1.Final\standalone\configuration路径下。 然后，查找节点 &lt;socket-binding-group&gt;。里面有 &lt;socket-binding name=”http” port=”8080”/&gt;，将8080修改为8888。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLServer连接错误]]></title>
    <url>%2F2017%2F05%2F17%2F95d600c2.html</url>
    <content type="text"><![CDATA[错误信息： 无法连接到 windows。 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: 命名管道提供程序, error: 40 - 无法打开到 SQL Server 的连接) (Microsoft SQL Server，错误: 53) 今天打开SQL Server 2008 的 SQL Server Management Studio，输入sa的密码发现，无法登陆数据库，提示信息如上： 解决方案： 1、先查看计算机名（Win7系统） 2、 然后在SQL Server Management Studio登录界面选择这个服务器 3、 如果在列表里没有的话就点击 浏览更多 ，就可以找到了 选择好正确的服务器就可以正常登录了 如果还是不行，修改一下计算机名重启后再按照上面的步骤进行]]></content>
      <categories>
        <category>MSSQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC重定向+传参]]></title>
    <url>%2F2017%2F05%2F14%2Fcfef625d.html</url>
    <content type="text"><![CDATA[strtuts有两种跳转方式转发和重定向，那么springMVC的重定向应该如何定义呢？springMVC重定向有几种情况：不带参数跳转，带参数拼接url形式跳转，带参数不拼接参数跳转 不带参重定向方式一：使用ModelAndView 1return new ModelAndView("redirect:/toList"); 这样可以重定向到toList这个方法 方式二：返回String 1return "redirect:/toList"; 带参拼接url重定向方式一：自己手动拼接 1new ModelAndView("redirect:/toListparam1="+value1+"&amp;&amp;param2="+value2); 这样有个弊端，就是传中文可能会有乱码问题 方式二：用RedirectAttributes，这个是发现的一个比较好用的一个类 这里用它的addAttribute方法，这个实际上重定向过去以后你看url，是它自动给你拼了你的url 12attr.addAttribute("param", value);return "redirect:/namespace/toController"; 这样在toController这个方法中就可以通过获得参数的方式获得这个参数，再传递到页面。过去的url还是和方式一一样的 带参不拼接url重定向123456789101112131415161718192021@RequestMapping("/save")public String save(@ModelAttribute("form") Bean form,RedirectAttributes attr)throws Exception &#123;4String code = service.save(form);4if(code.equals("000"))&#123;44attr.addFlashAttribute("name", form.getName()); 44attr.addFlashAttribute("success", "添加成功!");44return "redirect:/index";4&#125;else&#123;44attr.addAttribute("projectName", form.getProjectName()); 44attr.addAttribute("enviroment", form.getEnviroment()); 44attr.addFlashAttribute("msg", "添加出错!错误码为："+rsp.getCode().getCode()+",错误为："+rsp.getCode().getName());44return "redirect:/maintenance/toAddConfigCenter";4&#125;&#125;@RequestMapping("/index")public String save(@ModelAttribute("form") Bean form,RedirectAttributes attr)throws Exception &#123;4return "redirect:/main/list";&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate映射问题]]></title>
    <url>%2F2017%2F05%2F12%2F6512d67b.html</url>
    <content type="text"><![CDATA[错误的关键部分： Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘articleDaoImpl’: Injection of resource methods failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is org.hibernate.AnnotationException: mappedBy reference an unknown target entity property: com.wangzhe.model.Keyword.Articles in com.wangzhe.model.Article.keywords 错误原因： 在one-to-many注解配置： @OneToMany (mappedBy = “Articles”),mappedBy指向的是要关联的属性，而不是要关联的类，如果这样配置，hibernate则会找com.wangzhe.model.Keyword类下面的Articles 属性。但实际上没有这个属性，就会报上面的异常 解决方法： 指定到实际关联的属性：即：@OneToMany (mappedBy = “articles “) &nbsp;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天十道Java面试题（三）]]></title>
    <url>%2F2017%2F05%2F11%2F8372df0e.html</url>
    <content type="text"><![CDATA[一、HashMap和Hashtable的区别HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。 HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 二、GC是什么? 为什么要有GC?GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 三、应用服务器有那些？BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat 四、说出数据连接池的工作机制是什么?J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接标记为空闲，其他调用就可以使用这个连接。 五、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？1234567891011public String translate (String str) &#123;4String tempStr = "";4try &#123;44tempStr = new String(str.getBytes("ISO-8859-1"), "GBK");44tempStr = tempStr.trim();4&#125;4catch (Exception e) &#123;44System.err.println(e.getMessage());4&#125;4return tempStr;&#125; 六、什么是java序列化，如何实现java序列化？序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。 序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。 七、BS与CS的联系与区别C/S是Client/Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。 B/Ｓ是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。 C/S 与 B/S 区别： １．硬件环境不同: C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务. B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行 ２．对安全要求不同 C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息. B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。 ３．对程序架构不同 C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑. B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟. ４．软件重用不同 C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好. B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 ５．系统维护不同 C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统 B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级. ６．处理问题不同 C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统 B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小. ７．用户接口不同 C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高 B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本. ８．信息流不同 C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低 B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心 八、写一个函数要求输入一个字符串和一个字符长度，对该字符串进行分隔；(Core Java)123456789101112public String[] split(String str, int chars)&#123;4int n = (str.length()+ chars - 1)/chars;4String ret[] = new String[n];4for(int i=0; i&amp;lt;n; i++)&#123;44if(i &amp;lt; n-1)&#123;444ret[i] = str.substring(i*chars , (i+1)*chars);44&#125;else&#123;444ret[i] = str.substring(i*chars);44&#125;4&#125;4return ret;&#125; 九、写一种常见排序；（算法）答：C++中冒泡排序： java123456789101112131415void swap( int&amp;amp; a, int&amp;amp; b )&#123;4int c=a; a = b; b = c;&#125;void bubble( int* p, int len )&#123;4bool bSwapped;4do &#123;44bSwapped = false;44for( int i=1; i&amp;lt;len; i++ )&#123;444if( p[i-1]&amp;gt;p[i] )&#123;4444swap( p[i-1], p[i] );4444bSwapped = true;444&#125;44&#125;4&#125;while( bSwapped );&#125; 十、写四个线程，两个对j加1，两个对j减1；(Core Java)答：代码如下： 1234567891011121314151617181920212223242526272829303132333435363738package test;public class TestThread &#123;4int j;4public TestThread(int j) &#123;44this.j = j;4&#125;4private synchronized void inc()&#123;44j++;44System.out.println(j + "--Inc--" + Thread.currentThread().getName());4&#125;4private synchronized void dec()&#123;44j--;44System.out.println(j + "--Dec--" + Thread.currentThread().getName());4&#125;4public void run() &#123;44(new Dec()).start();44new Thread(new Inc()).start();44(new Dec()).start();44new Thread(new Inc()).start();4&#125;4class Dec extends Thread &#123;44public void run() &#123;444for(int i=0; i&amp;lt;100; i++)&#123;4444dec();444&#125;44&#125;4&#125;4class Inc implements Runnable &#123;44public void run() &#123;444for(int i=0; i&amp;lt;100; i++)&#123;4444inc();444&#125;44&#125;4&#125;4public static void main(String[] args) &#123;44(new TestThread(5)).run();4&#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九部烧脑电影推荐、分享]]></title>
    <url>%2F2017%2F05%2F09%2F3ba9746d.html</url>
    <content type="text"><![CDATA[很多人喜欢看高智商电影，我也不例外，有时候越是烧脑刺激的电影越让人有往下观看的欲望，享受深陷其中的快感，下面博主将看过的烧脑电影推荐给大家。（以下排名不分先后） 1、死亡幻觉 简要剧情： 丹尼•达可（杰克•盖伦霍尔 饰）患有精神疾病，某天晚 上他受到莫名的召唤，梦游，也因此逃避了一架飞机坠落在他房间天花板上，这样匪夷所思的事故。 自此以后，他的生活就发生了变化，频频出现幻觉，他时常看见一个兔人弗兰克，后者告诉他世界将在28天6小时48分12秒以后毁灭；他得到了一本书，《时空旅行奥义书》，对书中提到的时空旅行、离线宇宙产生了强烈的好奇。 随着世界末日的临近，杰克的生活越来约诡异，他新认识的女朋友和家人也被卷了进去。看来，杰克想实现拯救世界的愿望，需要付出更多的代价。 下载地址：http://pan.baidu.com/s/1pL0QLS3 密码：vm7z 2、蝴蝶效应 简要剧情： 伊万（艾什顿·库奇 Ashton Kutcher 饰）曾经有一个糟糕的童年，因为他行为闯下了大祸，令他童年充满不堪回忆的往事。而事实上，他确实只是依稀记得一点可怕的情景，这些情景一直纠缠着他的正常生活。伊万接受心理学家建议，把琐碎生活记在记事本里，却偶然发现通过记事本回到过去。 这时他才清楚记起，童年时候的自己做了那么多的错事。他幻想着用现在的意识，潜入童年的身体，去弥补种种过失给人们带来的伤害，尤其是希望与当年暗恋的凯西最终走回一起。然而他一次次的跨越时空的更改，只能越来越招致现实世界的不可救药。一切就像蝴蝶效应般，牵一发而动全身。 下载地址：http://pan.baidu.com/s/1pL7Cvm7 密码：xhut 3、星际穿越 简要剧情： 近未来的地球黄沙遍野，小麦、秋葵等基础农作物相继因枯萎病灭绝，人类不再像从前那样仰望星空，放纵想象力和灵感的迸发，而是每日在沙尘暴的肆虐下倒数着所剩不多的光景。在家务农的前NASA宇航员库珀（马修·麦康纳 Matthew McConaughey 饰）接连在女儿墨菲（麦肯吉·弗依 Mackenzie Foy 饰）的书房发现奇怪的重力场现象，随即得知在某个未知区域内前NASA成员仍秘密进行一个拯救人类的计划。多年以前土星附近出现神秘虫洞，NASA借机将数名宇航员派遣到遥远的星系寻找适合居住的星球。在布兰德教授（迈克尔·凯恩 Michael Caine 饰）的劝说下，库珀忍痛告别了女儿，和其他三名专家教授女儿艾米莉亚·布兰德（安妮·海瑟薇 Anne Hathaway 饰）、罗米利（大卫·吉雅西 David Gyasi 饰）、多伊尔（韦斯·本特利 Wes Bentley 饰）搭乘宇宙飞船前往目前已知的最有希望的三颗星球考察。 他们穿越遥远的星系银河，感受了一小时七年光阴的沧海桑田，窥见了未知星球和黑洞的壮伟与神秘。在浩瀚宇宙的绝望而孤独角落，总有一份超越了时空的笃定情怀将他们紧紧相连…… 下载地址：http://pan.baidu.com/s/1c1QF18O 密码：0c49 4、恐怖游轮 简要剧情： 单亲母亲杰西（梅利莎·乔治 饰）和一帮朋友乘游艇出海游玩，但她总有一种有不好的事情发生的感觉。不久，他们便在海上遭遇一场强烈的风暴。游艇翻船，众人落海，几经挣扎他们好不容易爬到游艇残骸上来。正当他们无计可施之时，一艘巨大的游轮向众人缓缓驶来。众人欣喜过望，未加思索便登上这艘名为“艾俄洛斯”的游轮，结果发现这竟是一艘1930年便告失踪的神秘之船，而船上更是空无一人。 随处可见的鲜血、神秘的指示以及突如其来的凶杀事件，将这群男女带入万劫不复的恐怖轮回之中…… 下载地址：http://pan.baidu.com/s/1cxT5eu 密码：kzpa 5、万能钥匙 简要剧情： 年轻的姑娘卡罗琳（凯特•哈德森 Kate Hudson 饰）受雇于老妇人维奥莱特（吉娜•罗兰兹 Gena Rowlands 饰），前往她家照顾她卧病在床的丈夫本（约翰•赫特 John Hurt 饰）。维奥莱特的大房子坐落于以神秘习俗和宗教仪式闻名的地区，卡罗琳刚到这里就觉得阴森诡异。随着日子一天天过去，卡罗琳渐渐对这件大房子和古怪的维奥莱特起疑。一次偶然，她从维奥莱特那里得到了一把万能钥匙，用它可以打开这座大房子的所有房间。当卡罗琳走进了隐藏在顶楼的房间时，她看到了令人惊悚的一幕，直觉告诉她，本的卧病在床和维奥莱特以及这间房间有着莫大的关系，她决心揭开这个迷！ 下载地址：http://pan.baidu.com/s/1qYlpIiC 密码：h3t1 6、盗梦空间 简要剧情： 道姆·柯布（莱昂纳多·迪卡普里奥 Leonardo DiCaprio 饰）与同事阿瑟（约瑟夫·戈登-莱维特 Joseph Gordon-Levitt 饰）和纳什（卢卡斯·哈斯 Lukas Haas 饰）在一次针对日本能源大亨齐藤（渡边谦 饰）的盗梦行动中失败，反被齐藤利用。齐藤威逼利诱因遭通缉而流亡海外的柯布帮他拆分他竞争对手的公司，采取极端措施在其唯一继承人罗伯特·费希尔（希里安·墨菲 Cillian Murphy 饰）的深层潜意识中种下放弃家族公司、自立门户的想法。为了重返美国，柯布偷偷求助于岳父迈尔斯（迈克尔·凯恩 Michael Caine 饰），吸收了年轻的梦境设计师艾里阿德妮（艾伦·佩吉 Ellen Page 饰）、梦境演员艾姆斯（汤姆·哈迪 Tom Hardy 饰）和药剂师约瑟夫（迪利普·劳 Dileep Rao 饰）加入行动。在一层层递进的梦境中，柯布不仅要对付费希尔潜意识的本能反抗，还必须直面已逝妻子梅尔（玛丽昂·歌迪亚 Marion Cotillard 饰）的处处破坏，实际情况远比预想危险得多…… 下载地址：http://pan.baidu.com/s/1kV7e9N5 密码：08j4 7、明日边缘 简要剧情： 未来世界陷入外星人入侵的恐慌中，军事演说家凯奇少校参加某个战役的第一天就惨死在战场，没想到这一死让他拥有了时空循环的能力。唯一相信他的人就是被称为“全金属战士”的丽塔·沃拉塔斯基，二人开始了时空循环作战，在训练中他们发现了控制时间的奥秘，而这与外星人“主脑”欧米茄有关，但是唯一能取得胜利的方法就是让凯奇不断死去、不断重启时间…… 下载地址：http://pan.baidu.com/s/1nvBKo45 密码：ucrc 8、源代码 简要剧情： 在阿富汗执行任务的美国空军飞行员在一周前去世，官方通过他尚未完全死亡的脑细胞影像来还原事件，调查事情的真相。最终，科特顺利完成了任务，但是他却决定再一次返回事故现场，拯救那些无辜的生命… 下载地址：http://pan.baidu.com/s/1i5mjXlz 密码：la7q 9、异次元杀阵 简要剧情： 警司昆廷（莫里斯•迪恩•温特Maurice Dean Wint 饰）、监狱专家兼传感器专家伦尼斯（维尼•罗宾逊 Wayne Robson 饰）、医生霍洛韦（尼基•瓜达尼 Nicky Guadagni 饰）、建筑师沃思（戴维•休利特 David Hewlett）、数学系的大学生利文（尼科勒•德搏尔 Nicole de Boer 饰）和身患孤独症的学者卡赞（安德鲁•米勒 Andrew Miller 饰），六个素不相识的人，一觉醒来后发现一同身处于由一个个形状相同的立方体组成的结构复杂的高度精密迷宫中！ 他们唯一的出路只有逃离这座迷宫，然而，一个个立方体尽管外貌相同，然而里面的机关却各不一样，复杂异常。依靠利文数学知识的推理，他们终于以为发现迷宫的运行规律，凭此一次次解开各个机关，迷宫的边缘近在眼前。 当他们正欲合力逃出迷宫之际，意外发生了。 下载地址：http://pan.baidu.com/s/1dFtJDTn 密码：5qda 如果链接失效，您可以 [url href=http://wpa.qq.com/msgrd?v=3&amp;uin=1766462016&amp;site=qq&amp;menu=yes]联系站长[/url]]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring核心技术]]></title>
    <url>%2F2017%2F05%2F06%2Fc8d624da.html</url>
    <content type="text"><![CDATA[Spring既是一个AOP框架，也是一个IOC容器。Spring是分层的Java SE/EE应用一站式的轻量级开源框架，以IoC(Inverse of Control：反转控制)和AOP(AspectOriented Programming：面向切面编程)为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，此外，Spring以海纳百川的胸怀整合了开源世界里众多注明的第三方框架的类库，逐渐成为使用最多的JavaEE企业应用开源框架 Spring IOC控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中我们使用面向对象编程对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 下面来让大家了解一下Spring到底是怎么运行的 首先假设Spring配置文件applicationContext.xml中有如下定义 123&lt;bean id="animal" class="test.springframework.test.Cat"&gt;; &lt;property name="name" value="kitty" /&gt;&lt;/bean&gt; 有一个类test.springframework.test.Cat 123456789&lt;public class Cat implements Animal &#123; private String name; public void say() &#123; System.out.println("I am " + name + "!"); &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 它实现了test.springframework.test.Animal接口 123public interface Animal &#123; public void say();&#125; 模拟spring注入的代码 12345public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext("applicationContext.xml"); Animal animal = (Animal) context.getBean("animal"); animal.say();&#125; Spring AOPAOP（Aspect-OrientedProgramming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。 实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“切面”，从而使得编译器可以在编译期间织入有关“切面”的代码。 如何使用Spring AOP可以通过配置文件或者编程的方式来使用Spring AOP。 配置可以通过xml文件来进行，大概有四种方式： 1、配置ProxyFactoryBean，显式地设置advisors, advice, target等 2、配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象 3、通过&lt;aop:config&gt;来配置 4、通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点 也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象 Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何使用JDK来生成代理对象，具体的生成代码在JdkDynamicAopProxy这个类中： 123456789101112131415 /** * * 获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false) * 检查上面得到的接口中有没有定义 equals或者hashcode的接口 * 调用Proxy.newProxyInstance创建代理对象 * */ public Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Creating JDK dynamic proxy: target source is " +this.advised.getTargetSource()); &#125; Class[] proxiedInterfaces =AopProxyUtils.completeProxiedInterfaces(this.advised); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this); &#125; 我们知道InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法。而通过JdkDynamicAopProxy的签名我们可以看到这个类其实也实现了InvocationHandler，下面我们就通过分析这个类中实现的invoke()方法来具体看下Spring AOP是如何织入切面的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123; MethodInvocation invocation = null; Object oldProxy = null; boolean setProxyContext = false; TargetSource targetSource = this.advised.targetSource; Class targetClass = null; Object target = null; try &#123; //eqauls()方法，具目标对象未实现此方法 if (!this.equalsDefined &amp;amp;&amp;amp; AopUtils.isEqualsMethod(method))&#123; return (equals(args[0])? Boolean.TRUE : Boolean.FALSE); &#125; //hashCode()方法，具目标对象未实现此方法 if (!this.hashCodeDefined &amp;amp;&amp;amp; AopUtils.isHashCodeMethod(method))&#123; return newInteger(hashCode()); &#125; //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知 if (!this.advised.opaque &amp;amp;&amp;amp;method.getDeclaringClass().isInterface() &amp;amp;&amp;amp;method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123; // Service invocations onProxyConfig with the proxy config... return AopUtils.invokeJoinpointUsingReflection(this.advised,method, args); &#125; Object retVal = null; if (this.advised.exposeProxy) &#123; // Make invocation available ifnecessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; //获得目标对象的类 target = targetSource.getTarget(); if (target != null) &#123; targetClass = target.getClass(); &#125; //获取可以应用到此方法上的Interceptor列表 List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass); //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args) if (chain.isEmpty()) &#123; retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args); &#125; else &#123; //创建MethodInvocation invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); retVal = invocation.proceed(); &#125; // Massage return value if necessary. if (retVal != null &amp;amp;&amp;amp; retVal == target &amp;amp;&amp;amp;method.getReturnType().isInstance(proxy) &amp;amp;&amp;amp;!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123; // Special case: it returned"this" and the return type of the method // is type-compatible. Notethat we can't help if the target sets // a reference to itself inanother returned object. retVal = proxy; &#125; return retVal; &#125; finally &#123; if (target != null &amp;amp;&amp;amp; !targetSource.isStatic()) &#123; // Must have come fromTargetSource. targetSource.releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2的核心和工作原理]]></title>
    <url>%2F2017%2F05%2F02%2F2dad7fc2.html</url>
    <content type="text"><![CDATA[Struts设计的第一目标就是使MVC模式应用于web程序设计。 Struts2有两方面的技术优势，一是所有的Struts2应用程序都是基于client/server HTTP交换协议，The JavaServlet API揭示了Java Servlet只是Java API的一个很小子集，这样我们可以在业务逻辑部分使用功能强大的Java语言进行程序设计。 二是提供了对MVC的一个清晰的实现，这一实现包含了很多参与对所以请求进行处理的关键组件，如：拦截器、OGNL表达式语言、堆栈。 工作原理Suruts2的工作原理可以用下面这张图来描述 一个请求在Struts2框架中的处理大概分为以下几个步骤： 1、客户端初始化一个指向Servlet容器（例如Tomcat）的请求 2、这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh Plugin） 3、接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action FilterDispatcher是控制器的核心，就是mvc中c控制层的核心。下面粗略的分析下我理解的FilterDispatcher工作流程和原理：FilterDispatcher进行初始化并启用核心doFilter 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException ...&#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; ServletContext servletContext = filterConfig.getServletContext(); // 在这里处理了HttpServletRequest和HttpServletResponse。 DispatcherUtils du = DispatcherUtils.getInstance(); du.prepare(request, response); // 正如这个方法名字一样进行locale、encoding以及特殊request parameters设置 try ...&#123; request = du.wrapRequest(request, servletContext); // 对request进行包装 &#125; catch (IOException e) ...&#123; String message = "Could not wrap servlet request with MultipartRequestWrapper!"; LOG.error(message, e); throw new ServletException(message, e); &#125; ActionMapperIF mapper = ActionMapperFactory.getMapper(); // 得到action的mapper ActionMapping mapping = mapper.getMapping(request); // 得到action的mapping if (mapping == null) ...&#123; // there is no action in this request, should we look for a static resource? String resourcePath = RequestUtils.getServletPath(request); if ("".equals(resourcePath) &amp;amp;&amp;amp; null != request.getPathInfo()) ...&#123; resourcePath = request.getPathInfo(); &#125; if ("true".equals(Configuration.get(WebWorkConstants.WEBWORK_SERVE_STATIC_CONTENT)) &amp;&amp; resourcePath.startsWith("/webwork")) ...&#123; String name = resourcePath.substring("/webwork".length()); findStaticResource(name, response); &#125; else ...&#123; // this is a normal request, let it pass through chain.doFilter(request, response); &#125; // WW did its job here return; &#125; Object o = null; try ...&#123; //setupContainer(request); o = beforeActionInvocation(request, servletContext); //整个框架最最核心的方法，下面分析 du.serviceAction(request, response, servletContext, mapping); &#125; finally ...&#123; afterActionInvocation(request, servletContext, o); ActionContext.setContext(null); &#125; &#125;du.serviceAction(request, response, servletContext, mapping);// 这个方法询问ActionMapper是否需要调用某个Action来处理这个（request）请求，如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxypublic void serviceAction(HttpServletRequest request, HttpServletResponse response, String namespace, String actionName, Map requestMap, Map parameterMap, Map sessionMap, Map applicationMap) ...&#123; HashMap extraContext = createContextMap(requestMap, parameterMap, sessionMap, applicationMap, request, response, getServletConfig()); // 实例化Map请求 ，询问ActionMapper是否需要调用某个Action来处理这个（request）请求 extraContext.put(SERVLET_DISPATCHER, this); OgnlValueStack stack = (OgnlValueStack) request.getAttribute(ServletActionContext.WEBWORK_VALUESTACK_KEY); if (stack != null) ...&#123; extraContext.put(ActionContext.VALUE_STACK,new OgnlValueStack(stack)); &#125; try ...&#123; ActionProxy proxy = ActionProxyFactory.getFactory().createActionProxy(namespace, actionName, extraContext); // 这里actionName是通过两道getActionName解析出来的, FilterDispatcher把请求的处理交给ActionProxy，下面是ServletDispatcher的 TODO: request.setAttribute(ServletActionContext.WEBWORK_VALUESTACK_KEY, proxy.getInvocation().getStack()); proxy.execute(); //通过代理模式执行ActionProxy if (stack != null)...&#123; request.setAttribute(ServletActionContext.WEBWORK_VALUESTACK_KEY,stack); &#125; &#125; catch (ConfigurationException e) ...&#123; log.error("Could not find action", e); sendError(request, response, HttpServletResponse.SC_NOT_FOUND, e); &#125; catch (Exception e) ...&#123; log.error("Could not execute action", e); sendError(request, response, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e); &#125; &#125; 4、如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy 5、ActionProxy通过ConfigurationManager询问框架的配置文件，找到需要调用的Action类 ,这里，我们一般是从struts.xml配置中读取。 6、ActionProxy创建一个ActionInvocation的实例。 7、ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。 下面我们来看看ActionInvocation是如何工作的： ActionInvocation是Xworks 中Action 调度的核心。而对Interceptor 的调度，也正是由ActionInvocation负责。ActionInvocation 是一个接口，而DefaultActionInvocation 则是Webwork 对ActionInvocation的默认实现。 Interceptor的调度流程大致如下： 1.ActionInvocation初始化时，根据配置，加载Action相关的所有Interceptor。 2\. 通过ActionInvocation.invoke方法调用Action实现时，执行Interceptor。 Interceptor将很多功能从我们的Action中独立出来，大量减少了我们Action的代码，独立出来的行为具有很好的重用性。XWork、WebWork的许多功能都是有Interceptor实现，可以在配置文件中组装Action用到的Interceptor，它会按照你指定的顺序，在Action执行前后运行。 这里，我们简单的介绍一下Interceptor 在struts2中自带了很多拦截器，在struts2-core-2.1.6.jar这个包下的struts-default.xml中我们可以发现： 1234567891011121314151617181920212223242526272829303132333435&lt;interceptors&gt; &lt;interceptor name="alias" class="com.opensymphony.xwork2.interceptor.AliasInterceptor"/&gt; &lt;interceptor name="autowiring" class="com.opensymphony.xwork2.spring.interceptor.ActionAutowiringInterceptor"/&gt; &lt;interceptor name="chain" class="com.opensymphony.xwork2.interceptor.ChainingInterceptor"/&gt; &lt;interceptor name="conversionError" class="org.apache.struts2.interceptor.StrutsConversionErrorInterceptor"/&gt; &lt;interceptor name="clearSession" class="org.apache.struts2.interceptor.ClearSessionInterceptor"/&gt; &lt;interceptor name="createSession" class="org.apache.struts2.interceptor.CreateSessionInterceptor"/&gt; &lt;interceptor name="debugging" class="org.apache.struts2.interceptor.debugging.DebuggingInterceptor"/&gt; &lt;interceptor name="externalRef" class="com.opensymphony.xwork2.interceptor.ExternalReferencesInterceptor"/&gt; &lt;interceptor name="execAndWait" class="org.apache.struts2.interceptor.ExecuteAndWaitInterceptor"/&gt; &lt;interceptor name="exception" class="com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor"/&gt; &lt;interceptor name="fileUpload" class="org.apache.struts2.interceptor.FileUploadInterceptor"/&gt; &lt;interceptor name="i18n" class="com.opensymphony.xwork2.interceptor.I18nInterceptor"/&gt; &lt;interceptor name="logger" class="com.opensymphony.xwork2.interceptor.LoggingInterceptor"/&gt; &lt;interceptor name="modelDriven" class="com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor"/&gt; &lt;interceptor name="scopedModelDriven" class="com.opensymphony.xwork2.interceptor.ScopedModelDrivenInterceptor"/&gt; &lt;interceptor name="params" class="com.opensymphony.xwork2.interceptor.ParametersInterceptor"/&gt; &lt;interceptor name="actionMappingParams" class="org.apache.struts2.interceptor.ActionMappingParametersInteceptor"/&gt; &lt;interceptor name="prepare" class="com.opensymphony.xwork2.interceptor.PrepareInterceptor"/&gt; &lt;interceptor name="staticParams" class="com.opensymphony.xwork2.interceptor.StaticParametersInterceptor"/&gt; &lt;interceptor name="scope" class="org.apache.struts2.interceptor.ScopeInterceptor"/&gt; &lt;interceptor name="servletConfig" class="org.apache.struts2.interceptor.ServletConfigInterceptor"/&gt; &lt;interceptor name="sessionAutowiring" class="org.apache.struts2.spring.interceptor.SessionContextAutowiringInterceptor"/&gt; &lt;interceptor name="timer" class="com.opensymphony.xwork2.interceptor.TimerInterceptor"/&gt; &lt;interceptor name="token" class="org.apache.struts2.interceptor.TokenInterceptor"/&gt; &lt;interceptor name="tokenSession" class="org.apache.struts2.interceptor.TokenSessionStoreInterceptor"/&gt; &lt;interceptor name="validation" class="org.apache.struts2.interceptor.validation.AnnotationValidationInterceptor"/&gt; &lt;interceptor name="workflow" class="com.opensymphony.xwork2.interceptor.DefaultWorkflowInterceptor"/&gt; &lt;interceptor name="store" class="org.apache.struts2.interceptor.MessageStoreInterceptor"/&gt; &lt;interceptor name="checkbox" class="org.apache.struts2.interceptor.CheckboxInterceptor"/&gt; &lt;interceptor name="profiling" class="org.apache.struts2.interceptor.ProfilingActivationInterceptor"/&gt; &lt;interceptor name="roles" class="org.apache.struts2.interceptor.RolesInterceptor"/&gt; &lt;interceptor name="jsonValidation" class="org.apache.struts2.interceptor.validation.JSONValidationInterceptor"/&gt; &lt;interceptor nameinterceptorname="annotationWorkflow" class="com.opensymphony.xwork2.interceptor.annotations.AnnotationWorkflowInterceptor"&gt;&lt;/interceptors&gt; 对于sturts2自带的拦截器，使用起来就相对比较方便了，我们只需要在struts.xml的action标签中加入&lt;interceptor-ref name=”logger “ /&gt;，并且struts.xml扩展struts-default，就可以使用， 如果是要自定义拦截器，首先需要写一个继承AbstractInterceptor 拦截器的类： 123456789101112131415package com.test.interceptors;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.AbstractInterceptor;public class AuthorizationInterceptor extends AbstractInterceptor &#123; @Override public Stringintercept(ActionInvocation ai)throws Exception &#123; System.out.println("abc"); return ai.invoke(); &#125;&#125; 并且在struts.xml中进行配置 123456789101112&lt;!DOCTYPE struts PUBLIC "-//Apache SoftwareFoundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;package name="test"extends="struts-default"&gt; &lt;interceptors&gt; &lt;interceptor name="AuthorizationInterceptor" class ="com.test.interceptors.AuthorizationInterceptor"/&gt; &lt;/interceptors&gt; &lt;action name="TestLogger" class="com.test.action.TestLoggerAction"&gt; &lt;interceptor-ref name="AuthorizationInterceptor"/&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 8、一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2 框架中继承的标签。在这个过程中需要涉及到ActionMapper 在上述过程中所有的对象（Action，Results，Interceptors，等）都是通过ObjectFactory来创建的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天十道JAVA面试题（二）]]></title>
    <url>%2F2017%2F04%2F25%2F65dc7f9b.html</url>
    <content type="text"><![CDATA[一、启动一个线程是用run()还是start()?答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 二、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?答：不能，一个对象的一个synchronized方法只能由一个线程访问。 三、请说出你所知道的线程同步的方法答： wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 四、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 同步的实现方面有两种，分别是synchronized,wait与notify。 五、jsp有哪些内置对象?作用分别是什么?答：JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）： request 用户端请求，此请求会包含来自GET/POST请求的参数 response 网页传回用户端的回应 pageContext 网页的属性是在这里管理 session 与请求有关的会话期 application servlet正在执行的内容 out 用来传送回应的输出 config servlet的构架部件 page JSP网页本身 exception 针对错误网页，未捕捉的例外 六、jsp有哪些动作?作用分别是什么?答:JSP共有以下6种基本动作： jsp:include：在页面被请求的时候引入一个文件。 jsp:useBean：寻找或者实例化一个JavaBean。 jsp:setProperty：设置JavaBean的属性。 jsp:getProperty：输出某个JavaBean的属性。 jsp:forward：把请求转到一个新的页面。 jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记 七、JSP的内置对象及方法答： request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。 response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等） out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。 session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息 applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息 config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。 page表示从该页面产生的一个servlet实例 八、请简述Servlet的生命周期?答: servlet有良好的生命周期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。 Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。 与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。 九、Java四种会话跟踪技术page否是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括被编译成 servlet 的 JSP 页面 request是是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系） session是是代表与用于某个 Web 客户机的一个用户体验相关的对象和属性。一个 Web 会话可以也经常会跨越多个客户机请求 application是是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域 十、给我一个你最常见到的runtime exception答：常见的运行时异常有如下这些： ArithmeticException, ArrayStoreException BufferOverflowException, BufferUnderflowException CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException DOMException, EmptyStackException IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException ProfileDataException, ProviderException RasterFormatException, SecurityException, SystemException UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5AI的完整安装记录]]></title>
    <url>%2F2017%2F04%2F24%2F91b29f60.html</url>
    <content type="text"><![CDATA[h5ai 是HTTP Web服务器的现代文件索引器，专注于您的文件。目录以有吸引力的方式显示，浏览它们通过不同的视图，面包屑和树状概述增强。最初，h5ai是HTML5 Apache Index的缩写，但现在也支持其他Web服务器。 在爬文的时候无意间看到h5ai，在使用h5ai之前尝试过apache目录索引和Apaxy，但是真的没有h5ai漂亮，h5ai给了我们更多的可定制性，但也是配置最复杂的一个，现在我把我配置h5ai的时候遇到的坑跟大家分享一下。 1、下载h5ai下载地址：https://larsjung.de/h5ai/ 2、解压并上传将h5ai最新版本0.29.0解压后的 _h5ai 文件夹上传到网站根目录 3、修改站点默认主页把/_h5ai/public/index.php添加到nignx配置文件，只是添加，当然把原先的删除再添加也是可以的 重载nginx，访问http://域名/_h5ai/public/index.php 注意：尽量使用谷歌浏览器，因为一些浏览器不兼容，无法出现下图的界面 4、安装拓展插件和简单配置默认密码为空，点击login，来到h5ai显示支持界面。 默认如下： 下面主要将上图显示no的选项变为yes，以便h5ai可以实现一些更丰富的功能。 Public Cache directory和Private Cache directory 把h5ai程序_h5ai中private和public两个文件夹中的cache目录权限设置为777，刷新一下网页可以看到两个no变为yes了。 Use EXIF thumbs 安装php的exif模块即可，主要参考http://www.vpser.net/manage/lnmp-php-install-ext.html，把需要的exif模块编译进去，然后重启lnmp即可。 Movie thumbs 选择安装ffmpeg，安装方法参考官网，其中centos的安装ffmpeg方法记得好像很麻烦。最后找到两个打包好的源码包，直接就可以用。 CentOS 64位：http://down.lc/Linux/Tool/ffmpeg-3.1-64bit-static.tar.xz CentOS 32位：http://down.lc/Linux/Tool/ffmpeg-3.1-32bit-static.tar.xz tar xvJf 解压到系统某个地方，然后在/usr/bin/目录创建软链接ffmpeg，指向解压包里面的ffmpeg就可以了，完成后执行ffmpeg，显示版本等信息即可。 也可以选择安装avconv，到http://libav.org/download/下载源码编译安装即可。 PDF thumbs 选择安装convert，直接yum -y install ImageMagick即可。 Shell tar，Shell zip和Shell du 这三项，根据h5ai官网，在php.ini被禁用函数中去掉exec和passthru即可，是否有危险不知道，自己掂量，禁用好像也不影响一些功能，另外顺便把scandir函数去掉禁用，不然会出现无非显示目录中文件的情况。 上面的步骤完成，基本上所有选项都是yes了。 h5ai比较强大，可以实现在线预览音乐，视频，图片等等功能（并不能在线预览所有格式，例如一些avi，flv文件）。 文章参考：http://www.aeaee.com/content/2995.html，感谢作者 中文文件名乱码解决修改系统编码为uft-8即可解决 修改方法： centos6： 1vim /etc/sysconfig/i18n 修改后的内容如下： 12345LANG=&quot;zh_CN.UTF-8&quot;SUPPORTED=&quot;zh_CN.UTF-8:zh_CN:zh&quot;SYSFONT=&quot;latarcyrheb-sun16&quot; centos7： 1vi /etc/locale.conf 修改后的内容如下： 1LANG=&quot;en_US.UTF-8&quot; 或者 1LANG=&quot;zh_CN.UTF-8&quot; 或者使用如下命令修改系统编码 1export LC_ALL=en_US.UTF-8]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天十道Java面试题（一）]]></title>
    <url>%2F2017%2F04%2F21%2Ffe7a9084.html</url>
    <content type="text"><![CDATA[一、谈谈final, finally, finalize的区别答： final—修饰符（关键字）。如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。 finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。 finalize—方法名。java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的 二、sleep() 和 wait() 有什么区别?sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，让出执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。 三、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?方法的重写Overriding和重载Overloading是Java多态性的不同表现。 重写Overriding是父类与子类之间多态性的一种表现， 重载Overloading是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。 Overloaded的方法是可以改变返回值的类型。 四、error和exception有什么区别?error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 五、同步和异步有何异同，在什么情况下分别使用他们？如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 六、abstract class和interface有什么区别?声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。 不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。 不能有抽象构造函数或抽象静态方法。 Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类，取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。 接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。 多继承性可通过实现这样的接口而获得。 接口中的所有方法都是抽象的，没有一个有程序体。 接口只可以定义static final成员变量。 接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。 当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。 由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。 引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。 七、forward 和redirect的区别forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。 八、EJB与JAVA BEAN的区别？Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。 但通常情况下，由于Java Bean是被容器所创建（如Tomcat）的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。 Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。 Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。 但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。 EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。 九、JSP中动态INCLUDE与静态INCLUDE的区别？动态INCLUDE用jsp:include动作实现 它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。 静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面 十、什么时候用assertassertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。 在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或退出。 一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC接收页面表单参数的几种方法]]></title>
    <url>%2F2017%2F04%2F17%2Fdaf362db.html</url>
    <content type="text"><![CDATA[Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。 Spring Web MVC也是服务到工作者模式的实现，但进行可优化。前端控制器是DispatcherServlet；应用控制器其实拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(View Resolver)进行视图管理；页面控制器/动作/处理器为Controller接口（仅包含ModelAndView handleRequest(request, response) 方法）的实现（也可以是任何的POJO类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持。 下面介绍SpringMVC接收页面表单参数的几种方法 1、直接把表单的参数写在Controller相应的方法的形参中 12345@RequestMapping("/addUser1")public String addUser1(String userName,String password) &#123;4System.out.println("userName is:"+userName);4System.out.println("password is:"+password); return "/user/success";&#125; 2、通过HttpServletRequest接收 12345678@RequestMapping("/addUser2")public String addUser2(HttpServletRequest request) &#123;4String userName = request.getParameter("userName");4String password = request.getParameter("password");4System.out.println("userName is:"+userName);4System.out.println("password is:"+password);4return "/user/success";&#125; 通过一个bean来接收 12345678@RequestMapping("/addUser2")public String addUser2(HttpServletRequest request) &#123;4String userName = request.getParameter("userName");4String password = request.getParameter("password");4System.out.println("userName is:"+userName);4System.out.println("password is:"+password);4return "/user/success";&#125; 3、通过json数据接收 123456789101112131415$("#button_submit").click(function()&#123;4var name = $("#userName").val();4var pass = $("#password").val();4var user = &#123;userName:name,password:pass&#125;;//拼装成json格式4$.ajax(&#123;44type:"POST",44url:"$&#123;pageContext.request.contextPath&#125;/user/addUser4",44data:user,44success:function(data)&#123;444alert("成功");44&#125;, error:function(e)&#123;444alert("出错："+e);44&#125;4&#125;);&#125;); 如上只是演示使用方法，实际开发如果表单元素很多，手工拼装成json数据非常麻烦，可以使用jQuery的serializeArray() 方法序列化表单元素 后端依然使用bean来接收json数据 123456@RequestMapping("/addUser4")public String addUser4(User user)&#123;4System.out.println("userName is:"+user.getUserName());4System.out.println("password is:"+user.getPassword());4return "/user/success";&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FontAwesome图标显示为小方块的解决办法]]></title>
    <url>%2F2017%2F04%2F13%2F98556eab.html</url>
    <content type="text"><![CDATA[123*&#123; font-family: "Microsoft YaHei", "微软雅黑" !important;&#125; 问题就出在这，全局的字体样式把FontAwesome的字体样式给覆盖了，而雅黑字体不能显示这个字符，找到问题所在了，那么把FontAwesome的引用放到下面如何呢 123456&lt;style type="text/css"&gt;;* &#123; font-family: "Microsoft YaHei", "微软雅黑" !important;&#125;&lt;/style&gt;&lt;link rel="stylesheet" href="css/font-awesome.min.css"&gt;; 还是显示小方块，回去查看FontAwesome源码发现 123456789101112131415@font-face &#123; font-family: 'FontAwesome'; src: url('../fonts/fontawesome-webfont.eot?v=4.7.0'); src: url('../fonts/fontawesome-webfont.eot?#iefix&amp;amp;v=4.7.0') format('embedded-opentype'), url('../fonts/fontawesome-webfont.woff2?v=4.7.0') format('woff2'), url('../fonts/fontawesome-webfont.woff?v=4.7.0') format('woff'), url('../fonts/fontawesome-webfont.ttf?v=4.7.0') format('truetype'), url('../fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular') format('svg'); font-weight: normal; font-style: normal;&#125;.fa &#123; display: inline-block; font: normal normal normal 14px/1 FontAwesome; font-size: inherit; text-rendering: auto; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; @font-face指定名为”FontAwesome”的字体，并指定在哪里可以找到它的URL，下面的类选择器”.fa”引用上面定义的FontAwesome字体，终于是找到问题根源了，如何解决呢，其实很简单，只需要重写一想类选择器”.fa”的字体样式即可，您可以自行解决，也可以按照我如下的步骤修正Github用的octicons字体、FontAwesome字体、Bootstrap用的glyphicon字体和popular font-face icon 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*----------- 代码开始------------------*//*保留微软雅黑字体*/*&#123;font-family: "Microsoft YaHei", "微软雅黑" !important;&#125;pre, code, textarea, tt, kbd, samp,pre *, code *, textarea *, tt *, kbd *, samp * &#123;font-family: Monaco,"Source Code Pro","Monoco",Consolas !important;&#125;/* http://bashooka.com/freebie/icon-fonts/ *//* zocial */.zocial&#123; font-family : zocial !important;&#125;/* FontAwesome */.fa &#123;font-family: FontAwesome !important;&#125;/* Bootstrap*/.glyphicon&#123;font-family: *Glyphicons Halflings* !important;&#125;/* Github Icons*/.select-menu-loading-overlay:before,.octicon,.mega-octicon,span.diffstat .diffstat-bar,.form-signup-home dl.successed:after,.form-signup-home dl.errored:after&#123;font-family : octicons !important;&#125;/* Symbolsets *//* font-family: "SSStandard";*//* font-family: "SSSocial"; */.ss-icon,[class^="ss-"]:before,[class*=" ss-"]:before,[class^="ss-"].right:after,[class*=" ss-"].right:after,.ss-icon.ss-standard,[class^="ss-"].ss-standard:before,[class*=" ss-"].ss-standard:before,[class^="ss-"].ss-standard.right:after,[class*=" ss-"].ss-standard.right:after &#123;font-family: "SSStandard" !important;&#125;.ss-icon.ss-social-regular,[class^="ss-"].ss-social-regular:before,[class*=" ss-"].ss-social-regular:before,[class^="ss-"].ss-social-regular.right:after,[class*=" ss-"].ss-social-regular.right:after &#123;font-family: "SSSocial" !important;&#125;/* http://typicons.com/ */.typcn:before &#123;font-family: *typicons* !important;&#125;/*------------代码结束------------------*/ 将上面的代码保存一个css文件中，然后在HTML页面中引入此文件即可，或者直接写入到原先的css定义文件中。]]></content>
      <categories>
        <category>frontEnd</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式之代理模式]]></title>
    <url>%2F2017%2F04%2F12%2Faf92ed6c.html</url>
    <content type="text"><![CDATA[简介Java编程的目标是实现现实不能完成的，优化现实能够完成的，是一种虚拟技术。生活中的方方面面都可以虚拟到代码中。代理模式所讲的就是现实生活中的这么一个概念：中介。 代理模式的定义：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 代理模式包含如下角色： ISubject：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。 RealSubject：真实主题角色，是实现抽象主题接口的类。 Proxy：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 实现动态代理的关键技术是反射。 静态代理代理模式有几种，虚拟代理，计数代理，远程代理，动态代理。主要分为两类，静态代理和动态代理。静态代理比较简单，是由程序员编写的代理类，并在程序运行前就编译好的，而不是由程序动态产生代理类，这就是所谓的静态。 考虑这样的场景，管理员在网站上执行操作，在生成操作结果的同时需要记录操作日志，这是很常见的。此时就可以使用代理模式，代理模式可以通过聚合和继承两种方式实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/**方式一：聚合式静态代理 * @author Goser (mailto:goskalrie@163.com) * @Since 2016年9月7日 *///1.抽象主题接口public interface Manager &#123; void doSomething();&#125;//2.真实主题类public class Admin implements Manager &#123; public void doSomething() &#123; System.out.println("Admin do something."); &#125;&#125;//3.以聚合方式实现的代理主题public class AdminPoly implements Manager&#123; private Admin admin; public AdminPoly(Admin admin) &#123; super(); this.admin = admin; &#125; public void doSomething() &#123; System.out.println("Log:admin操作开始"); admin.doSomething(); System.out.println("Log:admin操作结束"); &#125;&#125;//4.测试代码Admin admin = new Admin();Manager m = new AdminPoly(admin);m.doSomething();//方式二：继承式静态代理//与上面的方式仅代理类和测试代码不同//1.代理类public class AdminProxy extends Admin &#123; @Override public void doSomething() &#123; System.out.println("Log:admin操作开始"); super.doSomething(); System.out.println("Log:admin操作开始"); &#125;&#125;//2.测试代码AdminProxy proxy = new AdminProxy();proxy.doSomething(); 聚合实现方式中代理类聚合了被代理类，且代理类及被代理类都实现了同一个接口，可实现灵活多变。继承式的实现方式则不够灵活。 比如，在管理员操作的同时需要进行权限的处理，操作内容的日志记录，操作后数据的变化三个功能。三个功能的排列组合有6种，也就是说使用继承要编写6个继承了Admin的代理类，而使用聚合，仅需要针对权限的处理、日志记录和数据变化三个功能编写代理类，在业务逻辑中根据具体需求改变代码顺序即可。 动态代理一般来说，对代理模式而言，一个主题类与一个代理类一一对应，这也是静态代理模式的特点。 但是，也存在这样的情况，有n各主题类，但是代理类中的“前处理、后处理”都是一样的，仅调用主题不同。也就是说，多个主题类对应一个代理类，共享“前处理，后处理”功能，动态调用所需主题，大大减小了程序规模，这就是动态代理模式的特点。 JDK动态代理实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//1. 抽象主题public interface Moveable &#123; void move() throws Exception;&#125;//2. 真实主题public class Car implements Moveable &#123; public void move() throws Exception &#123; Thread.sleep(new Random().nextInt(1000)); System.out.println("汽车行驶中…"); &#125;&#125;//3.事务处理器public class TimeHandler implements InvocationHandler &#123; private Object target; public TimeHandler(Object target) &#123; super(); this.target = target; &#125; /** * 参数： *proxy 被代理的对象 *method 被代理对象的方法 *args 方法的参数 * 返回： *Object 方法返回值 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long startTime = System.currentTimeMillis(); System.out.println("汽车开始行驶…"); method.invoke(target, args); long stopTime = System.currentTimeMillis(); System.out.println("汽车结束行驶…汽车行驶时间：" + (stopTime - startTime) + "毫秒！"); return null; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) throws Exception&#123; Car car = new Car(); InvocationHandler h = new TimeHandler(car); Class&lt;?&gt; cls = car.getClass(); /** *loader 类加载器 *interfaces 实现接口 *h InvocationHandler */ Moveable m = (Moveable) Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(), h); m.move(); &#125;&#125; 代码讲解：在测试代码中，Proxy.newProxyInstance()方法需要3个参数：类加载器（要进行代理的类）、被代理类实现的接口，事务处理器。所以先实例化Car，实例化InvocationHandler的子类TimeHandler，将各参数传入Proxy的静态方法newProxyInstance()即可获得Car的代理类，前面的静态代理，代理类是我们编写好的，而动态代理则不需要我们去编写代理类，是在程序中动态生成的。 JDK动态代理步骤 创建一个实现InvocationHandler接口的类，它必须实现invoke()方法 创建被代理的类及接口 调用Proxy的静态方法，创建一个代理类 通过代理调用方法 而为什么要进行如此操作，可以从Proxy和InvocationHandler的源码中找打答案。对源码不感兴趣的可以将下面的源码部分小节略过。 123456789101112131415161718192021222324252627282930public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; if (h == null) &#123; throw new NullPointerException(); &#125; final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /*查找或生成指定的代理类*/ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /*用指定的调用处理程序调用它的构造函数.*/ try &#123; //获得类的构造函数 final Constructor&lt;?&gt; cons =cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (sm != null &amp;&amp; ProxyAccessHelper.needsNewInstanceCheck(cl)) &#123; //当需要代理的类实现了一个非public的接口时，因为这样的接口需要特殊的权限，因此调用doPrivilege（native 修饰的方法）创建代理实例。 return AccessController.doPrivileged(newPrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; return newInstance(cons,ih); &#125; &#125;); &#125; else &#123; return newInstance(cons,ih); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString()); &#125;&#125; 可以看到，获得代理类的代码是Class&lt;?&gt;cl = getProxyClass0(loader,intfs); 并由此获得代理类的构造函数，生成代理类的实例返回给该方法的调用者。 继续跟进getProxyClass0()方法： 123456789/** 生成代理类。调用该方法前必须使用checkproxyaccess方法执行权限检查。*/ private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;//检查实现的接口数，65535这个数字好特殊，端口数好像也是这个，这个数字是由虚拟机所决定的，2^16-1个if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; // 如果代理类已经通过实现给定接口的类加载器创建了，则返回缓存中的该类的副本；否则将通过ProxyClassFactory创建代理类 return proxyClassCache.get(loader, interfaces);&#125; 还是没有看到代理类是怎么生成的，只知道代理类是从proxyClassCache中取得的，这个变量是与缓存相关的一个对象，查看该变量的声明与初始化： 12private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); 可以发现proxyClassCache是个用来缓存代理类的类变量，大家知道类变量的特点是与类一一对应，在一个虚拟机中类只有一个，对应着在一个虚拟机中类变量也只有一个，且在此处，在Proxy类被加载的时候就赋值了。在赋值操作的参数中有ProxyClassFactory()这么一个构造函数，这个是动态代理中的关键：生成代理类的类文件字节码。继续跟进去，找到代理类的生成之处了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** 根据给定的类加载器和接口数组生成代理类的工厂类*/private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader,Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // 所有代理类名称的前缀 private static final String proxyClassNamePrefix = "$Proxy"; //用于生成唯一代理类名称的下一个序号 private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader,Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt;interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* 验证类加载器将此接口的名称解析为实际对象的名称。*/ Class&lt;?&gt; interfaceClass =null; try &#123; interfaceClass = Class.forName(intf.getName(),false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + " is not visible from classloader"); &#125; /* 验证类对象确实是一个接口。*/ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); &#125; /*确保接口唯一*/ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // 代理类的包名 /*记录非公开代理接口的包，以便将代理类定义在同一个包中。确认所有非公共代理接口都在同一个包中。*/ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; String name =intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( "non-public interfaces fromdifferent packages"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // 如果没有非公开的代理接口，使用com.sun.proxy作为包名 proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; &#125; /* 生成代理类名的序号*/ long num = nextUniqueNumber.getAndIncrement(); //生成全类名 String proxyName = proxyPkg + proxyClassNamePrefix + num; /*生成代理类字节码 */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName,interfaces); try &#123; return defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; throw new IllegalArgumentException(e.toString()); &#125; &#125; 登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。 这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。 饿汉式和懒汉式区别饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，而懒汉比较懒，只有当调用getInstance的时候，才会去初始化这个单例。 另外从以下两点再区分以下这两种方式： 1、线程安全： 饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题， 懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。 2、资源加载和性能： 饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成， 而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。 至于1、2、3这三种实现又有些区别第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的， 第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗 第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。 什么是线程安全？如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式之单例模式]]></title>
    <url>%2F2017%2F04%2F12%2F25a3ff42.html</url>
    <content type="text"><![CDATA[Java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。 单例模式有以下特点： 1、单例类只能有一个实例。2、单例类必须自己创建自己的唯一实例。3、单例类必须给所有其他对象提供这一实例。 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。 一、懒汉式单例123456789101112//懒汉式单例类.在第一次调用的时候实例化自己public class Singleton &#123;4private Singleton() &#123;&#125;4private static Singleton single=null;4//静态工厂方法4public static Singleton getInstance() &#123;44if (single == null) &#123;44single = new Singleton();44&#125;44returnsingle;4&#125;&#125; 通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问（事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效，此问题在此处不做讨论） 以上懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例，要实现线程安全，有以下三种方式，都是对getInstance这个方法改造，保证了懒汉式单例的线程安全，如果你第一次接触单例模式，对线程安全不是很了解，可以先跳过下面这三小条，去看饿汉式单例，等看完后面再回头考虑线程安全的问题： 1、在getInstance方法上加同步 123456public static synchronized Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single;&#125; 2、双重检查锁定 12345678910public static Singleton getInstance() &#123;4if (singleton == null) &#123;44synchronized (Singleton.class) &#123;444if (singleton == null) &#123;4444singleton = new Singleton();444&#125;44&#125;4&#125;4return singleton; &#125; 3、静态内部类 123456789public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; 二、饿汉式单例123456789//饿汉式单例类.在类初始化时，已经自行实例化public class Singleton1 &#123; private Singleton1() &#123;&#125; private static final Singleton1 single = new Singleton1(); //静态工厂方法 public static Singleton1 getInstance() &#123; return single; &#125;&#125; 饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。 三、登记式单例(可忽略)12345678910111213141516171819202122232425262728293031323334353637//类似Spring里面的方法，将类名注册，下次从里面直接获取。 public class Singleton3 &#123; private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;(); static&#123; Singleton3 single = new Singleton3(); map.put(single.getClass().getName(), single); &#125; //保护的默认构造子 protected Singleton3()&#123;&#125; //静态工厂方法,返还此类惟一的实例 public static Singleton3 getInstance(String name) &#123; if(name == null) &#123; name = Singleton3.class.getName(); System.out.println("name == null"+"---&amp;gt;name="+name); &#125; if(map.get(name) == null) &#123; try &#123; map.put(name, (Singleton3) Class.forName(name).newInstance()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; return map.get(name); &#125; //一个示意性的商业方法 public String about() &#123; return "Hello, I am RegSingleton."; &#125; public static void main(String[] args) &#123; Singleton3 single3 = Singleton3.getInstance(null); System.out.println(single3.about()); &#125; &#125; 登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。 这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。 饿汉式和懒汉式区别饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，而懒汉比较懒，只有当调用getInstance的时候，才会去初始化这个单例。 另外从以下两点再区分以下这两种方式： 1、线程安全： 饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题， 懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。 2、资源加载和性能： 饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成， 而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。 至于1、2、3这三种实现又有些区别第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的， 第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗 第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。 什么是线程安全？如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate的三种状态]]></title>
    <url>%2F2017%2F04%2F11%2F48aba412.html</url>
    <content type="text"><![CDATA[Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。使用Hibernate可以使我们采用面向对象的思维操作关系型数据库。此时，hibernate中对象有三种状态： 瞬时状态（transient） 持久化状态（persistent） 离线状态（detached） 三者之间的区别： 瞬时状态就是刚new出来一个对象，还没有被保存到数据库中，瞬时对象特点：不和Session 实例关联，在数据库中没有和瞬时对象关联的记录（session中没有这个对象，数据库中没有） 持久化状态就是已经被保存到数据库中，持久化对象的特点：和 Session 实例关联，在数据库中有和持久对象关联的记录（session中有此对象，数据库中有） 离线状态就是数据库中有，但是session中不存在该对象，脱管对象特点：本质上和瞬时对象相同，只是比瞬时对象多了一个数据库记录标识值 id（session中没有此对象，数据库中有） Hibernate三种状态中游离对象和瞬时对象异同： 两者都不会被Session关联，对象属性和数据库可能不一致； 游离对象由持久化对象关闭Session而转化而来，在内存中还有对象所以此时就变成游离状态了 三种状态之间是如何进行转换的 上图的解释如下： 使用 fine(),get(),load() 和 iterater() 待方法查询到的数据对象，将成为持久化对象。 通过 Session 的 save() 和 saveOrUpdate() 方法把一个瞬时对象与数据库相关联，这个瞬时对象就成为持久化对象。 与持久对象关联的 Session 被关闭后，对象就变为脱管对象。对游离对象的引用依然有效，对象可继续被修改。 当执行 close() 或 clear(),evict() 之后，持久对象会变为游离对象。 通过 Session 的 update(),saveOrUpdate() 和 lock() 等方法，把游离对象变为持久对象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openVZ安装双倍发包net-Speeder]]></title>
    <url>%2F2017%2F04%2F06%2F98b3c51b.html</url>
    <content type="text"><![CDATA[VPS上可以安装锐速对VPS进行加速，但是这货对 Linux 内核有要求，一般就只能在XEN或者KVM的机子上安装。不过还好锐速有一个免费的代替品：net-speeder。net-speeder可以在高延迟不稳定链路上优化单线程下载速度 安装CentOS用户，可以直接使用net-speeder一键安装包，执行以下命令安装： 123wget --no-check-certificate https://gist.github.com/LazyZhu/dc3f2f84c336a08fd6a5/raw/d8aa4bcf955409e28a262ccf52921a65fe49da99/net_speeder_lazyinstall.shsh net_speeder_lazyinstall.sh Debian/Ubuntu用户，可以直接使用TENNFY WU博主写的net-speeder一键安装包 12345wget --no-check-certificate https://raw.githubusercontent.com/tennfy/debian_netspeeder_tennfy/master/debian_netspeeder_tennfy.shchmod a+x debian_netspeeder_tennfy.shbash debian_netspeeder_tennfy.sh 开启加速安装完成后，会给出脚本用法，最简单的就是开启所有IP协议加速。参数：./net_speeder 网卡名 加速规则（bpf规则）。 1nohup /usr/local/net_speeder/net_speeder venet0 "ip" &gt;/dev/null 2&gt;&amp;&amp; 注意：这里引号中的IP不需要动，有的地方说需要改成自己的IP地址，其实不用改！ 关闭net_speeder1killall net_speeder 查看 net-speeder 是否运行1ps aux|grep net_speeder|grep -v grep 注意事项以下几种情况不适合使用net-speeder: 小流量 VPS，因为使用 net-speeder 会消耗双倍流量。 主要提供网页、图片等小文件访问。net-speeder 对于下载大文件、代理访问视频网站等效果比较好，而对小文件加速效果不明显。 需要使用 pptpd 等不支持双倍发包的网络软件。net-speeder 会造成这些软件无法正常使用。 如果线路本身很好，不存在延迟较大情况，使用 net-speeder 效果会适得其反。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
